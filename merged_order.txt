
/* File: ./server/order-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const morgan = require("morgan");
const connectDB = require("./config/db");
const orderRoutes = require("./routes/orderRoutes");
const cartRoutes = require("./routes/cartRoutes");
const errorHandler = require("./utils/errorHandler");
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan("dev"));

// Database connection
connectDB();

// Routes
app.use("/api/orders", orderRoutes);
app.use("/api/cart", cartRoutes);

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
  console.log(`Order service running on port ${PORT}`);
});

module.exports = app;


/* File: ./server/order-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("MongoDB connected successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server/order-service\controllers\cartController.js */
const Cart = require("../models/Cart");
const restaurantService = require("../services/restaurantService");
const userService = require("../services/userService");
const paymentService = require("../services/paymentService");
const estimationService = require("../services/estimationService");
const orderSplitter = require("../services/orderSplitter");
const Order = require("../models/Order");
const amqp = require("amqplib/callback_api");

// Function to publish the order created event to RabbitMQ
const publishOrderCreatedEvent = (orderId) => {
  amqp.connect("amqp://localhost", (error, connection) => {
    if (error) {
      console.error("RabbitMQ connection error:", error);
      return;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        console.error("RabbitMQ channel error:", error);
        return;
      }

      const queue = "order_created_queue";
      const msg = JSON.stringify({ orderId });

      channel.assertQueue(queue, { durable: true });
      channel.sendToQueue(queue, Buffer.from(msg), { persistent: true });

      console.log(`Order Created Event Sent: ${msg}`);
    });

    setTimeout(() => {
      connection.close();
    }, 500);
  });
};

// Get cart contents
const getCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;

    let cart = await Cart.findOne({ customerId });
    if (!cart) {
      cart = new Cart({ customerId, items: [] });
      await cart.save();
    }

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Add item to cart
const addToCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { restaurantId, menuItemId, name, price, quantity } = req.body;

    // Validate restaurant availability
    const restaurantAvailability =
      await restaurantService.getRestaurantAvailability(restaurantId);
    if (!restaurantAvailability.isAvailable) {
      return res
        .status(400)
        .json({ message: "Restaurant is not available for orders" });
    }

    let cart = await Cart.findOne({ customerId });
    if (!cart) {
      cart = new Cart({ customerId, items: [] });
    }

    // Check if cart already has items from a different restaurant
    const existingRestaurantIds = [
      ...new Set(cart.items.map((item) => item.restaurantId.toString())),
    ];
    if (
      existingRestaurantIds.length > 0 &&
      !existingRestaurantIds.includes(restaurantId.toString())
    ) {
      // We'll still allow adding the item, but include a warning
      cart.items.push({ restaurantId, menuItemId, name, price, quantity });
      await cart.save();

      return res.status(200).json({
        cart,
        warning:
          "Your cart now contains items from multiple restaurants. These will be processed as separate orders during checkout.",
      });
    }

    // Check if item already exists in cart
    const existingItemIndex = cart.items.findIndex(
      (item) =>
        item.menuItemId.toString() === menuItemId &&
        item.restaurantId.toString() === restaurantId
    );

    if (existingItemIndex > -1) {
      // Update quantity if item exists
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item
      cart.items.push({ restaurantId, menuItemId, name, price, quantity });
    }

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Update cart item quantity
const updateCartItem = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { itemId, quantity } = req.body;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    const itemIndex = cart.items.findIndex(
      (item) => item._id.toString() === itemId
    );
    if (itemIndex === -1) {
      return res.status(404).json({ message: "Item not found in cart" });
    }

    if (quantity <= 0) {
      // Remove item if quantity is 0 or negative
      cart.items.splice(itemIndex, 1);
    } else {
      // Update quantity
      cart.items[itemIndex].quantity = quantity;
    }

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Remove item from cart
const removeFromCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { itemId } = req.params;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    cart.items = cart.items.filter((item) => item._id.toString() !== itemId);

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Clear cart
const clearCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    cart.items = [];
    await cart.save();

    res.status(200).json({ message: "Cart cleared successfully", cart });
  } catch (error) {
    next(error);
  }
};

// Convert cart to order(s)
const checkoutCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { deliveryAddress, deliveryLocation } = req.body;
    const token = req.headers.authorization?.split(" ")[1];

    console.log("checkoutCart", req.body);

    const cart = await Cart.findOne({ customerId });
    if (!cart || cart.items.length === 0) {
      return res.status(400).json({ message: "Cart is empty" });
    }

    // Get customer info from user service
    let customerInfo;
    try {
      customerInfo = await userService.getUserInfo(customerId, token);
    } catch (error) {
      console.error("Failed to get user info, using fallback data:", error);
      customerInfo = {
        name: "Customer",
        phone: "Unknown",
      };
    }

    // Group cart items by restaurant
    const itemsByRestaurant = {};
    cart.items.forEach((item) => {
      if (!itemsByRestaurant[item.restaurantId]) {
        itemsByRestaurant[item.restaurantId] = [];
      }
      itemsByRestaurant[item.restaurantId].push(item);
    });

    // Create separate orders for each restaurant
    const orderPromises = Object.keys(itemsByRestaurant).map(
      async (restaurantId) => {
        const restaurantItems = itemsByRestaurant[restaurantId];

        // Calculate total amount for this restaurant's items
        const totalAmount = orderSplitter.calculateOrderTotal(restaurantItems);

        console.log("rest items", restaurantItems);

        // Calculate estimated delivery time
        const estimatedTime = await estimationService.calculateEstimatedTime(
          restaurantItems,
          deliveryLocation,
          [restaurantId]
        );

        // Create order for this restaurant
        const order = new Order({
          customerId,
          customerInfo: {
            name: customerInfo.name || "Customer",
            phone: customerInfo.phone || "Unknown",
          },
          items: restaurantItems,
          deliveryAddress,
          deliveryLocation,
          totalAmount,
          paymentStatus: "pending",
          estimatedDeliveryTime: estimatedTime,
          trackingStatus: "placed",
          statusUpdates: [
            {
              status: "placed",
              timestamp: Date.now(),
              note: "Order placed successfully",
            },
          ],
          restaurantId,
        });

        // Save the order
        const savedOrder = await order.save();

        // Initiate payment process for this order
        const paymentResponse = await paymentService.createPayment(
          savedOrder._id,
          totalAmount,
          customerId,
          `Order #${savedOrder._id} for restaurant ${restaurantId}`,
          token
        );

        // Update order with payment ID
        savedOrder.paymentId = paymentResponse.paymentId;
        await savedOrder.save();

        return {
          order: savedOrder,
          payment: {
            paymentId: paymentResponse.paymentId,
            checkoutUrl: paymentResponse.checkoutUrl,
            paymentParams: paymentResponse.paymentParams,
          },
        };
      }
    );

    // Wait for all orders to be created
    const results = await Promise.all(orderPromises);

    // Clear cart after successful orders
    cart.items = [];
    await cart.save();

    res.status(201).json({
      message: `Created ${results.length} orders from your cart`,
      orders: results,
    });
  } catch (error) {
    next(error);
  }
};

// Checkout items from a specific restaurant only - NEW FUNCTION
const checkoutRestaurant = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { restaurantId, deliveryAddress, paymentMethod } = req.body;
    const token = req.headers.authorization?.split(" ")[1];

    if (!req.body.deliveryLocation || !req.body.deliveryLocation.coordinates) {
      return res.status(400).json({
        message: "Delivery location coordinates are required",
      });
    }

    if (!deliveryAddress) {
      console.log("Delivery address is required");
      return res.status(400).json({ message: "Delivery address is required" });
    }

    // Use default delivery location if not provided
    const deliveryLocation = req.body.deliveryLocation || { lat: 0, lng: 0 };

    const cart = await Cart.findOne({ customerId });
    if (!cart || cart.items.length === 0) {
      return res.status(400).json({ message: "Cart is empty" });
    }

    // Filter for items only from the specified restaurant
    const restaurantItems = cart.items.filter(
      (item) => item.restaurantId.toString() === restaurantId.toString()
    );

    if (restaurantItems.length === 0) {
      return res.status(400).json({
        message: "No items found for this restaurant in your cart",
      });
    }

    // Get customer info from user service
    let customerInfo;
    try {
      customerInfo = await userService.getUserInfo(customerId, token);
    } catch (error) {
      console.error("Failed to get user info, using fallback data:", error);
      customerInfo = {
        name: "Customer",
        phone: "Unknown",
      };
    }

    // Calculate total amount for this restaurant's items
    const totalAmount = orderSplitter.calculateOrderTotal(restaurantItems);

    console.log("rest items", restaurantItems);

    console.log("Delivery location:", deliveryLocation);

    // Calculate estimated delivery time
    const estimatedTime = await estimationService.calculateEstimatedTime(
      restaurantItems,
      deliveryLocation,
      restaurantId
    );

    console.log("estimated time", estimatedTime);

    // Create order for this restaurant
    const order = new Order({
      customerId,
      customerInfo: {
        name: customerInfo.name || "Customer",
        phone: customerInfo.phone || "Unknown",
      },
      items: restaurantItems,
      deliveryAddress,
      deliveryLocation,
      totalAmount,
      paymentStatus: "pending",
      paymentType: paymentMethod,
      estimatedDeliveryTime: estimatedTime,
      trackingStatus: "placed",
      statusUpdates: [
        {
          status: "placed",
          timestamp: Date.now(),
          note: "Order placed successfully",
        },
      ],
      restaurantId,
    });

    // Save the order
    const savedOrder = await order.save();

    // Initiate payment process for this order
    const paymentResponse = await paymentService.createPayment(
      savedOrder._id,
      totalAmount,
      customerId,
      `Order #${savedOrder._id} for restaurant ${restaurantId}`,
      token,
      paymentMethod
    );

    // Update order with payment ID
    savedOrder.paymentId = paymentResponse.paymentId;
    await savedOrder.save();

    // Publish the order created event to RabbitMQ
    publishOrderCreatedEvent(savedOrder._id);

    // IMPORTANT FIX: Remove ONLY the items from this restaurant
    cart.items = cart.items.filter(
      (item) => item.restaurantId.toString() !== restaurantId.toString()
    );
    await cart.save();

    res.status(201).json({
      message: "Order created successfully",
      order: savedOrder,
      payment: {
        paymentId: paymentResponse.paymentId,
        checkoutUrl: paymentResponse.checkoutUrl,
        paymentParams: paymentResponse.paymentParams,
      },
      cart: cart,
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
  checkoutCart,
  checkoutRestaurant, // Export the new function
};


/* File: ./server/order-service\controllers\orderController.js */
const Order = require("../models/Order");
const Cart = require("../models/Cart");
const axios = require("axios");
const orderSplitter = require("../services/orderSplitter");
const restaurantService = require("../services/restaurantService");
const paymentService = require("../services/paymentService");
const notificationService = require("../services/notificationService");
const estimationService = require("../services/estimationService");
const userService = require("../services/userService");
const { RESTAURANT_SERVICE_URL } = process.env;
<<<<<<< HEAD
const amqp = require('amqplib/callback_api');

=======
const amqp = require("amqplib/callback_api");
>>>>>>> main

// Function to publish an event to RabbitMQ
// Function to publish the order created event to RabbitMQ
const publishOrderCreatedEvent = (orderId) => {
<<<<<<< HEAD
  amqp.connect('amqp://localhost', (error, connection) => {
=======
  amqp.connect("amqp://localhost", (error, connection) => {
>>>>>>> main
    if (error) {
      throw error;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        throw error;
      }

<<<<<<< HEAD
      const queue = 'order_created_queue';  // Queue name where delivery service listens
      const msg = JSON.stringify({ orderId });  // Message payload (only orderId)
=======
      const queue = "order_created_queue"; // Queue name where delivery service listens
      const msg = JSON.stringify({ orderId }); // Message payload (only orderId)
>>>>>>> main

      channel.assertQueue(queue, { durable: true });
      channel.sendToQueue(queue, Buffer.from(msg), { persistent: true });

      console.log(`Order Created Event Sent: ${msg}`);
    });

    setTimeout(() => {
      connection.close();
    }, 500);
  });
};

// Create a new order with items from a single restaurant
const createOrder = async (req, res, next) => {
  try {
    const {
      customerId,
      customerInfo,
      items,
      deliveryAddress,
      deliveryLocation,
    } = req.body;

    if (!deliveryAddress) {
      return res.status(400).json({ message: "Delivery address is required" });
    }

    // Ensure all items are from the same restaurant
    const restaurantIds = [
      ...new Set(items.map((item) => item.restaurantId.toString())),
    ];
    if (restaurantIds.length > 1) {
      return res.status(400).json({
        message: "An order can only contain items from a single restaurant",
        restaurantIds,
      });
    }

    const restaurantId = restaurantIds[0];

    // Validate restaurant availability
    const restaurantAvailability =
      await restaurantService.getRestaurantAvailability(restaurantId);
    if (!restaurantAvailability.isAvailable) {
      return res.status(400).json({
        message: "Restaurant is not available for orders",
        restaurantId,
      });
    }

    // Calculate total amount
    const totalAmount = orderSplitter.calculateOrderTotal(items);

    console.log("Delivery location:", deliveryLocation);

    // Calculate estimated delivery time
    const estimatedTime = await estimationService.calculateEstimatedTime(
      items,
      deliveryLocation,
      restaurantId
    );

    // Create the order
    const order = new Order({
      customerId,
      customerInfo,
      items,
      deliveryAddress,
      deliveryLocation,
      totalAmount,
      paymentStatus: "pending",
      estimatedDeliveryTime: estimatedTime,
      trackingStatus: "placed",
      statusUpdates: [
        {
          status: "placed",
          timestamp: Date.now(),
          note: "Order placed successfully",
        },
      ],
      restaurantId,
    });

    const savedOrder = await order.save();

    // Create response data object
    const responseData = {
      order: savedOrder,
    };

    let paymentResponse;

    // Initiate payment process
    try {
      const token = req.headers.authorization?.split(" ")[1];
      console.log("Token being used:", token); // Debug log
      paymentResponse = await paymentService.createPayment(
        savedOrder._id,
        totalAmount,
        customerId,
        `Order #${savedOrder._id} with ${items.length} items`,
        token
      );

      // Store payment ID in order
      savedOrder.paymentId = paymentResponse.paymentId;
      await savedOrder.save();

      // Include payment information in response
      responseData.payment = {
        paymentId: paymentResponse.paymentId,
        checkoutUrl: paymentResponse.checkoutUrl,
        paymentParams: paymentResponse.paymentParams,
      };
    } catch (error) {
      console.error("Error initiating payment:", error);
      return res.status(500).json({ message: "Error initiating payment" });
    }

    // Now paymentResponse is accessible here
    if (paymentResponse) {
      // Update order with payment ID
      savedOrder.paymentId = paymentResponse.paymentId;
      await savedOrder.save();
    }

    // Publish the order created event to RabbitMQ after the order is created
    publishOrderCreatedEvent(savedOrder._id);

    res.status(201).json(savedOrder);
  } catch (error) {
    next(error);
  }
};

// Get order details
const getOrderWithSubOrders = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate("customerId", "name email")
      .populate("items.restaurantId", "name address")
      .populate("restaurantId", "name address")
      .populate("deliveryPersonId", "name phone");

    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    res.json(order);
  } catch (error) {
    next(error);
  }
};

// Get orders by customer
const getCustomerOrders = async (req, res, next) => {
  try {
    const orders = await Order.find({ customerId: req.params.customerId })
      .sort({ createdAt: -1 })
      .populate("restaurantId", "name");

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Get orders by restaurant
const getRestaurantOrders = async (req, res, next) => {
  try {
    const orders = await Order.find({
      restaurantId: req.params.restaurantId,
    })
      .sort({ createdAt: -1 })
      .populate("customerId", "name");

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Update order tracking status
const updateOrderStatus = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const { status, note } = req.body;

    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    // Update tracking status
    order.trackingStatus = status;

    // Add to status updates history
    order.statusUpdates.push({
      status,
      timestamp: Date.now(),
      note: note || "",
    });

    // If status is out_for_delivery, assign delivery person
    if (
      status === "out_for_delivery" &&
      req.user.role === "delivery_personnel"
    ) {
      order.deliveryPersonId = req.user.id;
    }

    await order.save();

    // Notify customer about status update
    await notificationService.sendNotification(
      order.customerId,
      "order_status_update",
      `Your order #${order._id} is now ${status}`,
      { orderId: order._id, status }
    );

    res.status(200).json(order);
  } catch (error) {
    next(error);
  }
};

// Get orders assigned to delivery person
const getDeliveryPersonOrders = async (req, res, next) => {
  try {
    const deliveryPersonId = req.user.id;

    const orders = await Order.find({
      deliveryPersonId,
      trackingStatus: { $in: ["ready_for_pickup", "out_for_delivery"] },
    })
      .sort({ createdAt: -1 })
      .populate("customerId", "name")
      .populate("items.restaurantId", "name address")
      .populate("restaurantId", "name address");

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Get specific order for delivery person
const getDeliveryOrder = async (req, res, next) => {
  try {
    const deliveryPersonId = req.user.id;
    const orderId = req.params.id;

    const order = await Order.findOne({
      _id: orderId,
      deliveryPersonId,
    })
      .populate("customerId", "name email")
      .populate("items.restaurantId", "name address")
      .populate("restaurantId", "name address");

    if (!order) {
      return res
        .status(404)
        .json({ message: "Order not found or not assigned to you" });
    }

    res.json(order);
  } catch (error) {
    next(error);
  }
};

const updateOrderPaymentStatus = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const { paymentStatus, paymentId } = req.body;

    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    // Update payment status
    order.paymentStatus = paymentStatus;
    order.paymentId = paymentId;

    // If payment is completed, update order status
    if (paymentStatus === "completed") {
      order.trackingStatus = "confirmed";
      order.statusUpdates.push({
        status: "confirmed",
        timestamp: Date.now(),
        note: "Payment completed, order confirmed",
      });

      // Notify customer about confirmed order
      await notificationService
        .sendNotification(
          order.customerId,
          "order_confirmed",
          `Your order #${order._id} has been confirmed and is being prepared`,
          { orderId: order._id }
        )
        .catch((err) => console.error("Notification service error:", err));
    } else if (paymentStatus === "failed" || paymentStatus === "cancelled") {
      order.trackingStatus = "cancelled";
      order.statusUpdates.push({
        status: "cancelled",
        timestamp: Date.now(),
        note: "Order cancelled due to payment issues",
      });

      // Notify customer about cancelled order
      await notificationService
        .sendNotification(
          order.customerId,
          "order_cancelled",
          `Your order #${order._id} has been cancelled due to payment issues`,
          { orderId: order._id }
        )
        .catch((err) => console.error("Notification service error:", err));
    }

    await order.save();
    res.status(200).json({ message: "Order payment status updated", order });
  } catch (error) {
    next(error);
  }
};

const updateSubOrderStatus = async (req, res, next) => {
  try {
    const { subOrderId } = req.params;
    const { status, note } = req.body;

    // Find the order containing this sub-order
    const order = await Order.findOne({ "items._id": subOrderId });

    if (!order) {
      return res.status(404).json({ message: "Sub-order not found" });
    }

    // Find the specific item in the order
    const subOrderIndex = order.items.findIndex(
      (item) => item._id.toString() === subOrderId
    );

    if (subOrderIndex === -1) {
      return res.status(404).json({ message: "Sub-order not found in order" });
    }

    // Update the status of the sub-order
    order.items[subOrderIndex].status = status;

    // Add to status updates history if note is provided
    if (note) {
      order.statusUpdates.push({
        status: `sub_order_${status}`,
        timestamp: Date.now(),
        note: note,
        subOrderId: subOrderId,
      });
    }

    await order.save();

    // Notify customer about status update
    await notificationService
      .sendNotification(
        order.customerId,
        "sub_order_status_update",
        `Your item "${order.items[subOrderIndex].name}" is now ${status}`,
        { orderId: order._id, subOrderId: subOrderId, status }
      )
      .catch((err) => console.error("Notification service error:", err));

    res.status(200).json({
      message: "Sub-order status updated successfully",
      order,
    });
  } catch (error) {
    next(error);
  }
};

<<<<<<< HEAD


// controller/orderController.js
// In your OrderController.js file
const getAllOrders = async (req, res) => {
  try {
    const orders = await Order.find(); // Fetch orders from the order service

    // Fetch restaurant details for each order
    const ordersWithRestaurantData = await Promise.all(orders.map(async (order) => {
      const restaurantId = order.restaurantId; // restaurantId is just an ID in the Order model

      // Fetch restaurant data using the restaurantId (make API request to the restaurant service)
      try {
        const restaurantResponse = await axios.get(`http://localhost:3001/api/restaurants/${restaurantId}`);
        const restaurantData = restaurantResponse.data;

        // Attach restaurant data to the order
        return {
          ...order.toObject(),
          restaurant: restaurantData, // Attach the full restaurant details
        };
      } catch (restaurantError) {
        console.error(`Error fetching restaurant data for order ${order._id}: `, restaurantError);
        return {
          ...order.toObject(),
          restaurant: null, // In case of error, you can attach null or default data
        };
      }
    }));

    res.status(200).json({
      status: 'success',
      data: {
        orders: ordersWithRestaurantData, // return orders with restaurant details
      },
    });
  } catch (err) {
    console.error('Error fetching orders:', err);
    res.status(500).json({ message: 'Error fetching orders' });
  }
};


=======
>>>>>>> main
// Export all controller functions
module.exports = {
  createOrder,
  getOrderWithSubOrders,
  getCustomerOrders,
  getRestaurantOrders,
  updateOrderStatus,
  getDeliveryPersonOrders,
  getDeliveryOrder,
  updateOrderPaymentStatus,
  updateSubOrderStatus,
<<<<<<< HEAD
  getAllOrders,
=======
>>>>>>> main
};


/* File: ./server/order-service\models\Cart.js */
const mongoose = require("mongoose");

const cartItemSchema = new mongoose.Schema({
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  menuItemId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  price: {
    type: Number,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
  },
});

const cartSchema = new mongoose.Schema({
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "User",
    unique: true,
  },
  items: [cartItemSchema],
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

cartSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("Cart", cartSchema);


/* File: ./server/order-service\models\Order.js */
const mongoose = require("mongoose");

const orderItemSchema = new mongoose.Schema({
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  menuItemId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  price: {
    type: Number,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
  },
  status: {
    type: String,
    enum: [
      "pending",
      "confirmed",
      "preparing",
      "ready",
      "picked_up",
      "delivered",
      "cancelled",
    ],
    default: "pending",
  },
});

const orderSchema = new mongoose.Schema({
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "User",
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  customerInfo: {
    name: {
      type: String,
      required: true,
    },
    phone: {
      type: String,
      required: true,
    },
  },
  items: [orderItemSchema],
  deliveryAddress: {
    type: String,
    required: true,
  },
  deliveryLocation: {
    type: {
      type: String,
      default: "Point",
    },
    coordinates: [Number], // [longitude, latitude]
  },
  deliveryPersonId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  totalAmount: {
    type: Number,
    required: true,
  },
  paymentType: {
    type: String,
    enum: ["cash", "card"],
    required: true,
    default: "cash",
  },
  paymentStatus: {
    type: String,
    enum: ["pending", "completed", "failed", "refunded"],
    default: "pending",
  },
  paymentId: {
    type: String,
  },
  trackingStatus: {
    type: String,
    enum: [
      "placed",
      "confirmed",
      "preparing",
      "ready_for_pickup",
      "out_for_delivery",
      "delivered",
      "cancelled",
    ],
    default: "placed",
  },
  statusUpdates: [
    {
      status: String,
      timestamp: {
        type: Date,
        default: Date.now,
      },
      note: String,
    },
  ],
  estimatedDeliveryTime: {
    preparationTime: Number,
    travelTime: Number,
    totalEstimatedTime: Number,
    estimatedDeliveryAt: Date,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

orderSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("Order", orderSchema);


/* File: ./server/order-service\routes\cartRoutes.js */
const express = require("express");
const router = express.Router();
const {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
  checkoutCart,
  checkoutRestaurant,
} = require("../controllers/cartController");
const authMiddleware = require("../utils/authMiddleware");

// All cart routes require customer authentication
router.use(authMiddleware(["customer"]));

// Cart routes
router.get("/", getCart);
router.post("/items", addToCart);
router.patch("/items", updateCartItem);
router.delete("/items/:itemId", removeFromCart);
router.delete("/", clearCart);
router.post("/checkout", checkoutRestaurant);

module.exports = router;


/* File: ./server/order-service\routes\orderRoutes.js */
const express = require("express");
const router = express.Router();
const {
  createOrder,
  getOrderWithSubOrders,
  updateSubOrderStatus,
  getCustomerOrders,
  getRestaurantOrders,
  updateOrderStatus,
  getDeliveryPersonOrders,
  getDeliveryOrder,
  updateOrderPaymentStatus,
  getAllOrders,
} = require("../controllers/orderController");
const authMiddleware = require("../utils/authMiddleware");

// Customer routes
router.post("/", authMiddleware(["customer"]), createOrder);
router.get(
  "/customer/:customerId",
  authMiddleware(["customer"]),
  getCustomerOrders
);
router.get(
  "/:id",
  authMiddleware([
    "customer",
    "restaurant_admin",
    "delivery_personnel",
    "internal_service",
  ]),
  getOrderWithSubOrders
);

// Restaurant admin routes
router.patch(
  "/:id/suborders",
  authMiddleware(["restaurant_admin"]),
  updateSubOrderStatus
);
router.get(
  "/restaurant/:restaurantId",
  authMiddleware(["restaurant_admin"]),
  getRestaurantOrders
);

// Order tracking routes
router.patch(
  "/:orderId/status",
  authMiddleware(["restaurant_admin", "delivery_personnel"]),
  updateOrderStatus
);

// Delivery personnel routes
router.patch(
  "/suborders/:subOrderId/status",
  authMiddleware(["delivery_personnel"]),
  updateSubOrderStatus
);

router.get(
  "/delivery/assigned",
  authMiddleware(["delivery_personnel"]),
  getDeliveryPersonOrders
);

router.get(
  "/delivery/order/:id",
  authMiddleware(["delivery_personnel"]),
  getDeliveryOrder
);

router.post(
  "/:orderId/payment-update",
  authMiddleware(["internal_service"]),
  updateOrderPaymentStatus
);

router.get("/", authMiddleware(["restaurant_admin", "admin"]), getAllOrders); // You can modify roles as needed

module.exports = router;


/* File: ./server/order-service\services\estimationService.js */
const axios = require("axios");
const { RESTAURANT_SERVICE_URL } = process.env;

module.exports = {
  calculateEstimatedTime: async (items, deliveryLocation, restaurantId) => {
    if (!items || !Array.isArray(items)) {
      console.log("Warning: items is undefined or not an array");
      return { estimatedTime: 30 }; // Default value
    }
    if (!restaurantId) {
      throw new Error("restaurantId is required for estimation");
    }

    console.log("Calculating estimated time for items:", items);
    console.log("restaurantId:", restaurantId);

    // 1. Calculate preparation time (10 mins per item)
    const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
    const preparationTime = totalItems * 10; // in minutes

    // 2. Get restaurant location from restaurant service
    const restaurantLocation = await axios
      .get(`${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}`)
      .then((res) => res.data.address.geoCoordinates);

    // 3. Calculate distance (simple straight-line calculation)
    const [restaurantLong, restaurantLat] = restaurantLocation.coordinates;
    const [deliveryLong, deliveryLat] = deliveryLocation.coordinates;

    // Haversine formula
    const R = 6371; // Earth's radius in km
    const dLat = ((deliveryLat - restaurantLat) * Math.PI) / 180;
    const dLon = ((deliveryLong - restaurantLong) * Math.PI) / 180;
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos((restaurantLat * Math.PI) / 180) *
        Math.cos((deliveryLat * Math.PI) / 180) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c; // Distance in km

    // 4. Estimate delivery time (assuming 30 km/h average speed)
    const travelTimeMinutes = (distance / 30) * 60;

    // 5. Total estimated time
    return {
      preparationTime,
      travelTime: Math.round(travelTimeMinutes),
      totalEstimatedTime: Math.round(preparationTime + travelTimeMinutes),
      estimatedDeliveryAt: new Date(
        Date.now() + (preparationTime + travelTimeMinutes) * 60 * 1000
      ),
    };
  },
};


/* File: ./server/order-service\services\notificationService.js */
const axios = require("axios");
require("dotenv").config();

const { NOTIFICATION_SERVICE_URL } = process.env;

module.exports = {
  sendNotification: async (userId, type, message, metadata) => {
    try {
      // Check if notification service URL is defined
      if (!NOTIFICATION_SERVICE_URL) {
        console.log(
          "Notification service URL not defined, skipping notification"
        );
        return;
      }

      await axios.post(`${NOTIFICATION_SERVICE_URL}/api/notifications`, {
        userId,
        type,
        message,
        metadata,
      });
    } catch (error) {
      console.error("Error sending notification:", error.message);
      // Fail silently as notification is not critical
    }
  },
};


/* File: ./server/order-service\services\orderSplitter.js */
const _ = require("lodash");

module.exports = {
  // Group items by restaurant
  groupItemsByRestaurant: (items) => {
    return _.groupBy(items, "restaurantId");
  },

  // Calculate total amount for items
  calculateOrderTotal: (items) => {
    return items.reduce((total, item) => {
      return total + item.price * item.quantity;
    }, 0);
  },
};


/* File: ./server/order-service\services\paymentService.js */
// order-service/services/paymentService.js
const axios = require("axios");

const PAYMENT_SERVICE_URL =
  process.env.PAYMENT_SERVICE_URL || "http://localhost:3001";

// Create a payment for an order
const createPayment = async (
  orderId,
  amount,
  customerId,
  description,
  token,
  paymentMethod
) => {
  try {
    console.log("Creating payment with token:", token); // Debug log
    const response = await axios.post(
      `${PAYMENT_SERVICE_URL}/api/payments`,
      {
        orderId,
        amount,
        customerId,
        description,
        paymentMethod,
      },
      {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      }
    );
    return response.data;
  } catch (error) {
    console.error("Error creating payment:", error);
    throw error;
  }
};

// Update order with payment status
const updateOrderPaymentStatus = async (orderId, paymentStatus) => {
  try {
    // Find the order
    const order = await Order.findById(orderId);

    if (!order) {
      throw new Error(`Order not found: ${orderId}`);
    }

    // Update payment status
    order.paymentStatus = paymentStatus;

    // If payment is successful, update order status accordingly
    if (paymentStatus === "SUCCESSFUL") {
      order.status = "CONFIRMED";

      // Notify restaurants about confirmed order
      for (const subOrder of order.subOrders) {
        await restaurantService.notifyOrderConfirmation(
          subOrder.restaurantId,
          orderId,
          subOrder._id
        );
      }

      // Notify customer about confirmed order
      await notificationService.sendNotification(
        order.customerId,
        "order_confirmed",
        `Your order #${order._id} has been confirmed and is being prepared`,
        { orderId: order._id }
      );
    } else if (paymentStatus === "FAILED" || paymentStatus === "CANCELED") {
      order.status = "CANCELLED";

      // Notify customer about cancelled order
      await notificationService.sendNotification(
        order.customerId,
        "order_cancelled",
        `Your order #${order._id} has been cancelled due to payment issues`,
        { orderId: order._id }
      );
    }

    await order.save();

    return order;
  } catch (error) {
    console.error("Error updating order payment status:", error);
    throw error;
  }
};

module.exports = {
  createPayment,
  updateOrderPaymentStatus,
};


/* File: ./server/order-service\services\restaurantService.js */
const axios = require("axios");
require("dotenv").config();

const { RESTAURANT_SERVICE_URL } = process.env;

module.exports = {
  getRestaurantAvailability: async (restaurantId) => {
    try {
      const response = await axios.get(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}/availability`
      );
      return response.data;
    } catch (error) {
      console.error("Error fetching restaurant availability:", error);
      throw error;
    }
  },

  notifyNewOrder: async (restaurantId, orderData) => {
    try {
      await axios.post(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}/orders`,
        orderData
      );
    } catch (error) {
      console.error("Error notifying restaurant about new order:", error);
      throw error;
    }
  },

  getRestaurantDetails: async (restaurantId) => {
    try {
      const response = await axios.get(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}`
      );
      return response.data;
    } catch (error) {
      console.error("Error fetching restaurant details:", error);
      throw error;
    }
  },
};


/* File: ./server/order-service\services\userService.js */
const axios = require("axios");
require("dotenv").config();

const { USER_SERVICE_URL } = process.env;

module.exports = {
  getUserInfo: async (userId, token) => {
    try {
      // Use the correct endpoint
      const response = await axios.get(`${USER_SERVICE_URL}/api/users/me`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      return response.data.data.user;
    } catch (error) {
      console.error("Error fetching user info:", error);
      // Implement fallback mechanism
      try {
        // Try to get user by ID as fallback
        const fallbackResponse = await axios.get(
          `${USER_SERVICE_URL}/api/users/${userId}`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        return fallbackResponse.data.data.user;
      } catch (fallbackError) {
        console.error("Fallback also failed:", fallbackError);
        throw error; // Throw the original error
      }
    }
  },
  verifyDeliveryPerson: async (userId, token) => {
    try {
      const response = await axios.get(`${USER_SERVICE_URL}/api/users/me`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      // Check if the user has the delivery_personnel role
      return response.data.data.user.role === "delivery_personnel";
    } catch (error) {
      console.error("Error verifying delivery person:", error);
      return false;
    }
  },
};


/* File: ./server/order-service\utils\authMiddleware.js */
const jwt = require("jsonwebtoken");
const mongoose = require("mongoose");
require("dotenv").config();

module.exports = (allowedRoles) => {
  return (req, res, next) => {
    // First check for internal API key
    if (req.headers["x-api-key"] === process.env.INTERNAL_API_KEY) {
      // For internal service calls, create a valid ObjectId instead of "system"

      console.log(req.headers["x-api-key"]);
      req.user = {
        id: new mongoose.Types.ObjectId("000000000000000000000000"),
        role: "internal_service",
      };

      // Check if internal_service role is allowed
      if (!allowedRoles.includes("internal_service")) {
        return res
          .status(403)
          .json({ message: "Insufficient permissions for internal service" });
      }

      return next();
    }

    // If no internal API key, proceed with JWT authentication
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "Authentication required" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;

      if (!allowedRoles.includes(decoded.role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      next();
    } catch (error) {
      return res.status(401).json({ message: "Invalid token" });
    }
  };
};


/* File: ./server/order-service\utils\errorHandler.js */
module.exports = (err, req, res, next) => {
  console.error(err.stack);

  if (err.name === "ValidationError") {
    return res.status(400).json({
      message: "Validation error",
      details: err.message,
    });
  }

  if (err.isAxiosError) {
    return res.status(502).json({
      message: "Error communicating with dependent service",
      details: err.message,
    });
  }

  res.status(500).json({ message: "Something went wrong" });
};

