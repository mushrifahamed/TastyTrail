
/* File: ./server/restaurant-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const dotenv = require("dotenv");
const restaurantRoutes = require("./routes/restaurantRoutes");
const rateLimiter = require("./utils/rateLimiter");
const errorHandler = require("./utils/errorHandler");
const cors = require("cors");
const http = require("http"); // Import HTTP to create server
const socketIo = require("socket.io"); // Import socket.io for WebSocket

dotenv.config(); // Load environment variables

const app = express();
const PORT = process.env.PORT || 3001;

// Create HTTP server for Express app and Socket.IO
const httpServer = http.createServer(app);

// Initialize Socket.IO with the HTTP server
const io = socketIo(httpServer);

// Middleware setup
app.use(express.json()); // Parse JSON request bodies
app.use(cors()); // Enable cross-origin requests
app.use(rateLimiter); // Apply rate limiting

// Routes
app.use("/api/restaurants", restaurantRoutes);

// MongoDB Connection
mongoose
  .connect(process.env.DB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Connected to MongoDB");
  })
  .catch((err) => {
    console.error("MongoDB connection error:", err);
  });

// Error handling middleware
app.use(errorHandler);

// Real-time communication with Socket.IO
io.on("connection", (socket) => {
  console.log("A user connected");
  socket.on("disconnect", () => {
    console.log("A user disconnected");
  });
});

// Start the server and listen for incoming requests
httpServer.listen(PORT, () => {
  console.log(`Restaurant Service running on port ${PORT}`);
});


/* File: ./server/restaurant-service\config\dbConfig.js */
const mongoose = require('mongoose');

const connectDB = () => {
  mongoose.connect(process.env.DB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  }).then(() => {
    console.log('MongoDB Connected');
  }).catch((err) => {
    console.error('DB Connection Failed', err);
  });
};

module.exports = connectDB;

/* File: ./server/restaurant-service\config\multerConfig.js */
const multer = require('multer');
const path = require('path');

// Set up storage for images (in the 'uploads' directory)
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');  // Directory to store uploaded images
  },
  filename: (req, file, cb) => {
    const { name, menuItemNames } = req.body;

    // If it's a cover image
    if (file.fieldname === 'coverImage') {
      cb(null, `${name.replace(/\s+/g, '_').toLowerCase()}_cover_image_${Date.now()}${path.extname(file.originalname)}`);
    }
    // If it's a menu item image (for each menu item)
    else if (file.fieldname === 'menuItemImages') {
      const itemName = menuItemNames.split(',')[req.index];  // Assuming menuItemNames are passed in order
      cb(null, `${itemName.replace(/\s+/g, '_').toLowerCase()}_${Date.now()}${path.extname(file.originalname)}`);
    } else {
      cb(null, `${Date.now()}${path.extname(file.originalname)}`);
    }
  },
});

// File filter to accept only images (jpg, jpeg, png)
const fileFilter = (req, file, cb) => {
  const filetypes = /jpeg|jpg|png/;
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = filetypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true); // Accept file
  } else {
    cb(new Error('Invalid file type. Only jpg, jpeg, and png are allowed.'));
  }
};

const upload = multer({ storage, fileFilter });

module.exports = upload;


/* File: ./server/restaurant-service\controllers\restaurantController.js */
const Restaurant = require("../models/restaurantModel");
const { calculateDistance } = require("../utils/geolocation");
const upload = require("../config/multerConfig");

// Add new restaurant with cover image and multiple menu item images
const addRestaurant = async (req, res) => {
  const { name, description, address, menu, operatingHours, menuItemNames } =
    req.body;

  // Handle file upload for the cover image
  const coverImage = req.file ? req.file.path : null; // Store the cover image file path

  // Handle file upload for menu item images (multiple files)
  const menuItemImages = req.files; // Multer will upload multiple files as an array in `req.files`

  try {
    // Check if restaurant already exists
    const existingRestaurant = await Restaurant.findOne({ name });
    if (existingRestaurant) {
      return res.status(400).json({ message: "Restaurant already exists" });
    }

    // Create a new restaurant instance
    const newRestaurant = new Restaurant({
      name,
      description,
      address,
      menu,
      operatingHours,
      availability: true, // Default availability is true
      coverImage, // Save the cover image URL/path
    });

    // For each menu item, associate the uploaded image
    if (menuItemImages) {
      menu.forEach((menuItem, index) => {
        if (menuItemImages[index]) {
          menuItem.image = menuItemImages[index].path; // Assign image path to each menu item
        }
      });
    }

    // Save the new restaurant
    await newRestaurant.save();
    res.status(201).json(newRestaurant);
  } catch (err) {
    res.status(500).json({ message: "Error creating restaurant", err });
  }
};

// Get all restaurants within a certain radius (nearby restaurants)
const getNearbyRestaurants = async (req, res) => {
  const { longitude, latitude, radius } = req.query;

  try {
    // Perform the geospatial query to find nearby restaurants
    const nearbyRestaurants = await Restaurant.aggregate([
      {
        $geoNear: {
          near: {
            type: "Point",
            coordinates: [parseFloat(longitude), parseFloat(latitude)],
          },
          distanceField: "distance", // Ensure this is added
          maxDistance: radius * 1000,
          spherical: true,
          includeLocs: "address.geoCoordinates", // Include coordinates
        },
      },
      {
        $project: {
          name: 1,
          description: 1,
          coverImage: 1,
          menu: 1,
          availability: 1,
          operatingHours: 1, // Explicitly include
          distance: 1, // Include calculated distance
        },
      },
    ]);

    if (nearbyRestaurants.length === 0) {
      return res.status(404).json({ message: "No nearby restaurants found" });
    }

    res.status(200).json(nearbyRestaurants);
  } catch (err) {
    console.error("Error fetching nearby restaurants:", err);
    res.status(500).json({ message: "Error fetching nearby restaurants", err });
  }
};

module.exports = {
  getNearbyRestaurants,
};

// Update restaurant availability
const toggleAvailability = async (req, res) => {
  const { id } = req.params;
  try {
    const restaurant = await Restaurant.findById(id);
    if (!restaurant) {
      return res.status(404).json({ message: "Restaurant not found" });
    }

    restaurant.availability = !restaurant.availability; // Toggle availability
    await restaurant.save();

    res
      .status(200)
      .json({ message: "Restaurant availability updated", restaurant });
  } catch (err) {
    res.status(500).json({ message: "Error updating availability", err });
  }
};

// Manage menu items (add/update/remove items with images)
const manageMenu = async (req, res) => {
  const { restaurantId, action, menuItemId, menuItem } = req.body;

  // Handle image upload for the menu item
  const menuItemImage = req.file ? req.file.path : null;

  try {
    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({ message: "Restaurant not found" });
    }

    // Check if an image needs to be added or updated for the menu item
    if (menuItemImage) {
      menuItem.image = menuItemImage;
    }

    if (action === "add") {
      restaurant.menu.push(menuItem);
    } else if (action === "update") {
      const index = restaurant.menu.findIndex(
        (item) => item._id.toString() === menuItemId
      );
      if (index === -1) {
        return res.status(404).json({ message: "Menu item not found" });
      }
      restaurant.menu[index] = menuItem; // Update the menu item
    } else if (action === "remove") {
      restaurant.menu = restaurant.menu.filter(
        (item) => item._id.toString() !== menuItemId
      ); // Remove item
    }

    await restaurant.save();
    res.status(200).json({ message: "Menu updated", restaurant });
  } catch (err) {
    res.status(500).json({ message: "Error managing menu", err });
  }
};

// Search restaurants by filters (cuisine, price, rating)
const searchRestaurants = async (req, res) => {
  const { cuisine, priceRange, rating } = req.query;

  try {
    const query = {};

    if (cuisine) query["menu.category"] = cuisine;
    if (priceRange) query["menu.price"] = { $lte: priceRange };
    if (rating) query["rating"] = { $gte: rating };

    const restaurants = await Restaurant.find(query);
    res.status(200).json(restaurants);
  } catch (err) {
    res.status(500).json({ message: "Error searching restaurants", err });
  }
};

const getRestaurantAvailability = async (req, res) => {
  try {
    const { id } = req.params;
    const restaurant = await Restaurant.findById(id);

    if (!restaurant) {
      return res.status(404).json({ message: "Restaurant not found" });
    }

    res.status(200).json({
      restaurantId: restaurant._id,
      isAvailable: restaurant.availability,
    });
  } catch (err) {
    res
      .status(500)
      .json({ message: "Error checking restaurant availability", err });
  }
};

const getRestaurantById = async (req, res) => {
  try {
    const restaurant = await Restaurant.findById(req.params.id);
    if (!restaurant) {
      return res.status(404).json({ message: "Restaurant not found" });
    }
    res.status(200).json(restaurant);
  } catch (err) {
    res.status(500).json({ message: "Error fetching restaurant", err });
  }
};

module.exports = {
  addRestaurant,
  getNearbyRestaurants,
  toggleAvailability,
  manageMenu,
  searchRestaurants,
  getRestaurantAvailability,
  getRestaurantById,
};


/* File: ./server/restaurant-service\middleware\authMiddleware.js */
const jwt = require('jsonwebtoken');

// const verifyToken = (req, res, next) => {
//   const token = req.header('Authorization');
//   if (!token) return res.status(401).json({ message: 'No token, authorization denied' });

//   try {
//     const decoded = jwt.verify(token, process.env.JWT_SECRET);
//     req.user = decoded;
//     next();
//   } catch (err) {
//     res.status(400).json({ message: 'Invalid token' });
//   }
// };

// module.exports = verifyToken;

const verifyToken = (req, res, next) => {
    // Bypass authentication for testing
    next();
  };
  
  module.exports = verifyToken;  

/* File: ./server/restaurant-service\models\restaurantModel.js */
const mongoose = require('mongoose');

const menuItemSchema = new mongoose.Schema({
  name: String,
  description: String,
  price: Number,
  category: String,
  image: String, // menu item image
});

const restaurantSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  description: String,
  address: {
    street: String,
    city: String,
    country: String,
    geoCoordinates: {
      type: { type: String, default: 'Point' },
      coordinates: [Number], // [longitude, latitude]
    },
  },
  menu: [menuItemSchema],
  availability: { type: Boolean, default: true },
  operatingHours: {
    from: { type: String },
    to: { type: String },
  },
  rating: { type: Number, default: 0 },
  coverImage: String, // restaurant cover image
});

restaurantSchema.index({ 'address.geoCoordinates': '2dsphere' });

const Restaurant = mongoose.model('Restaurant', restaurantSchema);

module.exports = Restaurant;

/* File: ./server/restaurant-service\routes\restaurantRoutes.js */
const express = require("express");
const router = express.Router();
const restaurantController = require("../controllers/restaurantController");
const verifyToken = require("../middleware/authMiddleware");
const upload = require("../config/multerConfig");

// Add a new restaurant should have verifyToken
router.post(
  "/",
  upload.single("coverImage"),
  upload.array("menuItemImages"),
  restaurantController.addRestaurant
);

// get by id
router.get("/:id", restaurantController.getRestaurantById);

// Get nearby restaurants
router.get("/nearby", restaurantController.getNearbyRestaurants);

// Update restaurant availability should have verifyToken
router.put("/:id/availability", restaurantController.toggleAvailability);

// Manage menu (add/update/remove items) shoul have verify token
router.put(
  "/:id/menu",
  upload.single("menuItemImage"),
  restaurantController.manageMenu
);

// search restaurants
router.get("/search", restaurantController.searchRestaurants);

// check availability
router.get("/:id/availability", restaurantController.getRestaurantAvailability);

module.exports = router;


/* File: ./server/restaurant-service\utils\errorHandler.js */
const errorHandler = (err, req, res, next) => {
    const statusCode = err.statusCode || 500;
    const message = err.message || 'Internal Server Error';
    res.status(statusCode).json({ message });
  };
  
  module.exports = errorHandler;  

/* File: ./server/restaurant-service\utils\geolocation.js */
const geolib = require('geolib');

// Function to calculate the distance between two geo-coordinates
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  return geolib.getDistance(
    { latitude: lat1, longitude: lon1 },
    { latitude: lat2, longitude: lon2 }
  );
};

module.exports = { calculateDistance };

/* File: ./server/restaurant-service\utils\rateLimiter.js */
const rateLimit = require('express-rate-limit');

// Apply a rate limit of 100 requests per 1 minute per IP address
const rateLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 100,                 // Limit each IP to 100 requests per windowMs
  message: "Too many requests, please try again later.", // Custom error message
});

module.exports = rateLimiter;
