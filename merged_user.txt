
/* File: ./client_customer\.dart_tool\dartpad\web_plugin_registrant.dart */
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:firebase_core_web/firebase_core_web.dart';
import 'package:firebase_messaging_web/firebase_messaging_web.dart';
import 'package:geolocator_web/geolocator_web.dart';
import 'package:google_maps_flutter_web/google_maps_flutter_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  FirebaseCoreWeb.registerWith(registrar);
  FirebaseMessagingWeb.registerWith(registrar);
  GeolocatorPlugin.registerWith(registrar);
  GoogleMapsPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}


/* File: ./client_customer\.dart_tool\flutter_build\dart_plugin_registrant.dart */
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.2

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:geocoding_android/geocoding_android.dart';
import 'package:geolocator_android/geolocator_android.dart';
import 'package:google_maps_flutter_android/google_maps_flutter_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:url_launcher_android/url_launcher_android.dart';
import 'package:geocoding_ios/geocoding_ios.dart';
import 'package:geolocator_apple/geolocator_apple.dart';
import 'package:google_maps_flutter_ios/google_maps_flutter_ios.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:url_launcher_ios/url_launcher_ios.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:geolocator_apple/geolocator_apple.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:url_launcher_macos/url_launcher_macos.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        GeocodingAndroid.registerWith();
      } catch (err) {
        print(
          '`geocoding_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        GeolocatorAndroid.registerWith();
      } catch (err) {
        print(
          '`geolocator_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        GoogleMapsFlutterAndroid.registerWith();
      } catch (err) {
        print(
          '`google_maps_flutter_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherAndroid.registerWith();
      } catch (err) {
        print(
          '`url_launcher_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        GeocodingIOS.registerWith();
      } catch (err) {
        print(
          '`geocoding_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        GeolocatorApple.registerWith();
      } catch (err) {
        print(
          '`geolocator_apple` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        GoogleMapsFlutterIOS.registerWith();
      } catch (err) {
        print(
          '`google_maps_flutter_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherIOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherLinux.registerWith();
      } catch (err) {
        print(
          '`url_launcher_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        GeolocatorApple.registerWith();
      } catch (err) {
        print(
          '`geolocator_apple` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherMacOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherWindows.registerWith();
      } catch (err) {
        print(
          '`url_launcher_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}


/* File: ./client_customer\lib\main.dart */
import 'dart:convert';

import 'package:client_customer/providers/order_provider.dart';
import 'package:client_customer/screens/cart/order_confirmation_screen.dart';
import 'package:client_customer/screens/order/order_tracking_screen.dart';
import 'package:client_customer/screens/restaurant/restaurant_screen.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:provider/provider.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'providers/auth_provider.dart';
import 'providers/cart_provider.dart';
import 'providers/restaurant_provider.dart';
import 'services/auth_service.dart';
import 'models/user.dart';
import 'screens/auth/login_screen.dart';
import 'screens/home/home_screen.dart';
import 'screens/auth/register_screen.dart';
import 'theme/app_theme.dart';
import 'screens/onboarding/onboarding1_screen.dart';
import 'screens/cart/cart_screen.dart';
import 'screens/cart/checkout_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(); // Ensure firebase is initialized

  Future<void> testRegisterToken(String userId) async {
    final fcmToken = await FirebaseMessaging.instance.getToken();
    if (fcmToken != null) {
      await http.post(
        Uri.parse('http://10.0.2.2:5000/api/notifications/register'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'userId': userId,
          'token': fcmToken,
          'role': 'customer',
        }),
      );
      print("✅ Token registered: $fcmToken");
    }
  }

  final authService = AuthService();
  final token = await authService.getToken();
  final userJson = await authService.getUser();
  User? initialUser;
  if (userJson != null) {
    initialUser = User.fromJson(userJson);
  }

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) => AuthProvider()
            ..setToken(token ?? '')
            ..setUser(
              initialUser ?? User(id: '', name: '', email: '', role: ''),
            ),
        ),
        ChangeNotifierProvider(create: (_) => CartProvider()),
        ChangeNotifierProvider(create: (_) => RestaurantProvider()),
        ChangeNotifierProvider(create: (_) => OrderProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ScreenUtilInit(
      designSize: const Size(360, 690),
      builder: (context, child) {
        return MaterialApp(
          title: 'Food Delivery App',
          theme: AppTheme.lightTheme,
          debugShowCheckedModeBanner: false,
          home: Consumer<AuthProvider>(
            builder: (context, authProvider, _) {
              final isCustomer = authProvider.user != null &&
                  authProvider.user!.role == 'customer';
              return (authProvider.isAuth && isCustomer)
                  ? const HomeScreen()
                  : const Onboarding1Screen();
            },
          ),
          routes: {
            '/login': (context) => const LoginScreen(),
            '/register': (context) => const RegisterScreen(),
            '/home': (context) => const HomeScreen(),
            '/restaurant': (context) => RestaurantDetailScreen(
                  restaurantId:
                      ModalRoute.of(context)!.settings.arguments as String,
                ),
            '/orders': (context) => const OrderTrackingScreen(),
            '/cart': (context) => const CartScreen(),
            '/checkout': (context) => const CheckoutScreen(),
            OrderConfirmationScreen.routeName: (context) {
              try {
                print('Initializing OrderConfirmationScreen');
                final args = ModalRoute.of(context)!.settings.arguments;
                if (args == null || args is! Map<String, dynamic>) {
                  throw Exception(
                      'Invalid or missing arguments for OrderConfirmationScreen');
                }
                return OrderConfirmationScreen(orderData: args);
              } catch (e) {
                print('Error initializing OrderConfirmationScreen: $e');
                return Scaffold(
                  appBar: AppBar(title: const Text('Error')),
                  body: Center(
                    child: Text('Failed to load Order Confirmation Screen: $e'),
                  ),
                );
              }
            },
          },
        );
      },
    );
  }
}


/* File: ./client_customer\lib\models\cart.dart */
class CartItem {
  final String id;
  final String restaurantId;
  final String menuItemId;
  final String name;
  final double price;
  int quantity;

  CartItem({
    required this.id,
    required this.restaurantId,
    required this.menuItemId,
    required this.name,
    required this.price,
    required this.quantity,
  });

  factory CartItem.fromJson(Map<String, dynamic> json) {
    return CartItem(
      id: json['_id'] ?? '',
      restaurantId: json['restaurantId'] ?? '',
      menuItemId: json['menuItemId'] ?? '',
      name: json['name'] ?? '',
      price: (json['price'] ?? 0).toDouble(),
      quantity: json['quantity'] ?? 1,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'restaurantId': restaurantId,
      'menuItemId': menuItemId,
      'name': name,
      'price': price,
      'quantity': quantity,
    };
  }
}

class Cart {
  final String customerId;
  final List<CartItem> items;
  final DateTime updatedAt;

  Cart({
    required this.customerId,
    required this.items,
    required this.updatedAt,
  });

  factory Cart.fromJson(Map<String, dynamic> json) {
    return Cart(
      customerId: json['customerId'] ?? '',
      items:
          (json['items'] as List<dynamic>? ?? [])
              .map((item) => CartItem.fromJson(item))
              .toList(),
      updatedAt:
          json['updatedAt'] != null
              ? DateTime.parse(json['updatedAt'])
              : DateTime.now(),
    );
  }

  double get totalAmount {
    return items.fold(0, (sum, item) => sum + (item.price * item.quantity));
  }
}


/* File: ./client_customer\lib\models\order.dart */
// models/order.dart
class Order {
  final String id;
  final String customerId;
  final String restaurantId;
  final String restaurantName;
  final List<OrderItem> items;
  final String deliveryAddress;
  final double totalAmount;
  final String paymentStatus;
  final String trackingStatus;
  final List<StatusUpdate> statusUpdates;
  final DateTime createdAt;

  Order({
    required this.id,
    required this.customerId,
    required this.restaurantId,
    required this.restaurantName,
    required this.items,
    required this.deliveryAddress,
    required this.totalAmount,
    required this.paymentStatus,
    required this.trackingStatus,
    required this.statusUpdates,
    required this.createdAt,
  });

  factory Order.fromJson(Map<String, dynamic> json,
      {String restaurantName = ''}) {
    return Order(
      id: json['_id'] ?? '',
      customerId: json['customerId'] ?? '',
      restaurantId: json['restaurantId'] ?? '',
      restaurantName: restaurantName,
      items: (json['items'] as List<dynamic>? ?? [])
          .map((item) => OrderItem.fromJson(item))
          .toList(),
      deliveryAddress: json['deliveryAddress'] ?? '',
      totalAmount: (json['totalAmount'] ?? 0).toDouble(),
      paymentStatus: json['paymentStatus'] ?? 'pending',
      trackingStatus: json['trackingStatus'] ?? 'placed',
      statusUpdates: (json['statusUpdates'] as List<dynamic>? ?? [])
          .map((update) => StatusUpdate.fromJson(update))
          .toList(),
      createdAt: json['createdAt'] != null
          ? DateTime.parse(json['createdAt'])
          : DateTime.now(),
    );
  }
}

class OrderItem {
  final String id;
  final String name;
  final double price;
  final int quantity;

  OrderItem({
    required this.id,
    required this.name,
    required this.price,
    required this.quantity,
  });

  factory OrderItem.fromJson(Map<String, dynamic> json) {
    return OrderItem(
      id: json['_id'] ?? '',
      name: json['name'] ?? '',
      price: (json['price'] ?? 0).toDouble(),
      quantity: json['quantity'] ?? 1,
    );
  }
}

class StatusUpdate {
  final String status;
  final DateTime timestamp;
  final String note;

  StatusUpdate({
    required this.status,
    required this.timestamp,
    required this.note,
  });

  factory StatusUpdate.fromJson(Map<String, dynamic> json) {
    return StatusUpdate(
      status: json['status'] ?? '',
      timestamp:
          DateTime.parse(json['timestamp'] ?? DateTime.now().toIso8601String()),
      note: json['note'] ?? '',
    );
  }
}


/* File: ./client_customer\lib\models\restaurant.dart */
class MenuItem {
  final String id;
  final String name;
  final String description;
  final double price;
  final String image;

  MenuItem({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    required this.image,
  });

  factory MenuItem.fromJson(Map<String, dynamic> json) {
    return MenuItem(
      id: json['_id'] ?? '',
      name: json['name'] ?? 'No name',
      description: json['description'] ?? '',
      price: (json['price'] ?? 0).toDouble(),
      image: json['image'] ?? '',
    );
  }
}

class Restaurant {
  final String id;
  final String name;
  final String description;
  final String coverImage;
  final List<MenuItem> menu;
  final bool availability;
  final OperatingHours? operatingHours; // Nullable
  final double? distance; // In kilometers

  Restaurant({
    required this.id,
    required this.name,
    required this.description,
    required this.coverImage,
    required this.menu,
    required this.availability,
    this.operatingHours,
    this.distance,
  });

  factory Restaurant.fromJson(Map<String, dynamic> json) {
    // Add debugging
    print('Parsing restaurant JSON: ${json['_id']}');

    final id = json['_id'] is String ? json['_id'] : json['_id'].toString();
    print('Parsed restaurant ID: $id');

    return Restaurant(
      id: json['_id'] ?? '',
      name: json['name'] ?? 'No name',
      description: json['description'] ?? '',
      coverImage: json['coverImage'] ?? '',
      availability: json['availability'] ?? true,
      menu: (json['menu'] as List<dynamic>? ?? [])
          .map((x) => MenuItem.fromJson(x))
          .toList(),
      operatingHours: json['operatingHours'] != null
          ? OperatingHours.fromJson(json['operatingHours'])
          : null,
      distance: json.containsKey('distance')
          ? (json['distance'] ?? 0.0) / 1000
          : null,
    );
  }
}

class OperatingHours {
  final String? from;
  final String? to;

  OperatingHours({this.from, this.to});

  factory OperatingHours.fromJson(Map<String, dynamic> json) {
    return OperatingHours(
      from: json['from']?.toString(),
      to: json['to']?.toString(),
    );
  }
}


/* File: ./client_customer\lib\models\user.dart */
class User {
  final String id;
  final String name;
  final String email;
  final String role;
  final String? phone;
  final String? address;

  User({
    required this.id,
    required this.name,
    required this.email,
    required this.role,
    this.phone,
    this.address,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['_id'],
      name: json['name'],
      email: json['email'],
      role: json['role'],
      phone: json['phone'],
      address: json['address'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      '_id': id,
      'name': name,
      'email': email,
      'role': role,
      'phone': phone,
      'address': address,
    };
  }
}


/* File: ./client_customer\lib\providers\auth_provider.dart */
import 'package:flutter/foundation.dart';
import '../models/user.dart';

class AuthProvider with ChangeNotifier {
  User? _user;
  String? _token;

  User? get user => _user;
  String? get token => _token;
  bool get isAuth => _token != null;

  void setUser(User user) {
    _user = user;
    notifyListeners();
  }

  void setToken(String token) {
    _token = token;
    notifyListeners();
  }

  Future<void> logout() async {
    _user = null;
    _token = null;
    notifyListeners();
  }
}


/* File: ./client_customer\lib\providers\cart_provider.dart */
import 'package:flutter/foundation.dart';
import '../models/cart.dart';
import '../models/restaurant.dart';
import '../services/cart_service.dart';

class CartProvider with ChangeNotifier {
  Cart? _cart;
  bool _isLoading = false;
  String? _error;
  final CartService _cartService = CartService();

  Cart? get cart => _cart;
  bool get isLoading => _isLoading;
  String? get error => _error;
  int get itemCount => _cart?.items.length ?? 0;
  double get totalAmount => _cart?.totalAmount ?? 0.0;

  Future<void> fetchCart() async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.getCart();
      if (result['success']) {
        _cart = Cart.fromJson(result['data']);
      } else {
        _error = result['message'];
      }
    } catch (e) {
      _error = 'Failed to load cart: $e';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<Map<String, dynamic>> addToCart(
    MenuItem menuItem,
    String restaurantId,
    int quantity,
  ) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.addToCart(
        restaurantId: restaurantId,
        menuItemId: menuItem.id,
        name: menuItem.name,
        price: menuItem.price,
        quantity: quantity,
      );

      if (result['success']) {
        _cart = Cart.fromJson(result['data']);
        return {'success': true};
      } else {
        _error = result['message'];
        return {'success': false, 'message': result['message']};
      }
    } catch (e) {
      _error = 'Failed to add item to cart: $e';
      return {'success': false, 'message': _error};
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> updateCartItem(String itemId, int quantity) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.updateCartItem(itemId, quantity);
      if (result['success']) {
        _cart = Cart.fromJson(result['data']);
      } else {
        _error = result['message'];
      }
    } catch (e) {
      _error = 'Failed to update cart item: $e';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> removeFromCart(String itemId) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.removeFromCart(itemId);
      if (result['success']) {
        _cart = Cart.fromJson(result['data']);
      } else {
        _error = result['message'];
      }
    } catch (e) {
      _error = 'Failed to remove item from cart: $e';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> clearCart() async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.clearCart();
      if (result['success']) {
        _cart = Cart.fromJson(result['data']);
      } else {
        _error = result['message'];
      }
    } catch (e) {
      _error = 'Failed to clear cart: $e';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<Map<String, dynamic>> checkout(
    String deliveryAddress,
    Map<String, double> deliveryLocation,
  ) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final result = await _cartService.checkout({
        'address': deliveryAddress,
        'location': deliveryLocation,
      });
      if (result['success']) {
        _cart = Cart.fromJson({
          'customerId': _cart?.customerId ?? '',
          'items': [],
        });
        return {'success': true, 'data': result['data']};
      } else {
        _error = result['message'];
        return {'success': false, 'message': result['message']};
      }
    } catch (e) {
      _error = 'Failed to checkout: $e';
      return {'success': false, 'message': _error};
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Map<String, List<CartItem>> get itemsByRestaurant {
    if (_cart == null) return {};

    Map<String, List<CartItem>> grouped = {};

    for (var item in _cart!.items) {
      if (!grouped.containsKey(item.restaurantId)) {
        grouped[item.restaurantId] = [];
      }
      grouped[item.restaurantId]!.add(item);
    }

    return grouped;
  }

// Calculate total amount for a specific restaurant
  double getTotalAmountForRestaurant(String restaurantId) {
    if (_cart == null) return 0.0;

    return _cart!.items
        .where((item) => item.restaurantId == restaurantId)
        .fold(0.0, (sum, item) => sum + (item.price * item.quantity));
  }

// Checkout items from a specific restaurant
  Future<Map<String, dynamic>> checkoutRestaurant(
    String restaurantId,
    String deliveryAddress,
    String paymentMethod,
    List<double>? coordinates,
  ) async {
    print(
        "[CartProvider] checkoutRestaurant called with restaurantId: $restaurantId, paymentMethod: $paymentMethod"); // Log: Method start
    try {
      _isLoading = true;
      notifyListeners();

      // Filter items for this restaurant
      List<CartItem> restaurantItems = _cart!.items
          .where((item) => item.restaurantId == restaurantId)
          .toList();

      if (restaurantItems.isEmpty) {
        throw Exception('No items for this restaurant');
      }

      // Prepare payload
      final payload = {
        'restaurantId': restaurantId,
        'deliveryAddress': deliveryAddress,
        'paymentMethod': paymentMethod,
        'deliveryLocation': {
          'coordinates': coordinates,
        },
      };
      print(
          "[CartProvider] Calling _cartService.checkoutRestaurant with payload: $payload"); // Log: Before API call

      // Call checkout API
      final response = await _cartService.checkoutRestaurant(
          restaurantId, deliveryAddress, paymentMethod, coordinates);

      // Log response for debugging
      print(
          "[CartProvider] _cartService.checkoutRestaurant response: $response"); // Log: After API call

      // Refresh cart after checkout
      print(
          "[CartProvider] Fetching cart after checkout..."); // Log: Before fetchCart
      await fetchCart();
      print("[CartProvider] Cart fetched."); // Log: After fetchCart

      _isLoading = false;
      notifyListeners();

      // Properly extract order data from the nested structure
      if (response['success'] == true &&
          response['data'] != null &&
          response['data']['order'] != null) {
        print(
            "[CartProvider] Checkout successful, returning order data."); // Log: Success
        return {
          'success': true,
          'order': response['data']['order'],
        };
      } else if (response['success'] == true) {
        // Fallback if the structure isn't as expected but success is true
        print(
            "[CartProvider] Checkout reported success, but order data structure might be unexpected. Returning data."); // Log: Success with fallback
        return {
          'success': true,
          'data': response['data'], // Return the whole data part
          'order': response['data']?['order'] ??
              response['data'] ??
              {}, // Attempt to extract order or return data/empty map
        };
      } else {
        // Handle failure case reported by the service
        print(
            "[CartProvider] Checkout failed according to response: ${response['message']}"); // Log: Failure from response
        _error = response['message'] ?? 'Checkout failed';
        return {
          'success': false,
          'message': _error,
        };
      }
    } catch (error) {
      print(
          "[CartProvider] Error during checkoutRestaurant: $error"); // Log: Catch block error
      _isLoading = false;
      _error = error.toString();
      notifyListeners();
      return {
        'success': false,
        'message': error.toString(),
      };
    }
  }
}


/* File: ./client_customer\lib\providers\order_provider.dart */
// providers/order_provider.dart
import 'package:flutter/foundation.dart';
import '../models/order.dart';
import '../services/order_service.dart';

enum OrderLoadingStatus { initial, loading, loaded, error }

class OrderProvider with ChangeNotifier {
  final OrderService _orderService = OrderService();

  List<Order> _orders = [];
  Order? _selectedOrder;
  OrderLoadingStatus _status = OrderLoadingStatus.initial;
  String? _errorMessage;

  List<Order> get orders => _orders;
  Order? get selectedOrder => _selectedOrder;
  OrderLoadingStatus get status => _status;
  String? get errorMessage => _errorMessage;
  bool get isLoading => _status == OrderLoadingStatus.loading;

  Future<void> fetchCustomerOrders() async {
    _status = OrderLoadingStatus.loading;
    _errorMessage = null;
    notifyListeners();

    try {
      _orders = await _orderService.getCustomerOrders();
      _status = OrderLoadingStatus.loaded;
    } catch (e) {
      _errorMessage = e.toString();
      _status = OrderLoadingStatus.error;
      _orders = [];
    }

    notifyListeners();
  }

  // Other methods omitted for brevity
}


/* File: ./client_customer\lib\providers\restaurant_provider.dart */
// lib/providers/restaurant_provider.dart
import 'package:flutter/foundation.dart';
import '../models/restaurant.dart';
import '../services/restaurant_service.dart';

/// Provider class that manages restaurant-related state and API calls
class RestaurantProvider with ChangeNotifier {
  final RestaurantService _restaurantService = RestaurantService();
  List<Restaurant> _restaurants = [];
  bool _isLoading = false;
  String? _errorMessage;

  /// Gets the list of restaurants
  List<Restaurant> get restaurants => List.unmodifiable(_restaurants);

  /// Gets the loading state
  bool get isLoading => _isLoading;

  /// Gets the current error message, if any
  String? get errorMessage => _errorMessage;

  /// Fetches restaurants near the specified location
  Future<void> fetchNearbyRestaurants({
    required double latitude,
    required double longitude,
    required double radius,
  }) async {
    try {
      _setLoading(true);
      _restaurants = await _restaurantService.getNearbyRestaurants(
        latitude: latitude,
        longitude: longitude,
        radius: radius,
      );
      _setLoading(false);
    } catch (e) {
      _handleError('Failed to fetch nearby restaurants: ${e.toString()}');
    }
  }

  /// Fetches a specific restaurant by its ID
  Future<Restaurant?> getRestaurantById(String id) async {
    try {
      final restaurant = await _restaurantService.getRestaurantById(id);

      // Debug logging
      print('DEBUG: Restaurant fetched successfully:');
      print('- ID: ${restaurant.id}');
      print('- Name: ${restaurant.name}');
      print('- Description: ${restaurant.description}');
      print('- Cover Image: ${restaurant.coverImage}');
      print(
          '- Operating Hours: ${restaurant.operatingHours?.from} - ${restaurant.operatingHours?.to}');
      print('- Menu Items Count: ${restaurant.menu.length}');

      // Log menu items if present
      if (restaurant.menu.isNotEmpty) {
        print('\nMenu Items:');
        restaurant.menu.forEach((item) {
          print('  * ${item.name} - \$${item.price}');
        });
      }

      return restaurant;
    } catch (e) {
      _handleError('Failed to fetch restaurant details: ${e.toString()}');
      return null;
    }
  }

  /// Searches for restaurants based on query
  Future<void> searchRestaurants(String query) async {
    try {
      _setLoading(true);
      _restaurants = await _restaurantService.searchRestaurants(query);
      _setLoading(false);
    } catch (e) {
      _handleError('Failed to search restaurants: ${e.toString()}');
    }
  }

  /// Helper method to update loading state
  void _setLoading(bool value) {
    _isLoading = value;
    _errorMessage = null;
    notifyListeners();
  }

  /// Helper method to handle errors
  void _handleError(String message) {
    _isLoading = false;
    _errorMessage = message;
    notifyListeners();
  }
}


/* File: ./client_customer\lib\screens\location_picker_screen.dart */
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:geocoding/geocoding.dart';
import 'package:geolocator/geolocator.dart';
import 'package:url_launcher/url_launcher.dart';
import '../theme/app_theme.dart';

class LocationPickerScreen extends StatefulWidget {
  final LatLng? initialLocation;

  const LocationPickerScreen({super.key, this.initialLocation});

  @override
  _LocationPickerScreenState createState() => _LocationPickerScreenState();
}

class _LocationPickerScreenState extends State<LocationPickerScreen> {
  late LatLng _selectedLocation;
  final MapController _mapController = MapController();
  bool _isGettingLocation = false;

  @override
  void initState() {
    super.initState();
    _selectedLocation = widget.initialLocation ??
        const LatLng(6.9271, 79.8612); // Default to Colombo, Sri Lanka
  }

  Future<void> _getCurrentLocation() async {
    setState(() {
      _isGettingLocation = true;
    });

    try {
      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          throw Exception('Location permissions are denied');
        }
      }

      if (permission == LocationPermission.deniedForever) {
        throw Exception('Location permissions are permanently denied');
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition();
      setState(() {
        _selectedLocation = LatLng(position.latitude, position.longitude);
      });

      // Move map to current location
      _mapController.move(_selectedLocation, 15.0);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error getting location: ${e.toString()}')),
      );
    } finally {
      setState(() {
        _isGettingLocation = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select Location'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context, _selectedLocation);
            },
            child: const Text('CONFIRM', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
      body: Stack(
        children: [
          FlutterMap(
            mapController: _mapController,
            options: MapOptions(
              center: _selectedLocation,
              zoom: 15.0,
              maxZoom: 18.0,
              minZoom: 5.0,
              onTap: (tapPosition, point) {
                setState(() {
                  _selectedLocation = point;
                });
              },
            ),
            nonRotatedChildren: [
              // Fix: Use the correct attribution widget
              RichAttributionWidget(
                attributions: [
                  TextSourceAttribution(
                    'OpenStreetMap contributors',
                    onTap: () => launchUrl(
                        Uri.parse('https://openstreetmap.org/copyright')),
                  ),
                ],
              ),
            ],
            children: [
              TileLayer(
                urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                userAgentPackageName: 'com.example.app',
              ),
              MarkerLayer(
                markers: [
                  Marker(
                    width: 80.0,
                    height: 80.0,
                    point: _selectedLocation,
                    builder: (ctx) => const Icon(
                      Icons.location_pin,
                      color: Colors.red,
                      size: 40,
                    ),
                  ),
                ],
              ),
            ],
          ),
          Positioned(
            bottom: 16,
            right: 16,
            child: FloatingActionButton(
              onPressed: _getCurrentLocation,
              tooltip: 'Get Current Location',
              child: _isGettingLocation
                  ? const CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    )
                  : const Icon(Icons.my_location),
            ),
          ),
          Positioned(
            bottom: 16,
            left: 16,
            right: 90,
            child: ElevatedButton(
              onPressed: () {
                Navigator.pop(context, _selectedLocation);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primary,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              child: const Text('Use This Location'),
            ),
          ),
        ],
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\auth\login_screen.dart */
// lib/screens/auth/login_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'dart:convert';
import '../../services/api_service.dart';
import '../../services/auth_service.dart';
import '../../providers/auth_provider.dart';
import '../../models/user.dart';
import '../home/home_screen.dart';
import 'register_screen.dart';
import '../../theme/app_theme.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _phoneController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;
  bool _obscurePassword = true;

  // Track current login mode (email or phone)
  bool _isEmailMode = true;

  Future<void> _login() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    final apiService = ApiService();
    final authService = AuthService();
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final result = await apiService.login(
      email: _isEmailMode ? _emailController.text.trim() : null,
      phone: !_isEmailMode ? _phoneController.text.trim() : null,
      password: _passwordController.text.trim(),
    );

    if (!mounted) return;

    if (result['success'] == true) {
      final user = User.fromJson(result['user']);

      // Restrict access to only "customer" role
      if (user.role != 'customer') {
        setState(() {
          _errorMessage = 'Only customers are allowed to log in.';
          _isLoading = false;
        });
        return;
      }

      await authService.saveAuthData(
        result['token'],
        jsonEncode(user.toJson()),
      );
      authProvider.setUser(user);
      authProvider.setToken(result['token']);

      if (!mounted) return;

      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const HomeScreen()),
      );
    } else {
      setState(() {
        _errorMessage = result['message'];
        _isLoading = false;
      });
    }
  }

  void _toggleLoginMode() {
    setState(() {
      _isEmailMode = !_isEmailMode;
      // Clear the error message when switching modes
      _errorMessage = null;
    });
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your email';
    }
    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
      return 'Please enter a valid email';
    }
    return null;
  }

  String? _validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your phone number';
    }
    if (!RegExp(r'^\+?[\d\s-]{10,}$').hasMatch(value)) {
      return 'Enter a valid phone number (e.g. +94771234567)';
    }
    return null;
  }

  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your password';
    }
    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: EdgeInsets.symmetric(horizontal: 24.w),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: 32.h),
                Text(
                  "Login to your account",
                  style: theme.textTheme.displayLarge?.copyWith(
                    fontWeight: FontWeight.w700,
                    fontSize: 32.sp,
                    color: Colors.black,
                  ),
                ),
                SizedBox(height: 12.h),
                Text(
                  "Enter your details to continue",
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
                SizedBox(height: 32.h),

                // Conditionally show either email or phone field
                if (_isEmailMode) ...[
                  TextFormField(
                    controller: _emailController,
                    decoration: InputDecoration(
                      labelText: "Email Address",
                      hintText: "Albertstevano@gmail.com",
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: _validateEmail,
                  ),
                ] else ...[
                  TextFormField(
                    controller: _phoneController,
                    decoration: InputDecoration(
                      labelText: "Phone Number",
                      hintText: "+94771234567",
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    keyboardType: TextInputType.phone,
                    validator: _validatePhone,
                  ),
                ],

                // Toggle link to switch between email and phone
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: _toggleLoginMode,
                    child: Text(
                      _isEmailMode
                          ? "Use phone number instead"
                          : "Use email instead",
                      style: TextStyle(
                        color: AppColors.primary,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),

                SizedBox(height: 20.h),
                TextFormField(
                  controller: _passwordController,
                  decoration: InputDecoration(
                    labelText: "Password",
                    hintText: "**********",
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_off
                            : Icons.visibility,
                        color: Colors.grey,
                      ),
                      onPressed: () {
                        setState(() {
                          _obscurePassword = !_obscurePassword;
                        });
                      },
                    ),
                  ),
                  obscureText: _obscurePassword,
                  validator: _validatePassword,
                ),

                if (_errorMessage != null)
                  Padding(
                    padding: EdgeInsets.only(top: 16.h),
                    child: Text(
                      _errorMessage!,
                      style: TextStyle(
                        color: theme.colorScheme.error,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),

                SizedBox(height: 24.h),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : _login,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      padding: EdgeInsets.symmetric(vertical: 16.h),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Colors.white,
                              ),
                            ),
                          )
                        : const Text(
                            "Login",
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                  ),
                ),

                SizedBox(height: 32.h),
                Center(
                  child: GestureDetector(
                    onTap: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const RegisterScreen(),
                        ),
                      );
                    },
                    child: RichText(
                      text: TextSpan(
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: Colors.black,
                        ),
                        children: [
                          const TextSpan(text: "Don't have an account? "),
                          TextSpan(
                            text: "Sign Up",
                            style: TextStyle(
                              color: AppColors.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                SizedBox(height: 24.h),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\auth\profile_screen.dart */
import 'package:client_customer/providers/auth_provider.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../theme/app_theme.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  Map<String, dynamic>? user;
  bool loading = true;

  @override
  void initState() {
    super.initState();
    fetchUser();
  }

  Future<void> fetchUser() async {
    final token = Provider.of<AuthProvider>(context, listen: false).token;
    print(token);
    if (token == null) {
      setState(() {
        loading = false;
      });
      return;
    }
    final response = await http.get(
      Uri.parse('http://10.0.2.2:3000/api/users/me'),
      headers: {'Authorization': 'Bearer $token'},
    );
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      setState(() {
        user = data['data']['user'];
        loading = false;
      });
    } else {
      setState(() {
        loading = false;
      });
    }
  }

  Future<void> logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('token');
    if (!mounted) return;
    Navigator.of(context).pushNamedAndRemoveUntil('/login', (route) => false);
  }

  @override
  Widget build(BuildContext context) {
    if (loading) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    if (user == null) {
      return const Scaffold(
        body: Center(
          child: Text('Not logged in.', style: TextStyle(fontSize: 16)),
        ),
      );
    }

    final theme = AppTheme.lightTheme;
    final primaryColor = AppColors.primary;
    final lightPrimaryColor = AppColors.lightprime;

    return Scaffold(
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              lightPrimaryColor,
              Colors.white,
            ],
          ),
        ),
        child: SafeArea(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                children: [
                  const SizedBox(height: 20),
                  // Profile Avatar
                  Container(
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.1),
                          blurRadius: 20,
                          offset: const Offset(0, 5),
                        ),
                      ],
                    ),
                    child: CircleAvatar(
                      radius: 50,
                      backgroundColor: lightPrimaryColor,
                      child: Text(
                        user!['name'] != null && user!['name'].isNotEmpty
                            ? user!['name'][0].toUpperCase()
                            : '?',
                        style: TextStyle(
                          fontSize: 40,
                          fontWeight: FontWeight.bold,
                          color: primaryColor,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  // User Info Cards
                  Container(
                    padding: const EdgeInsets.all(20),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(20),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.05),
                          blurRadius: 10,
                          offset: const Offset(0, 5),
                        ),
                      ],
                    ),
                    child: Column(
                      children: [
                        _buildInfoRow(
                          icon: Icons.person,
                          title: 'Name',
                          value: user!['name'] ?? 'Not set',
                          primaryColor: primaryColor,
                        ),
                        const Divider(height: 20),
                        _buildInfoRow(
                          icon: Icons.email,
                          title: 'Email',
                          value: user!['email'] ?? 'Not set',
                          primaryColor: primaryColor,
                        ),
                        if (user!['phone'] != null) ...[
                          const Divider(height: 20),
                          _buildInfoRow(
                            icon: Icons.phone,
                            title: 'Phone',
                            value: user!['phone'],
                            primaryColor: primaryColor,
                          ),
                        ],
                        const Divider(height: 20),
                        _buildInfoRow(
                          icon: Icons.badge,
                          title: 'Role',
                          value: user!['role']?.toString().toUpperCase() ??
                              'Not set',
                          primaryColor: primaryColor,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 32),
                  // Logout Button
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: logout,
                      icon: const Icon(Icons.logout, color: Colors.white),
                      label: const Text(
                        'Logout',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.red,
                        padding: const EdgeInsets.symmetric(vertical: 15),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        elevation: 2,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String title,
    required String value,
    required Color primaryColor,
  }) {
    return Row(
      children: [
        Icon(icon, color: primaryColor, size: 24),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                value,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}


/* File: ./client_customer\lib\screens\auth\register_screen.dart */
import 'package:client_customer/screens/auth/login_screen.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:convert';
import '../../services/api_service.dart';
import '../../services/auth_service.dart';
import '../../providers/auth_provider.dart';
import '../home/home_screen.dart';
import '../../models/user.dart';
import '../../theme/app_theme.dart';

class RegisterScreen extends StatefulWidget {
  const RegisterScreen({super.key});

  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _addressController = TextEditingController();
  bool _isAgree = false;
  bool _isLoading = false;
  String? _errorMessage;
  bool _obscurePassword = true;

  Future<void> _register() async {
    if (!_formKey.currentState!.validate() || !_isAgree) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    final apiService = ApiService();
    final authService = AuthService();
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final result = await apiService.register(
      name: _nameController.text.trim(),
      email: _emailController.text.trim(),
      phone: _phoneController.text.trim(),
      password: _passwordController.text.trim(),
      address: _addressController.text.trim(),
    );

    if (!mounted) return;

    if (result['success'] == true) {
      final user = User.fromJson(result['user']);
      await authService.saveAuthData(
        result['token'],
        jsonEncode(user.toJson()),
      );
      authProvider.setUser(user);
      authProvider.setToken(result['token']);

      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const HomeScreen()),
      );
    } else {
      setState(() {
        _errorMessage = result['message'];
        _isLoading = false;
      });
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _addressController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 32),
                Text(
                  "Create your new account",
                  style: theme.textTheme.displayLarge?.copyWith(
                    fontWeight: FontWeight.w700,
                    fontSize: 32,
                    color: Colors.black,
                  ),
                ),
                const SizedBox(height: 12),
                Text(
                  "Create an account to start looking for the food you like",
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
                const SizedBox(height: 32),
                _label("Email Address"),
                const SizedBox(height: 8),
                _roundedField(
                  controller: _emailController,
                  hintText: "Albertstevano@gmail.com",
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your email';
                    }
                    if (!RegExp(
                      r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                    ).hasMatch(value)) {
                      return 'Please enter a valid email';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                _label("User Name"),
                const SizedBox(height: 8),
                _roundedField(
                  controller: _nameController,
                  hintText: "Alber tstevano",
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your name';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                _label("Phone Number"),
                const SizedBox(height: 8),
                _roundedField(
                  controller: _phoneController,
                  hintText: "+94771234567",
                  keyboardType: TextInputType.phone,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your phone number';
                    }
                    if (!RegExp(r'^\+?[\d\s-]{10,}$').hasMatch(value)) {
                      return 'Enter a valid phone number (e.g. +94771234567)';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                _label("Password"),
                const SizedBox(height: 8),
                _roundedField(
                  controller: _passwordController,
                  hintText: "**********",
                  obscureText: _obscurePassword,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword
                          ? Icons.visibility_off
                          : Icons.visibility,
                      color: Colors.grey,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a password';
                    }
                    if (value.length < 6) {
                      return 'Password must be at least 6 characters';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                _label("Address"),
                const SizedBox(height: 8),
                _roundedField(
                  controller: _addressController,
                  hintText: "123 Main Street, City",
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your address';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                Row(
                  children: [
                    Checkbox(
                      value: _isAgree,
                      onChanged: (val) {
                        setState(() {
                          _isAgree = val ?? false;
                        });
                      },
                      activeColor: AppColors.primary,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4),
                      ),
                    ),
                    Expanded(
                      child: RichText(
                        text: TextSpan(
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: Colors.black,
                          ),
                          children: [
                            const TextSpan(text: "I Agree with "),
                            TextSpan(
                              text: "Terms of Service",
                              style: TextStyle(
                                color: AppColors.secondary,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            const TextSpan(text: " and "),
                            TextSpan(
                              text: "Privacy Policy",
                              style: TextStyle(
                                color: AppColors.secondary,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                if (_errorMessage != null)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 12.0),
                    child: Text(
                      _errorMessage!,
                      style: TextStyle(
                        color: theme.colorScheme.error,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                const SizedBox(height: 8),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: (_isLoading || !_isAgree) ? null : _register,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      minimumSize: const Size.fromHeight(56),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(32),
                      ),
                      textStyle: const TextStyle(
                        fontWeight: FontWeight.w600,
                        fontSize: 18,
                      ),
                    ),
                    child:
                        _isLoading
                            ? const CircularProgressIndicator(
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Colors.white,
                              ),
                            )
                            : const Text("Register"),
                  ),
                ),
                const SizedBox(height: 32),
                Center(
                  child: GestureDetector(
                    onTap: () {
                      Navigator.pushReplacement(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const LoginScreen(),
                        ),
                      );
                    },
                    child: RichText(
                      text: TextSpan(
                        style: Theme.of(
                          context,
                        ).textTheme.bodyMedium?.copyWith(color: Colors.black),
                        children: [
                          const TextSpan(text: "Have an account? "),
                          TextSpan(
                            text: "Log in",
                            style: TextStyle(
                              color: AppColors.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _label(String text) => Text(
    text,
    style: Theme.of(context).textTheme.labelLarge?.copyWith(
      color: Colors.black,
      fontWeight: FontWeight.w600,
    ),
  );

  Widget _roundedField({
    required TextEditingController controller,
    String? hintText,
    TextInputType? keyboardType,
    bool obscureText = false,
    Widget? suffixIcon,
    String? Function(String?)? validator,
  }) {
    return TextFormField(
      controller: controller,
      keyboardType: keyboardType,
      obscureText: obscureText,
      validator: validator,
      style: const TextStyle(fontSize: 16),
      decoration: InputDecoration(
        hintText: hintText,
        filled: true,
        fillColor: Colors.white,
        contentPadding: const EdgeInsets.symmetric(
          vertical: 20,
          horizontal: 16,
        ),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(14),
          borderSide: BorderSide(color: Colors.grey.shade300, width: 1.5),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(14),
          borderSide: BorderSide(color: Colors.grey.shade300, width: 1.5),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(14),
          borderSide: BorderSide(color: AppColors.primary, width: 2),
        ),
        suffixIcon: suffixIcon,
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\cart\cart_screen.dart */
// In screens/cart/cart_screen.dart

import 'package:client_customer/models/cart.dart';
import 'package:client_customer/theme/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/cart_provider.dart';
import '../../services/restaurant_service.dart';
import '../../models/restaurant.dart';

class CartScreen extends StatefulWidget {
  const CartScreen({super.key});

  @override
  _CartScreenState createState() => _CartScreenState();
}

class _CartScreenState extends State<CartScreen> {
  final RestaurantService _restaurantService = RestaurantService();
  final Map<String, Restaurant> _restaurants = {};
  bool _loadingRestaurants = false;

  @override
  void initState() {
    super.initState();
    Future.microtask(() =>
        Provider.of<CartProvider>(context, listen: false).fetchCart().then((_) {
          _fetchRestaurantDetails();
        }));
  }

  Future<void> _fetchRestaurantDetails() async {
    final cartProvider = Provider.of<CartProvider>(context, listen: false);
    if (cartProvider.cart == null) return;

    setState(() {
      _loadingRestaurants = true;
    });

    try {
      final restaurantIds = cartProvider.itemsByRestaurant.keys.toList();

      for (final id in restaurantIds) {
        if (!_restaurants.containsKey(id)) {
          final restaurant = await _restaurantService.getRestaurantById(id);
          setState(() {
            _restaurants[id] = restaurant;
          });
        }
      }
    } catch (e) {
      print('Error fetching restaurant details: $e');
    } finally {
      setState(() {
        _loadingRestaurants = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Your Cart'),
        elevation: 0,
        backgroundColor: Colors.white,
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_outline),
            onPressed: () {
              // Implement clear cart functionality
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: const Text('Clear Cart?'),
                  content:
                      const Text('Are you sure you want to clear your cart?'),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                    TextButton(
                      onPressed: () {
                        Provider.of<CartProvider>(context, listen: false)
                            .clearCart();
                        Navigator.pop(context);
                      },
                      style: TextButton.styleFrom(foregroundColor: Colors.red),
                      child: const Text('Clear'),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
      body: Consumer<CartProvider>(
        builder: (context, cartProvider, child) {
          if (cartProvider.isLoading) {
            return _buildLoadingState();
          }

          if (cartProvider.error != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline, size: 64, color: Colors.grey[400]),
                  const SizedBox(height: 16),
                  Text(
                    'Error: ${cartProvider.error}',
                    style: TextStyle(color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () => cartProvider.fetchCart(),
                    child: const Text('Try Again'),
                  ),
                ],
              ),
            );
          }

          if (cartProvider.cart == null || cartProvider.itemCount == 0) {
            return _buildEmptyCart();
          }

          final itemsByRestaurant = cartProvider.itemsByRestaurant;

          return Column(
            children: [
              Expanded(
                child: ListView.builder(
                  itemCount: itemsByRestaurant.length,
                  padding: const EdgeInsets.all(16),
                  itemBuilder: (context, index) {
                    final restaurantId =
                        itemsByRestaurant.keys.elementAt(index);
                    final restaurantItems = itemsByRestaurant[restaurantId]!;
                    final restaurant = _restaurants[restaurantId];
                    final restaurantName = restaurant?.name ?? 'Restaurant';

                    return Card(
                      margin: const EdgeInsets.only(bottom: 24),
                      elevation: 2,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(16),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Restaurant Header
                            Row(
                              children: [
                                Container(
                                  width: 48,
                                  height: 48,
                                  decoration: BoxDecoration(
                                    borderRadius: BorderRadius.circular(8),
                                    color: Colors.grey[200],
                                    image: restaurant?.coverImage != null
                                        ? DecorationImage(
                                            image: NetworkImage(
                                                restaurant!.coverImage),
                                            fit: BoxFit.cover,
                                          )
                                        : null,
                                  ),
                                  child: restaurant?.coverImage == null
                                      ? const Icon(Icons.restaurant,
                                          color: Colors.grey)
                                      : null,
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        restaurantName,
                                        style: const TextStyle(
                                          fontSize: 18,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                      Text(
                                        '${restaurantItems.length} items',
                                        style: TextStyle(
                                          fontSize: 14,
                                          color: Colors.grey[600],
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),

                            const Divider(height: 24),

                            // Items List
                            ...restaurantItems.map((item) => _buildCartItem(
                                  item: item,
                                  cartProvider: cartProvider,
                                )),

                            const Divider(height: 24),

                            // Order Summary
                            Padding(
                              padding: const EdgeInsets.symmetric(vertical: 8),
                              child: Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  const Text(
                                    'Subtotal',
                                    style: TextStyle(fontSize: 16),
                                  ),
                                  Text(
                                    '\$${cartProvider.getTotalAmountForRestaurant(restaurantId).toStringAsFixed(2)}',
                                    style: const TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                            ),

                            const SizedBox(height: 16),

                            // Checkout Button
                            SizedBox(
                              width: double.infinity,
                              child: ElevatedButton(
                                onPressed: () {
                                  Navigator.pushNamed(
                                    context,
                                    '/checkout',
                                    arguments: {
                                      'restaurantId': restaurantId,
                                      'restaurantName': restaurantName,
                                    },
                                  );
                                },
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: AppColors.primary,
                                  foregroundColor: Colors.white,
                                  padding:
                                      const EdgeInsets.symmetric(vertical: 16),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                ),
                                child: const Text(
                                  'Checkout',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildCartItem({
    required CartItem item,
    required CartProvider cartProvider,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Item details
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.name,
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 16,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '\$${item.price.toStringAsFixed(2)}',
                  style: TextStyle(
                    color: Colors.grey[700],
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
          // Quantity controls
          Row(
            children: [
              Container(
                decoration: BoxDecoration(
                  color: Colors.grey[200],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.remove, size: 16),
                      onPressed: item.quantity > 1
                          ? () => cartProvider.updateCartItem(
                              item.id, item.quantity - 1)
                          : null,
                      color:
                          item.quantity > 1 ? AppColors.primary : Colors.grey,
                      padding: const EdgeInsets.all(8),
                      constraints: const BoxConstraints(),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 8, vertical: 4),
                      constraints: const BoxConstraints(minWidth: 24),
                      child: Text(
                        '${item.quantity}',
                        style: const TextStyle(fontWeight: FontWeight.bold),
                        textAlign: TextAlign.center,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.add, size: 16),
                      onPressed: () => cartProvider.updateCartItem(
                          item.id, item.quantity + 1),
                      color: AppColors.primary,
                      padding: const EdgeInsets.all(8),
                      constraints: const BoxConstraints(),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 16),
              Text(
                '\$${(item.price * item.quantity).toStringAsFixed(2)}',
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.delete_outline,
                    size: 20, color: Colors.red),
                onPressed: () => cartProvider.removeFromCart(item.id),
                padding: const EdgeInsets.all(8),
                constraints: const BoxConstraints(),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyCart() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'Your cart is empty',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: Colors.grey[700],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Add items from restaurants to start an order',
            style: TextStyle(color: Colors.grey[600]),
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () => Navigator.pushNamed(context, '/home'),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primary,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 16,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: const Text('Browse Restaurants'),
          ),
        ],
      ),
    );
  }

  Widget _buildLoadingState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(),
          SizedBox(height: 16),
          Text('Loading your cart...'),
        ],
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\cart\checkout_screen.dart */
// In screens/cart/checkout_screen.dart

import 'package:client_customer/providers/auth_provider.dart';
import 'package:client_customer/screens/cart/order_confirmation_screen.dart';
import 'package:client_customer/screens/location_picker_screen.dart';
import 'package:client_customer/services/payhere_service.dart';
import 'package:client_customer/theme/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:geocoding/geocoding.dart';
import 'package:geolocator/geolocator.dart';
import 'package:latlong2/latlong.dart';
import 'package:payhere_mobilesdk_flutter/payhere_mobilesdk_flutter.dart';
import 'package:provider/provider.dart';
import '../../providers/cart_provider.dart';

class CheckoutScreen extends StatefulWidget {
  const CheckoutScreen({Key? key}) : super(key: key);

  @override
  _CheckoutScreenState createState() => _CheckoutScreenState();
}

class _CheckoutScreenState extends State<CheckoutScreen> {
  bool _isGettingLocation = false;
  LatLng? _selectedLocation;
  final TextEditingController _addressController = TextEditingController();
  String _selectedRestaurantId = '';
  String _selectedRestaurantName = '';
  String _selectedPaymentMethod = 'Cash on Delivery';
  bool _isProcessing = false;

  // Updated to only include Cash and Card
  final List<String> _paymentMethods = [
    'Cash on Delivery',
    'Credit Card',
  ];

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args = ModalRoute.of(context)?.settings.arguments;
    if (args != null && args is Map<String, dynamic>) {
      _selectedRestaurantId = args['restaurantId'] ?? '';
      _selectedRestaurantName = args['restaurantName'] ?? 'Restaurant';
    }
  }

  @override
  void dispose() {
    _addressController.dispose();
    super.dispose();
  }

  Future<void> _getCurrentLocation() async {
    setState(() {
      _isGettingLocation = true;
    });

    try {
      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          throw Exception('Location permissions are denied');
        }
      }

      if (permission == LocationPermission.deniedForever) {
        throw Exception('Location permissions are permanently denied');
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition();
      _selectedLocation = LatLng(position.latitude, position.longitude);

      // Get address from coordinates
      List<Placemark> placemarks =
          await placemarkFromCoordinates(position.latitude, position.longitude);

      if (placemarks.isNotEmpty) {
        Placemark place = placemarks[0];
        _addressController.text =
            '${place.street}, ${place.subLocality}, ${place.locality}, ${place.postalCode}';
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error getting location: ${e.toString()}')),
      );
    } finally {
      setState(() {
        _isGettingLocation = false;
      });
    }
  }

  Future<void> _openLocationPicker() async {
    final LatLng? result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LocationPickerScreen(
          initialLocation: _selectedLocation,
        ),
      ),
    );

    if (result != null) {
      _selectedLocation = result;
      // Get address from coordinates
      List<Placemark> placemarks =
          await placemarkFromCoordinates(result.latitude, result.longitude);

      if (placemarks.isNotEmpty) {
        Placemark place = placemarks[0];
        _addressController.text =
            '${place.street}, ${place.subLocality}, ${place.locality}, ${place.postalCode}';
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Checkout'),
        centerTitle: true,
        elevation: 0,
        backgroundColor: Colors.white,
      ),
      body: Consumer<CartProvider>(
        builder: (context, cartProvider, child) {
          if (_selectedRestaurantId.isEmpty) {
            return const Center(child: Text('No restaurant selected'));
          }

          if (cartProvider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          final restaurantItems =
              cartProvider.itemsByRestaurant[_selectedRestaurantId] ?? [];

          if (restaurantItems.isEmpty) {
            return const Center(child: Text('No items to checkout'));
          }

          final totalAmount =
              cartProvider.getTotalAmountForRestaurant(_selectedRestaurantId);
          const deliveryFee = 2.99;
          final taxAmount = totalAmount * 0.1; // 10% tax
          final finalTotal = totalAmount + deliveryFee + taxAmount;

          return Stack(
            children: [
              SingleChildScrollView(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Restaurant Info Card
                    Card(
                      elevation: 2,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.restaurant,
                              color: AppColors.primary,
                              size: 32,
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    _selectedRestaurantName,
                                    style: const TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  Text(
                                    '${restaurantItems.length} items | Estimated delivery: 30-45 min',
                                    style: TextStyle(
                                      fontSize: 14,
                                      color: Colors.grey[600],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                    const SizedBox(height: 20),

                    // Delivery Address
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Delivery Address',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 12),
                        TextField(
                          controller: _addressController,
                          decoration: InputDecoration(
                            hintText: 'Enter your delivery address',
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(12),
                              borderSide: BorderSide(color: Colors.grey[300]!),
                            ),
                            prefixIcon: const Icon(Icons.location_on),
                          ),
                          maxLines: 2,
                        ),
                        const SizedBox(height: 16),
                        Row(
                          children: [
                            Expanded(
                              child: ElevatedButton.icon(
                                onPressed: _isGettingLocation
                                    ? null
                                    : _getCurrentLocation,
                                icon: const Icon(Icons.my_location),
                                label: _isGettingLocation
                                    ? const SizedBox(
                                        width: 20,
                                        height: 20,
                                        child: CircularProgressIndicator(
                                            strokeWidth: 2))
                                    : const Text('Use Current Location'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.grey[200],
                                  foregroundColor: Colors.black87,
                                ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: ElevatedButton.icon(
                                onPressed: () => _openLocationPicker(),
                                icon: const Icon(Icons.map),
                                label: const Text('Select on Map'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.grey[200],
                                  foregroundColor: Colors.black87,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),

                    const SizedBox(height: 20),

                    // Payment Method
                    const Text(
                      'Payment Method',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Card(
                      elevation: 1,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8.0),
                        child: Column(
                          children: _paymentMethods.map((method) {
                            return RadioListTile<String>(
                              title: Text(method),
                              value: method,
                              groupValue: _selectedPaymentMethod,
                              onChanged: (value) {
                                setState(() {
                                  _selectedPaymentMethod = value!;
                                });
                              },
                              activeColor: AppColors.primary,
                              contentPadding:
                                  const EdgeInsets.symmetric(horizontal: 16),
                            );
                          }).toList(),
                        ),
                      ),
                    ),

                    const SizedBox(height: 20),

                    // Order Summary
                    const Text(
                      'Order Summary',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Card(
                      elevation: 2,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Column(
                          children: [
                            // Item List (collapsible)
                            ExpansionTile(
                              title: Text(
                                'Items (${restaurantItems.length})',
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              initiallyExpanded: false,
                              children: restaurantItems.map((item) {
                                return ListTile(
                                  dense: true,
                                  title: Text(item.name),
                                  trailing: Text(
                                    '${item.quantity} × \$${item.price.toStringAsFixed(2)}',
                                  ),
                                  subtitle: Text(
                                    '\$${(item.price * item.quantity).toStringAsFixed(2)}',
                                    style: const TextStyle(
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                );
                              }).toList(),
                            ),

                            const Divider(),

                            // Price breakdown
                            _buildPriceSummaryRow('Subtotal',
                                '\$${totalAmount.toStringAsFixed(2)}'),
                            _buildPriceSummaryRow('Delivery Fee',
                                '\$${deliveryFee.toStringAsFixed(2)}'),
                            _buildPriceSummaryRow('Tax (10%)',
                                '\$${taxAmount.toStringAsFixed(2)}'),
                            const Divider(),
                            _buildPriceSummaryRow(
                              'Total',
                              '\$${finalTotal.toStringAsFixed(2)}',
                              isTotal: true,
                            ),
                          ],
                        ),
                      ),
                    ),

                    const SizedBox(
                      height: 100,
                    ), // Space for the fixed button
                  ],
                ),
              ),

              // Fixed place order button at bottom
              Positioned(
                bottom: 0,
                left: 0,
                right: 0,
                child: Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 10,
                        offset: const Offset(0, -2),
                      ),
                    ],
                  ),
                  child: SafeArea(
                    child: ElevatedButton(
                      onPressed: _isProcessing
                          ? null
                          : () async {
                              if (_addressController.text.isEmpty ||
                                  _selectedLocation == null) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                      content: Text(
                                          'Please enter your delivery address')),
                                );
                                return;
                              }

                              setState(() {
                                _isProcessing = true;
                              });
                              print(
                                  "[CheckoutScreen] Place Order button pressed."); // Log: Button press

                              try {
                                final cartProvider = Provider.of<CartProvider>(
                                    context,
                                    listen: false);

                                // For Cash on Delivery
                                if (_selectedPaymentMethod ==
                                    'Cash on Delivery') {
                                  print(
                                      "[CheckoutScreen] Processing Cash on Delivery..."); // Log: COD start
                                  final result =
                                      await cartProvider.checkoutRestaurant(
                                    _selectedRestaurantId,
                                    _addressController.text,
                                    'cash',
                                    _selectedLocation != null
                                        ? [
                                            _selectedLocation!.longitude,
                                            _selectedLocation!.latitude
                                          ]
                                        : null,
                                  );

                                  if (!result['success']) {
                                    throw Exception(result['message'] ??
                                        'Failed to place order');
                                  }

                                  if (!mounted) return;

                                  // Navigate to confirmation screen with order data
                                  await Navigator.pushNamedAndRemoveUntil(
                                    context,
                                    OrderConfirmationScreen.routeName,
                                    (route) => false,
                                    arguments: result['order'],
                                  );
                                  print(
                                      "[CheckoutScreen] Cash on Delivery processed."); // Log: COD end
                                  return;
                                }

                                // For Credit Card - PayHere integration
                                if (_selectedPaymentMethod == 'Credit Card') {
                                  print(
                                      "[CheckoutScreen] Processing Credit Card Payment...");

                                  // First create order in your backend
                                  final orderResponse =
                                      await cartProvider.checkoutRestaurant(
                                    _selectedRestaurantId,
                                    _addressController.text,
                                    'card',
                                    _selectedLocation != null
                                        ? [
                                            _selectedLocation!.longitude,
                                            _selectedLocation!.latitude
                                          ]
                                        : null,
                                  );

                                  if (!orderResponse['success']) {
                                    throw Exception(orderResponse['message'] ??
                                        'Failed to create order');
                                  }

                                  final orderData = orderResponse['order'] ??
                                      orderResponse['data']?['order'];
                                  if (orderData == null) {
                                    throw Exception(
                                        'Invalid order data received from server');
                                  }

                                  final orderId = orderData['_id'];
                                  if (orderId == null || orderId.isEmpty) {
                                    throw Exception(
                                        'Could not extract order ID from response');
                                  }

                                  final totalAmount = double.parse(
                                      orderData['totalAmount'].toString());

                                  // Get user info for payment
                                  final user = Provider.of<AuthProvider>(
                                          context,
                                          listen: false)
                                      .user;
                                  final customerName = user?.name ?? 'Customer';
                                  final customerEmail = user?.email;
                                  final customerPhone = user?.phone;

                                  // Initialize PayHere payment
                                  final payhereService = PayhereService();
                                  final paymentResult =
                                      await payhereService.initiatePayment(
                                    orderId: orderId,
                                    amount: totalAmount,
                                    items:
                                        "Order from $_selectedRestaurantName",
                                    customerName: customerName,
                                    email: customerEmail,
                                    phone: customerPhone,
                                    address: _addressController.text,
                                  );

                                  if (!paymentResult['success']) {
                                    throw Exception(paymentResult['message']);
                                  }

                                  // Launch PayHere payment gateway
                                  PayHere.startPayment(
                                    paymentResult['paymentObject'],
                                    (paymentId) async {
                                      print(
                                          "[CheckoutScreen] Payment Success. PaymentId: $paymentId");
                                      print(
                                          "[CheckoutScreen] Original order data: $orderData");

                                      final updateResult = await payhereService
                                          .savePaymentDetails(
                                        orderId: orderId,
                                        paymentId: paymentId,
                                        amount: totalAmount,
                                        status: 'completed',
                                      );

                                      if (!mounted) return;

                                      if (updateResult['success']) {
                                        final confirmationData =
                                            Map<String, dynamic>.from(
                                                orderData);
                                        confirmationData['totalAmount'] =
                                            totalAmount;
                                        confirmationData['paymentType'] =
                                            'Credit Card';
                                        confirmationData['paymentStatus'] =
                                            'completed';
                                        confirmationData['paymentId'] =
                                            paymentId;

                                        print(
                                            "[CheckoutScreen] Confirmation data being sent: $confirmationData");

                                        await Navigator.pushNamedAndRemoveUntil(
                                          context,
                                          OrderConfirmationScreen.routeName,
                                          (route) => false,
                                          arguments: confirmationData,
                                        );
                                      } else {
                                        ScaffoldMessenger.of(context)
                                            .showSnackBar(
                                          SnackBar(
                                              content: Text(updateResult[
                                                      'message'] ??
                                                  'Failed to update payment status')),
                                        );
                                        setState(() {
                                          _isProcessing = false;
                                        });
                                      }
                                    },
                                    (error) {
                                      // Payment failed callback
                                      print("Payment Error: $error");
                                      if (!mounted) return;
                                      ScaffoldMessenger.of(context)
                                          .showSnackBar(
                                        SnackBar(
                                            content:
                                                Text('Payment failed: $error')),
                                      );
                                      setState(() {
                                        _isProcessing = false;
                                      });
                                    },
                                    () {
                                      // Payment dismissed callback
                                      print("Payment Dismissed");
                                      if (!mounted) return;
                                      ScaffoldMessenger.of(context)
                                          .showSnackBar(
                                        const SnackBar(
                                            content: Text(
                                                'Payment cancelled by user')),
                                      );
                                      setState(() {
                                        _isProcessing = false;
                                      });
                                    },
                                  );
                                }
                              } catch (e) {
                                print(
                                    "[CheckoutScreen] Error in checkout process: $e"); // Log: Error
                                if (!mounted) return;
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                      content: Text('Error: ${e.toString()}')),
                                );
                                setState(() {
                                  _isProcessing = false;
                                });
                              }
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppColors.primary,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      child: _isProcessing
                          ? const CircularProgressIndicator(
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(Colors.white))
                          : const Text('Place Order',
                              style: TextStyle(
                                  fontSize: 16, fontWeight: FontWeight.bold)),
                    ),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildPriceSummaryRow(String label, String value,
      {bool isTotal = false}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: TextStyle(
              fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
              fontSize: isTotal ? 16 : 14,
            ),
          ),
          Text(
            value,
            style: TextStyle(
              fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
              fontSize: isTotal ? 16 : 14,
              color: isTotal ? AppColors.primary : null,
            ),
          ),
        ],
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\cart\order_confirmation_screen.dart */
import 'package:client_customer/theme/app_theme.dart';
import 'package:flutter/material.dart';

class OrderConfirmationScreen extends StatelessWidget {
  final Map<String, dynamic> orderData;

  const OrderConfirmationScreen({super.key, required this.orderData});

  static const String routeName = '/order-confirmation';

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        // Override back button to navigate to home
        Navigator.of(context)
            .pushNamedAndRemoveUntil('/home', (route) => false);
        return false;
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Order Confirmation'),
          automaticallyImplyLeading: false,
        ),
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 24),
              const Icon(
                Icons.check_circle,
                size: 80,
                color: Colors.green,
              ),
              const SizedBox(height: 24),
              Text(
                'Order Placed Successfully!',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              Text(
                'Thank you for your order. Your food will be delivered soon.',
                style: Theme.of(context).textTheme.bodyMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              // Order details
              Card(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Order Details',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      const Divider(),
                      _buildOrderDetail('Order ID', orderData['_id'] ?? 'N/A'),
                      _buildOrderDetail('Total Amount',
                          '\$${(orderData['totalAmount'] ?? 0).toStringAsFixed(2)}'),
                      _buildOrderDetail(
                          'Payment Method', orderData['paymentType'] ?? 'N/A'),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Go back to home button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    Navigator.pushNamedAndRemoveUntil(
                        context, '/home', (route) => false);
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  child: const Text(
                    'Go back to Home',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOrderDetail(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(
              fontWeight: FontWeight.w500,
              color: Colors.grey,
            ),
          ),
          Text(
            value,
            style: const TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\home\home_screen.dart */
// lib/screens/home/home_screen.dart
import 'package:client_customer/screens/order/order_tracking_screen.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:geolocator/geolocator.dart';
import 'package:latlong2/latlong.dart';
import '../../models/restaurant.dart';
import '../../providers/restaurant_provider.dart';
import '../../theme/app_theme.dart';
import '../cart/cart_screen.dart';
import '../auth/profile_screen.dart';
import '../location_picker_screen.dart';

mixin ImageBuilderMixin {
  // Updated base URL to include the restaurant service
  final String _baseImageUrl = 'http://10.0.2.2:3001/';

  Widget _buildImage(String? imagePath,
      {double? width, double? height, BoxFit fit = BoxFit.cover}) {
    if (imagePath == null || imagePath.isEmpty) {
      return _buildPlaceholder(width: width, height: height);
    }

    // Handle absolute URLs (like Unsplash)
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
      return _networkImage(imagePath, width: width, height: height, fit: fit);
    }

    // Handle local backend images
    return _serverImage(imagePath, width: width, height: height, fit: fit);
  }

  Widget _serverImage(String path,
      {double? width, double? height, BoxFit? fit}) {
    // Clean up the path to ensure proper URL construction
    String cleanPath = path.startsWith('/') ? path.substring(1) : path;
    final fullUrl = _baseImageUrl + cleanPath;

    print('Loading image from: $fullUrl'); // Debug log
    return _networkImage(fullUrl, width: width, height: height, fit: fit);
  }

  Widget _networkImage(String url,
      {double? width, double? height, BoxFit? fit}) {
    return Image.network(
      url,
      width: width,
      height: height,
      fit: fit,
      loadingBuilder: (context, child, progress) {
        if (progress == null) return child;
        return _buildLoadingPlaceholder(width: width, height: height);
      },
      errorBuilder: (context, error, stackTrace) {
        print('Image load error: $error');
        return _buildPlaceholder(width: width, height: height);
      },
    );
  }

  Widget _buildPlaceholder({double? width, double? height}) {
    return Container(
      width: width,
      height: height,
      color: Colors.grey[200],
      child: const Icon(Icons.restaurant, size: 40, color: Colors.grey),
    );
  }

  Widget _buildLoadingPlaceholder({double? width, double? height}) {
    return Container(
      width: width,
      height: height,
      color: Colors.grey[200],
      child: Center(
        child: CircularProgressIndicator(
          strokeWidth: 2,
          valueColor: AlwaysStoppedAnimation<Color>(AppColors.primary),
        ),
      ),
    );
  }
}

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with ImageBuilderMixin {
  int _selectedIndex = 0;
  LatLng? _selectedLocation;
  bool _isGettingLocation = false;

  @override
  void initState() {
    super.initState();
    _getCurrentLocation();
  }

  Future<void> _getCurrentLocation() async {
    setState(() {
      _isGettingLocation = true;
    });

    try {
      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          throw Exception('Location permissions are denied');
        }
      }

      if (permission == LocationPermission.deniedForever) {
        throw Exception('Location permissions are permanently denied');
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition();
      setState(() {
        _selectedLocation = LatLng(position.latitude, position.longitude);
      });

      // Load restaurants based on current location
      await Provider.of<RestaurantProvider>(
        context,
        listen: false,
      ).fetchNearbyRestaurants(
        latitude: position.latitude,
        longitude: position.longitude,
        radius: 5,
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error getting location: ${e.toString()}')),
      );
      // Load with default location if there's an error
      await _loadRestaurantsWithDefaultLocation();
    } finally {
      setState(() {
        _isGettingLocation = false;
      });
    }
  }

  Future<void> _loadRestaurantsWithDefaultLocation() async {
    await Provider.of<RestaurantProvider>(
      context,
      listen: false,
    ).fetchNearbyRestaurants(latitude: 6.9271, longitude: 79.8612, radius: 5);
  }

  Future<void> _openLocationPicker() async {
    final LatLng? result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LocationPickerScreen(
          initialLocation: _selectedLocation,
        ),
      ),
    );

    if (result != null) {
      setState(() {
        _selectedLocation = result;
      });

      // Load restaurants based on selected location
      await Provider.of<RestaurantProvider>(
        context,
        listen: false,
      ).fetchNearbyRestaurants(
        latitude: result.latitude,
        longitude: result.longitude,
        radius: 5,
      );
    }
  }

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: _getSelectedScreen(),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(
            icon: Icon(Icons.shopping_cart),
            label: 'Cart',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.delivery_dining),
            label: 'Orders',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: Colors.grey, // Set unselected items to white
        backgroundColor: Colors.white, // Optional: set navbar background
        type:
            BottomNavigationBarType.fixed, // Recommended for more than 3 items
        showSelectedLabels: true,
        showUnselectedLabels: true,
        onTap: _onItemTapped,
      ),
    );
  }

  Widget _getSelectedScreen() {
    switch (_selectedIndex) {
      case 0:
        return _buildHomeContent();
      case 1:
        return const CartScreen();
      case 2:
        return const OrderTrackingScreen();
      case 3:
        return const ProfileScreen();
      default:
        return _buildHomeContent();
    }
  }

  Widget _buildHomeContent() {
    return Column(
      children: [
        // Header with gradient background
        Container(
          padding: EdgeInsets.fromLTRB(16.w, 50.h, 16.w, 20.h),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [AppColors.primary, AppColors.primary.withOpacity(0.8)],
            ),
            borderRadius: BorderRadius.only(
              bottomLeft: Radius.circular(24.r),
              bottomRight: Radius.circular(24.r),
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      "Flavor Town, Gastronomia",
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            color: Colors.white,
                            fontWeight: FontWeight.w600,
                          ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.search, color: Colors.white),
                    onPressed: () {},
                  ),
                ],
              ),
              SizedBox(height: 10.h),
              Text(
                "Discover the best restaurants near you!",
                style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w400,
                    ),
              ),
              SizedBox(height: 16.h),
              // Add location buttons
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed:
                          _isGettingLocation ? null : _getCurrentLocation,
                      icon: const Icon(Icons.my_location),
                      label: _isGettingLocation
                          ? SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor:
                                    AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            )
                          : const Text('Current Location'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: AppColors.primary,
                        padding: EdgeInsets.symmetric(vertical: 10.h),
                      ),
                    ),
                  ),
                  SizedBox(width: 8.w),
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: _openLocationPicker,
                      icon: const Icon(Icons.map),
                      label: const Text('Select on Map'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: AppColors.primary,
                        padding: EdgeInsets.symmetric(vertical: 10.h),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        // Body
        Expanded(
          child: Consumer<RestaurantProvider>(
            builder: (context, restaurantProvider, _) {
              if (restaurantProvider.isLoading) {
                return const Center(child: CircularProgressIndicator());
              }

              if (restaurantProvider.errorMessage != null) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text('Error: ${restaurantProvider.errorMessage}'),
                      SizedBox(height: 16.h),
                      ElevatedButton(
                        onPressed: _getCurrentLocation,
                        child: const Text('Retry'),
                      ),
                    ],
                  ),
                );
              }

              final restaurants = [
                ...restaurantProvider.restaurants
              ]; // Create a modifiable copy
              if (restaurants.isEmpty) {
                return const Center(child: Text('No restaurants found'));
              }

              // Now sorting the modifiable copy is allowed
              restaurants.sort(
                (a, b) => (a.distance ?? 0).compareTo(b.distance ?? 0),
              );

              return RefreshIndicator(
                onRefresh: _getCurrentLocation,
                child: ListView.builder(
                  padding: EdgeInsets.symmetric(
                    horizontal: 16.w,
                    vertical: 16.h,
                  ),
                  itemCount: restaurants.length,
                  itemBuilder: (context, index) {
                    final restaurant = restaurants[index];
                    return _RestaurantCard(
                      restaurant: restaurant,
                      onTap: () {
                        Navigator.pushNamed(
                          context,
                          '/restaurant',
                          arguments: restaurant.id,
                        );
                      },
                    );
                  },
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

class _RestaurantCard extends StatelessWidget with ImageBuilderMixin {
  final Restaurant restaurant;
  final VoidCallback onTap;

  _RestaurantCard({required this.restaurant, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: EdgeInsets.only(bottom: 28.h),
        child: Column(
          children: [
            ClipRRect(
              borderRadius: BorderRadius.only(
                topLeft: Radius.circular(28.r),
                topRight: Radius.circular(28.r),
              ),
              child: _buildImage(
                restaurant.coverImage,
                width: double.infinity,
                height: 170.h,
                fit: BoxFit.cover,
              ),
            ),
            // Details tile, full width, curved bottom
            Container(
              width: double.infinity,
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.only(
                  bottomLeft: Radius.circular(28.r),
                  bottomRight: Radius.circular(28.r),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black12,
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              padding: EdgeInsets.fromLTRB(24.w, 16.h, 24.w, 16.h),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    restaurant.name,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          color: AppColors.primary,
                          fontWeight: FontWeight.bold,
                        ),
                  ),
                  SizedBox(height: 6.h),
                  Text(
                    restaurant.description,
                    style: Theme.of(
                      context,
                    ).textTheme.bodyMedium?.copyWith(color: Colors.grey[700]),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  SizedBox(height: 10.h),
                  Row(
                    children: [
                      Icon(
                        Icons.location_on,
                        color: AppColors.primary,
                        size: 18.sp,
                      ),
                      SizedBox(width: 4.w),
                      Text(
                        restaurant.distance != null
                            ? "${restaurant.distance!.toStringAsFixed(2)} km"
                            : "N/A",
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      SizedBox(width: 16.w),
                      Icon(
                        Icons.access_time,
                        color: AppColors.primary,
                        size: 18.sp,
                      ),
                      SizedBox(width: 4.w),
                      Text(
                        restaurant.operatingHours != null
                            ? "${restaurant.operatingHours!.from ?? '??'} - ${restaurant.operatingHours!.to ?? '??'}"
                            : "Hours N/A",
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\onboarding\onboarding1_screen.dart */
import 'package:flutter/material.dart';
import '../../theme/app_theme.dart';
import 'onboarding2_screen.dart';
import '../auth/register_screen.dart';

class Onboarding1Screen extends StatelessWidget {
  const Onboarding1Screen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: Stack(
        fit: StackFit.expand,
        children: [
          Image.asset(
            'assets/onboarding1_bg.png', // Update to your asset path
            fit: BoxFit.cover,
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.fromLTRB(24, 36, 24, 36),
              decoration: BoxDecoration(
                color: AppColors.primary,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(36),
                  topRight: Radius.circular(36),
                ),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    "We serve incomparable delicacies",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.displayLarge?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 26,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    "All the best restaurants with their top menu waiting for you, they can’t wait for your order!!",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: Colors.white.withOpacity(0.9),
                      fontWeight: FontWeight.w400,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      _dot(true),
                      const SizedBox(width: 8),
                      _dot(false),
                      const SizedBox(width: 8),
                      _dot(false),
                    ],
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      TextButton(
                        onPressed: () {
                          Navigator.pushReplacement(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const RegisterScreen(),
                            ),
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.white,
                        ),
                        child: const Text(
                          "Skip",
                          style: TextStyle(
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                          ),
                        ),
                      ),
                      TextButton.icon(
                        onPressed: () {
                          Navigator.pushReplacement(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const Onboarding2Screen(),
                            ),
                          );
                        },
                        icon: const Text(
                          "Next",
                          style: TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                          ),
                        ),
                        label: const Icon(
                          Icons.arrow_forward,
                          color: Colors.white,
                        ),
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.white,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _dot(bool isActive) {
    return Container(
      width: isActive ? 24 : 12,
      height: 8,
      decoration: BoxDecoration(
        color: isActive ? Colors.white : Colors.white.withOpacity(0.5),
        borderRadius: BorderRadius.circular(8),
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\onboarding\onboarding2_screen.dart */
import 'package:flutter/material.dart';
import '../../theme/app_theme.dart';
import 'onboarding3_screen.dart';
import '../auth/register_screen.dart';

class Onboarding2Screen extends StatelessWidget {
  const Onboarding2Screen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: Stack(
        fit: StackFit.expand,
        children: [
          Image.asset(
            'assets/onboarding2_bg.png', // Update to your asset path
            fit: BoxFit.cover,
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.fromLTRB(24, 36, 24, 36),
              decoration: BoxDecoration(
                color: AppColors.primary,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(36),
                  topRight: Radius.circular(36),
                ),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    "We serve incomparable delicacies",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.displayLarge?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 26,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    "All the best restaurants with their top menu waiting for you, they can’t wait for your order!!",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: Colors.white.withOpacity(0.9),
                      fontWeight: FontWeight.w400,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      _dot(false),
                      const SizedBox(width: 8),
                      _dot(true),
                      const SizedBox(width: 8),
                      _dot(false),
                    ],
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      TextButton(
                        onPressed: () {
                          Navigator.pushReplacement(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const RegisterScreen(),
                            ),
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.white,
                        ),
                        child: const Text(
                          "Skip",
                          style: TextStyle(
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                          ),
                        ),
                      ),
                      TextButton.icon(
                        onPressed: () {
                          Navigator.pushReplacement(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const Onboarding3Screen(),
                            ),
                          );
                        },
                        icon: const Text(
                          "Next",
                          style: TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                          ),
                        ),
                        label: const Icon(
                          Icons.arrow_forward,
                          color: Colors.white,
                        ),
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.white,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _dot(bool isActive) {
    return Container(
      width: isActive ? 24 : 12,
      height: 8,
      decoration: BoxDecoration(
        color: isActive ? Colors.white : Colors.white.withOpacity(0.5),
        borderRadius: BorderRadius.circular(8),
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\onboarding\onboarding3_screen.dart */
import 'package:flutter/material.dart';
import '../../theme/app_theme.dart';
import '../auth/register_screen.dart';

class Onboarding3Screen extends StatelessWidget {
  const Onboarding3Screen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: Stack(
        fit: StackFit.expand,
        children: [
          Image.asset(
            'assets/onboarding3_bg.png', // Update to your asset path
            fit: BoxFit.cover,
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.fromLTRB(24, 36, 24, 36),
              decoration: BoxDecoration(
                color: AppColors.primary,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(36),
                  topRight: Radius.circular(36),
                ),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    "We serve incomparable delicacies",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.displayLarge?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 26,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    "All the best restaurants with their top menu waiting for you, they can’t wait for your order!!",
                    textAlign: TextAlign.center,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: Colors.white.withOpacity(0.9),
                      fontWeight: FontWeight.w400,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      _dot(false),
                      const SizedBox(width: 8),
                      _dot(false),
                      const SizedBox(width: 8),
                      _dot(true),
                    ],
                  ),
                  const SizedBox(height: 32),
                  // Circular next button
                  Center(
                    child: SizedBox(
                      width: 56,
                      height: 56,
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          CircularProgressIndicator(
                            value: 1.0,
                            strokeWidth: 3,
                            backgroundColor: Colors.white.withOpacity(0.3),
                            valueColor: AlwaysStoppedAnimation<Color>(
                              Colors.white,
                            ),
                          ),
                          Material(
                            color: Colors.white,
                            shape: const CircleBorder(),
                            child: InkWell(
                              customBorder: const CircleBorder(),
                              onTap: () {
                                Navigator.pushReplacement(
                                  context,
                                  MaterialPageRoute(
                                    builder: (_) => const RegisterScreen(),
                                  ),
                                );
                              },
                              child: const Padding(
                                padding: EdgeInsets.all(8.0),
                                child: Icon(
                                  Icons.arrow_forward,
                                  color: AppColors.primary,
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  // Optionally, you can add a skip button here if you want
                  // Center(
                  //   child: TextButton(
                  //     onPressed: () {
                  //       Navigator.pushReplacement(
                  //         context,
                  //         MaterialPageRoute(builder: (_) => const RegisterScreen()),
                  //       );
                  //     },
                  //     style: TextButton.styleFrom(
                  //       foregroundColor: Colors.white,
                  //     ),
                  //     child: const Text(
                  //       "Skip",
                  //       style: TextStyle(
                  //         fontWeight: FontWeight.w600,
                  //         fontSize: 16,
                  //       ),
                  //     ),
                  //   ),
                  // ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _dot(bool isActive) {
    return Container(
      width: isActive ? 24 : 12,
      height: 8,
      decoration: BoxDecoration(
        color: isActive ? Colors.white : Colors.white.withOpacity(0.5),
        borderRadius: BorderRadius.circular(8),
      ),
    );
  }
}


/* File: ./client_customer\lib\screens\order\order_tracking_screen.dart */
// screens/order/order_tracking_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../../providers/order_provider.dart';
import '../../models/order.dart';
import '../../theme/app_theme.dart';
import '../order/order_tracking_screen.dart';

class OrderTrackingScreen extends StatefulWidget {
  const OrderTrackingScreen({Key? key}) : super(key: key);

  @override
  _OrderTrackingScreenState createState() => _OrderTrackingScreenState();
}

class _OrderTrackingScreenState extends State<OrderTrackingScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Provider.of<OrderProvider>(context, listen: false).fetchCustomerOrders();
    });
  }

  // Convert tracking status to more readable format
  String getStatusText(String status) {
    switch (status) {
      case 'placed':
        return 'Order Placed';
      case 'confirmed':
        return 'Order Confirmed';
      case 'preparing':
        return 'Preparing';
      case 'ready_for_pickup':
        return 'Ready for Pickup';
      case 'out_for_delivery':
        return 'Out for Delivery';
      case 'delivered':
        return 'Delivered';
      case 'cancelled':
        return 'Cancelled';
      default:
        return status;
    }
  }

  // Return an appropriate icon for the status
  IconData getStatusIcon(String status) {
    switch (status) {
      case 'placed':
        return Icons.receipt_long;
      case 'confirmed':
        return Icons.check_circle;
      case 'preparing':
        return Icons.restaurant;
      case 'ready_for_pickup':
        return Icons.delivery_dining;
      case 'out_for_delivery':
        return Icons.directions_bike;
      case 'delivered':
        return Icons.home;
      case 'cancelled':
        return Icons.cancel;
      default:
        return Icons.help;
    }
  }

  // Get a color based on the status
  Color getStatusColor(String status) {
    switch (status) {
      case 'placed':
        return Colors.blue;
      case 'confirmed':
        return Colors.green;
      case 'preparing':
        return Colors.deepPurple;
      case 'ready_for_pickup':
        return Colors.purple;
      case 'out_for_delivery':
        return Colors.indigo;
      case 'delivered':
        return Colors.teal;
      case 'cancelled':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Orders'),
        centerTitle: true,
        elevation: 0,
        backgroundColor: Colors.white,
      ),
      body: Consumer<OrderProvider>(
        builder: (context, orderProvider, child) {
          if (orderProvider.isLoading) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          if (orderProvider.errorMessage != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Colors.red[300],
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Error: ${orderProvider.errorMessage}',
                    style: const TextStyle(color: Colors.red),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () => orderProvider.fetchCustomerOrders(),
                    child: const Text('Try Again'),
                  ),
                ],
              ),
            );
          }

          if (orderProvider.orders.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.receipt_long,
                    size: 80,
                    color: Colors.grey[400],
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No orders yet',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey[700],
                    ),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    'Your order history will appear here',
                    style: TextStyle(color: Colors.grey),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () => Navigator.pushNamed(context, '/home'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 32,
                        vertical: 16,
                      ),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: const Text('Order Food'),
                  ),
                ],
              ),
            );
          }

          // Display the list of orders
          return RefreshIndicator(
            onRefresh: () => orderProvider.fetchCustomerOrders(),
            child: ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: orderProvider.orders.length,
              itemBuilder: (context, index) {
                final order = orderProvider.orders[index];
                return _buildOrderCard(context, order);
              },
            ),
          );
        },
      ),
    );
  }

  Widget _buildOrderCard(BuildContext context, Order order) {
    final dateFormat = DateFormat('MMM d, y • h:mm a');

    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      color: const Color.fromARGB(255, 255, 240, 215),
      child: InkWell(
        onTap: () {
          // Navigate to order details
        },
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Order ID and Date
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Order #${order.id.substring(order.id.length - 8)}',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    dateFormat.format(order.createdAt),
                    style: TextStyle(
                      color: Colors.grey[600],
                      fontSize: 14,
                    ),
                  ),
                ],
              ),

              const Divider(height: 24),

              // Restaurant name
              Row(
                children: [
                  Icon(Icons.restaurant, color: Colors.grey[600], size: 20),
                  const SizedBox(width: 8),
                  Text(
                    order.restaurantName,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 12),

              // Order summary
              Text(
                '${order.items.length} item${order.items.length > 1 ? 's' : ''} • \$${order.totalAmount.toStringAsFixed(2)}',
                style: TextStyle(
                  color: Colors.grey[700],
                  fontSize: 14,
                ),
              ),

              const SizedBox(height: 16),

              // Status
              Row(
                children: [
                  Icon(
                    getStatusIcon(order.trackingStatus),
                    color: getStatusColor(order.trackingStatus),
                    size: 24,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    getStatusText(order.trackingStatus),
                    style: TextStyle(
                      color: getStatusColor(order.trackingStatus),
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                ],
              ),

              // Progress indicator for active orders
              if (order.trackingStatus != 'delivered' &&
                  order.trackingStatus != 'cancelled')
                _buildOrderProgressIndicator(order.trackingStatus),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOrderProgressIndicator(String status) {
    // Define the order status sequence
    final orderStatuses = [
      'placed',
      'confirmed',
      'preparing',
      'ready_for_pickup',
      'out_for_delivery',
      'delivered'
    ];

    // Find the current status index
    final currentIndex = orderStatuses.indexOf(status);

    // If the status is not in our defined sequence, return empty container
    if (currentIndex == -1) return Container();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 16),
        LinearProgressIndicator(
          value: (currentIndex + 1) / orderStatuses.length,
          backgroundColor: Colors.grey[300],
          valueColor: AlwaysStoppedAnimation<Color>(
            getStatusColor(status),
          ),
          minHeight: 8,
          borderRadius: BorderRadius.circular(4),
        ),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Text(
              'Placed',
              style: TextStyle(fontSize: 12),
            ),
            Text(
              'Delivered',
              style: TextStyle(
                fontSize: 12,
                color: currentIndex == orderStatuses.length - 1
                    ? Colors.teal
                    : Colors.grey,
              ),
            ),
          ],
        ),
      ],
    );
  }
}


/* File: ./client_customer\lib\screens\restaurant\restaurant_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/restaurant.dart';
import '../../providers/cart_provider.dart';
import '../../providers/restaurant_provider.dart';

mixin ImageBuilderMixin {
  final String _baseImageUrl = 'http://10.0.2.2:3001/';

  Widget buildImage(String? imagePath,
      {double? width, double? height, BoxFit fit = BoxFit.cover}) {
    if (imagePath == null || imagePath.isEmpty) {
      return _buildPlaceholder(width: width, height: height);
    }

    // Handle absolute URLs (like Unsplash)
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
      return _networkImage(imagePath, width: width, height: height, fit: fit);
    }

    // Handle local backend images - clean up the path
    String cleanPath = imagePath
        .replaceAll(
            '\\', '/') // Replace Windows backslashes with forward slashes
        .replaceAll('/uploads/', ''); // Remove any 'uploads/' prefix if present

    return _serverImage(cleanPath, width: width, height: height, fit: fit);
  }

  Widget _serverImage(String path,
      {double? width, double? height, BoxFit? fit}) {
    final fullUrl = _baseImageUrl + path;
    print('Loading image from: $fullUrl'); // Debug log
    return _networkImage(fullUrl, width: width, height: height, fit: fit);
  }

  Widget _networkImage(String url,
      {double? width, double? height, BoxFit? fit}) {
    return Image.network(
      url,
      width: width,
      height: height,
      fit: fit,
      loadingBuilder: (context, child, progress) {
        if (progress == null) return child;
        return _buildLoadingPlaceholder(width: width, height: height);
      },
      errorBuilder: (context, error, stackTrace) {
        print('Image load error: $error');
        return _buildPlaceholder(width: width, height: height);
      },
    );
  }

  Widget _buildPlaceholder({double? width, double? height}) {
    return Container(
      width: width,
      height: height,
      color: Colors.grey[200],
      child: const Icon(Icons.restaurant, size: 40, color: Colors.grey),
    );
  }

  Widget _buildLoadingPlaceholder({double? width, double? height}) {
    return Container(
      width: width,
      height: height,
      color: Colors.grey[200],
      child: const Center(
        child: CircularProgressIndicator(
          strokeWidth: 2,
        ),
      ),
    );
  }
}

class RestaurantDetailScreen extends StatefulWidget {
  final String restaurantId;

  const RestaurantDetailScreen({
    super.key,
    required this.restaurantId,
  });

  @override
  State<RestaurantDetailScreen> createState() => _RestaurantDetailScreenState();
}

class _RestaurantDetailScreenState extends State<RestaurantDetailScreen>
    with ImageBuilderMixin {
  bool _isLoading = true;
  Restaurant? _restaurant;
  String? _error;

  @override
  void initState() {
    super.initState();
    _fetchRestaurantDetails();
  }

  Future<void> _fetchRestaurantDetails() async {
    print('DEBUG: Fetching restaurant with ID: ${widget.restaurantId}');

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final restaurantProvider =
          Provider.of<RestaurantProvider>(context, listen: false);

      final restaurant =
          await restaurantProvider.getRestaurantById(widget.restaurantId);

      // Add detailed logging of the fetched data
      print('DEBUG: Restaurant details:');
      print('- Name: ${restaurant?.name}');
      print('- Description: ${restaurant?.description}');
      print('- Cover Image: ${restaurant?.coverImage}');
      print(
          '- Operating Hours: ${restaurant?.operatingHours?.from} - ${restaurant?.operatingHours?.to}');
      print('- Availability: ${restaurant?.availability}');
      print('- Menu Items: ${restaurant?.menu.length} items');

      // Log each menu item
      restaurant?.menu.forEach((item) {
        print('  * Menu Item:');
        print('    - Name: ${item.name}');
        print('    - Price: \$${item.price}');
        print('    - Description: ${item.description}');
        print('    - Image: ${item.image}');
      });

      setState(() {
        _restaurant = restaurant;
        _isLoading = false;
      });
    } catch (e) {
      print('ERROR: Failed to load restaurant: $e');
      setState(() {
        _error = 'Failed to load restaurant details: $e';
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
              ? Center(child: Text(_error!))
              : _restaurant == null
                  ? const Center(child: Text('Restaurant not found'))
                  : _buildRestaurantDetails(),
    );
  }

  Widget _buildRestaurantDetails() {
    if (_restaurant == null) return const SizedBox.shrink();

    return CustomScrollView(
      slivers: [
        _buildAppBar(),
        SliverToBoxAdapter(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _restaurant!.name,
                  style: Theme.of(context).textTheme.headlineMedium,
                ),
                const SizedBox(height: 8),
                Text(
                  _restaurant!.description,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                const SizedBox(height: 16),
                _buildOperatingHours(),
                const Divider(height: 32),
                Text(
                  'Menu',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
        _buildMenuList(),
      ],
    );
  }

  Widget _buildAppBar() {
    return SliverAppBar(
      expandedHeight: 200.0,
      pinned: true,
      flexibleSpace: FlexibleSpaceBar(
        title: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: Colors.black.withOpacity(0.5),
            borderRadius: BorderRadius.circular(20),
          ),
          child: Text(
            _restaurant!.name,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 16.0,
            ),
          ),
        ),
        background: buildImage(
          _restaurant!.coverImage,
          width: double.infinity,
          height: double.infinity,
          fit: BoxFit.cover,
        ),
      ),
    );
  }

  Widget _buildOperatingHours() {
    final hours = _restaurant!.operatingHours;
    if (hours == null) return const SizedBox.shrink();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Row(
          children: [
            const Icon(Icons.access_time),
            const SizedBox(width: 8),
            Text(
              '${hours.from ?? 'N/A'} - ${hours.to ?? 'N/A'}',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const Spacer(),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: _restaurant!.availability ? Colors.green : Colors.red,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                _restaurant!.availability ? 'Open' : 'Closed',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuList() {
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) {
          return _buildMenuItem(_restaurant!.menu[index]);
        },
        childCount: _restaurant!.menu.length,
      ),
    );
  }

  Widget _buildMenuItem(MenuItem menuItem) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Menu item image
            ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: SizedBox(
                width: 80,
                height: 80,
                child: buildImage(
                  menuItem.image,
                  width: 80,
                  height: 80,
                  fit: BoxFit.cover,
                ),
              ),
            ),
            const SizedBox(width: 12),
            // Menu item details
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    menuItem.name,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    menuItem.description,
                    style: TextStyle(
                      color: Colors.grey[600],
                      fontSize: 13,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        '\$${menuItem.price.toStringAsFixed(2)}',
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 14,
                        ),
                      ),
                      ElevatedButton(
                        onPressed: () => _addToCart(menuItem),
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(horizontal: 12),
                          minimumSize: const Size(0, 32),
                        ),
                        child: const Text('Add'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _addToCart(MenuItem menuItem) async {
    try {
      final cartProvider = Provider.of<CartProvider>(context, listen: false);
      final result = await cartProvider.addToCart(
        menuItem,
        _restaurant!.id,
        1,
      );

      if (result['success'] == true) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${menuItem.name} added to cart'),
            action: SnackBarAction(
              label: 'View Cart',
              onPressed: () {
                Navigator.pushNamed(context, '/cart');
              },
            ),
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(result['message'] ?? 'Failed to add to cart')),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to add to cart: $e')),
      );
    }
  }
}


/* File: ./client_customer\lib\services\api_service.dart */
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:client_customer/models/restaurant.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';

class ApiService {
  static const String _userBaseUrl = 'http://10.0.2.2:3000/api/users';
  static const String _restaurantBaseUrl =
      'http://10.0.2.2:3001/api/restaurants';

  Future<Map<String, dynamic>> register({
    required String name,
    required String email,
    required String phone,
    required String password,
    required String address,
  }) async {
    try {
      // Validate input parameters first
      if (email.isEmpty || !email.contains('@')) {
        return {
          'success': false,
          'message': 'Please enter a valid email address',
          'errorCode': 'invalid_email',
        };
      }

      if (password.length < 6) {
        return {
          'success': false,
          'message': 'Password must be at least 6 characters',
          'errorCode': 'weak_password',
        };
      }

      final response = await http
          .post(
            Uri.parse('$_userBaseUrl/customers/register'),
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({
              'name': name,
              'email': email,
              'phone': phone,
              'password': password,
              'address': address,
              'role': 'customer',
            }),
          )
          .timeout(const Duration(seconds: 15));

      // Handle empty or malformed response
      if (response.body.isEmpty) {
        return {
          'success': false,
          'message': 'Empty response from server',
          'errorCode': 'empty_response',
          'statusCode': response.statusCode,
        };
      }

      final responseData = jsonDecode(response.body);

      // Successful registration
      if (response.statusCode == 201) {
        return {
          'success': true,
          'token': responseData['token'],
          'user': responseData['data']['user'],
          'message': 'Registration successful',
        };
      }

      // Handle specific error responses from server
      if (response.statusCode == 400) {
        return {
          'success': false,
          'message': responseData['message'] ?? 'Invalid request data',
          'errorCode': responseData['errorCode'] ?? 'bad_request',
          'validationErrors': responseData['errors'],
          'statusCode': response.statusCode,
        };
      }

      if (response.statusCode == 409) {
        return {
          'success': false,
          'message': 'Email already in use',
          'errorCode': 'email_conflict',
          'statusCode': response.statusCode,
        };
      }

      // Handle other status codes
      return {
        'success': false,
        'message': responseData['message'] ??
            'Registration failed with status ${response.statusCode}',
        'errorCode': responseData['errorCode'] ?? 'server_error',
        'statusCode': response.statusCode,
      };
    } on SocketException catch (e) {
      return {
        'success': false,
        'message': 'No internet connection',
        'errorCode': 'no_connection',
        'details': e.toString(),
      };
    } on TimeoutException catch (e) {
      return {
        'success': false,
        'message': 'Connection timeout',
        'errorCode': 'timeout',
        'details': e.toString(),
      };
    } on http.ClientException catch (e) {
      return {
        'success': false,
        'message': 'Network error occurred',
        'errorCode': 'network_error',
        'details': e.toString(),
      };
    } on FormatException catch (e) {
      return {
        'success': false,
        'message': 'Invalid server response format',
        'errorCode': 'invalid_format',
        'details': e.toString(),
      };
    } catch (e) {
      debugPrint('Registration error: $e');
      return {
        'success': false,
        'message': 'An unexpected error occurred',
        'errorCode': 'unknown_error',
        'details': e.toString(),
      };
    }
  }

  Future<void> registerDeviceToken(String userId) async {
    try {
      final token = await FirebaseMessaging.instance.getToken();
      if (token == null) return;

      await http.post(
        Uri.parse(
            'http://10.0.2.2:5000/api/notifications/register'), // Replace port if needed
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'userId': userId,
          'token': token,
          'role': 'customer', // You can make this dynamic if needed
        }),
      );
    } catch (e) {
      debugPrint('FCM token registration error: $e');
    }
  }

  Future<Map<String, dynamic>> login({
    String? email,
    String? phone,
    required String password,
  }) async {
    try {
      // Validate at least one identifier is provided
      if ((email == null || email.isEmpty) &&
          (phone == null || phone.isEmpty)) {
        return {
          'success': false,
          'message': 'Email or phone required',
          'errorCode': 'missing_credentials',
        };
      }

      final body = <String, dynamic>{'password': password};
      if (email != null && email.isNotEmpty) body['email'] = email;
      if (phone != null && phone.isNotEmpty) body['phone'] = phone;

      final response = await http
          .post(
            Uri.parse('$_userBaseUrl/login'),
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode(body),
          )
          .timeout(const Duration(seconds: 15));

      final responseData = jsonDecode(response.body);

      switch (response.statusCode) {
        case 200:
          final user = responseData['data']['user'];
          final userId = user['id'] ??
              user['_id']; // adjust depending on your backend format

          // Call FCM token registration
          await registerDeviceToken(userId);
          return {
            'success': true,
            'token': responseData['token'],
            'user': responseData['data']['user'],
          };
        case 400:
          return {
            'success': false,
            'message': responseData['message'] ?? 'Invalid request',
            'errorCode': responseData['errorCode'] ?? 'bad_request',
          };
        case 401:
          return {
            'success': false,
            'message': responseData['message'] ?? 'Invalid credentials',
            'errorCode': 'invalid_credentials',
          };
        case 403:
          return {
            'success': false,
            'message': responseData['message'] ?? 'Account not active',
            'errorCode':
                responseData['details']?.toString() ?? 'inactive_account',
          };
        default:
          return {
            'success': false,
            'message': responseData['message'] ?? 'Login failed',
            'statusCode': response.statusCode,
          };
      }
    } on SocketException {
      return {'success': false, 'message': 'No internet connection'};
    } on TimeoutException {
      return {'success': false, 'message': 'Connection timeout'};
    } on http.ClientException catch (e) {
      return {'success': false, 'message': 'Network error: ${e.message}'};
    } catch (e) {
      debugPrint('Login error: $e');
      return {'success': false, 'message': 'An unexpected error occurred'};
    }
  }

  Future<Map<String, dynamic>> getProfile(String token) async {
    try {
      final response = await http.get(
        Uri.parse('$_userBaseUrl/me'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      final responseData = jsonDecode(response.body);

      if (response.statusCode == 200) {
        return {'success': true, 'user': responseData['data']['user']};
      } else {
        return {
          'success': false,
          'message': responseData['message'] ?? 'Failed to fetch profile',
        };
      }
    } catch (e) {
      debugPrint('Profile error: $e');
      return {
        'success': false,
        'message': 'An error occurred while fetching profile',
      };
    }
  }

  Future<List<Restaurant>> getNearbyRestaurants(
    double lat,
    double lon,
    int radius,
  ) async {
    try {
      final response = await http.get(
        Uri.parse('$_restaurantBaseUrl/nearby').replace(
          queryParameters: {
            'latitude': lat.toString(),
            'longitude': lon.toString(),
            'radius': radius.toString(),
          },
        ),
      );

      if (response.statusCode == 200) {
        List<dynamic> data = jsonDecode(response.body);
        return data.map((json) => Restaurant.fromJson(json)).toList();
      }
      throw Exception('Failed to load restaurants');
    } catch (e) {
      throw Exception('Restaurant API error: $e');
    }
  }

  Future<Restaurant> getRestaurantDetails(String restaurantId) async {
    try {
      final response = await http.get(
        Uri.parse('$_restaurantBaseUrl/$restaurantId'),
      );

      if (response.statusCode == 200) {
        return Restaurant.fromJson(jsonDecode(response.body));
      }
      throw Exception('Failed to load restaurant details');
    } catch (e) {
      throw Exception('Restaurant details error: $e');
    }
  }
}


/* File: ./client_customer\lib\services\auth_service.dart */
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

class AuthService {
  static const String _tokenKey = 'auth_token';
  static const String _userKey = 'auth_user';

  Future<bool> saveAuthData(String token, String userJson) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_tokenKey, token);
      await prefs.setString(_userKey, userJson);
      return true;
    } catch (e) {
      debugPrint('Error saving auth data: $e');
      return false;
    }
  }

  Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_tokenKey);
  }

  Future<Map<String, dynamic>?> getUser() async {
    final prefs = await SharedPreferences.getInstance();
    final userJson = prefs.getString(_userKey);
    if (userJson != null) {
      return Map<String, dynamic>.from(jsonDecode(userJson));
    }
    return null;
  }

  Future<bool> clearAuthData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_tokenKey);
      await prefs.remove(_userKey);
      return true;
    } catch (e) {
      debugPrint('Error clearing auth data: $e');
      return false;
    }
  }
}


/* File: ./client_customer\lib\services\cart_service.dart */
// File: services/cart_service.dart

import 'dart:convert';
import 'package:http/http.dart' as http;
import '../services/auth_service.dart';

class CartService {
  final String baseUrl = 'http://10.0.2.2:3002/api/cart';
  final AuthService _authService = AuthService();

  Future<Map<String, dynamic>> getCart() async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.get(
        Uri.parse(baseUrl),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

  Future<Map<String, dynamic>> addToCart({
    required String restaurantId,
    required String menuItemId,
    required String name,
    required double price,
    required int quantity,
  }) async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.post(
        Uri.parse('$baseUrl/items'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode({
          'restaurantId': restaurantId,
          'menuItemId': menuItemId,
          'name': name,
          'price': price,
          'quantity': quantity,
        }),
      );

      if (response.statusCode == 200) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

  Future<Map<String, dynamic>> updateCartItem(
      String itemId, int quantity) async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.patch(
        Uri.parse('$baseUrl/items'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode({
          'itemId': itemId,
          'quantity': quantity,
        }),
      );

      if (response.statusCode == 200) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

  Future<Map<String, dynamic>> clearCart() async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.delete(
        Uri.parse(baseUrl),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        return {
          'success': true,
          'message': 'Cart cleared successfully',
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

// Method to checkout the cart
  Future<Map<String, dynamic>> checkout(
      Map<String, dynamic> checkoutData) async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.post(
        Uri.parse('$baseUrl/checkout'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode(checkoutData),
      );

      if (response.statusCode == 201) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

// Make sure you have this helper method in your class
  String _parseErrorMessage(http.Response response) {
    try {
      final parsedResponse = jsonDecode(response.body);
      return parsedResponse['message'] ?? 'Unknown error occurred';
    } catch (e) {
      return 'Error: ${response.statusCode}';
    }
  }

  Future<Map<String, dynamic>> removeFromCart(String itemId) async {
    try {
      final token = await _authService.getToken();

      if (token == null) {
        return {
          'success': false,
          'message': 'You need to login first',
        };
      }

      final response = await http.delete(
        Uri.parse('$baseUrl/items/$itemId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorMsg = _parseErrorMessage(response);
        return {
          'success': false,
          'message': errorMsg,
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to connect to server: $e',
      };
    }
  }

  Future<Map<String, dynamic>> checkoutRestaurant(
    String restaurantId,
    String deliveryAddress,
    String paymentMethod,
    List<double>? coordinates,
  ) async {
    try {
      final token = await _authService.getToken();
      if (token == null) {
        throw Exception('No authentication token found');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/checkout'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode({
          'restaurantId': restaurantId,
          'deliveryAddress': deliveryAddress,
          'paymentMethod': paymentMethod,
          'deliveryLocation': {
            'coordinates': coordinates,
          },
        }),
      );

      if (response.statusCode == 201) {
        return {
          'success': true,
          'data': jsonDecode(response.body),
        };
      } else {
        final errorData = jsonDecode(response.body);
        return {
          'success': false,
          'message': errorData['message'] ?? 'Failed to checkout',
        };
      }
    } catch (e) {
      return {
        'success': false,
        'message': 'Error during checkout: $e',
      };
    }
  }
}


/* File: ./client_customer\lib\services\notification_service.dart */
// lib/services/notification_service.dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';

class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final GlobalKey<NavigatorState> navigatorKey;

  NotificationService({required this.navigatorKey});

  Future<void> initialize() async {
    try {
      // Request permissions
      NotificationSettings settings = await _messaging.requestPermission(
        alert: true,
        badge: true,
        sound: true,
      );
      print('⚙️ FCM Permission status: ${settings.authorizationStatus}');

      // Get FCM token
      final token = await _messaging.getToken();
      print('🔑 FCM Token: ${token?.substring(0, 10)}...');

      // Configure handlers
      FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
      FirebaseMessaging.onBackgroundMessage(
          _firebaseMessagingBackgroundHandler);
      FirebaseMessaging.onMessageOpenedApp.listen(_handleMessageOpenedApp);

      print('✅ FCM initialized successfully');
    } catch (e) {
      print('❌ FCM initialization error: $e');
    }
  }

  void _handleForegroundMessage(RemoteMessage message) {
    print('📨 Foreground message received:');
    print('Title: ${message.notification?.title}');
    print('Body: ${message.notification?.body}');
    print('Data: ${message.data}');
  }

  void _handleMessageOpenedApp(RemoteMessage message) {
    print('🔔 Notification tapped:');
    print('Data: ${message.data}');

    if (message.data.containsKey('orderId')) {
      navigatorKey.currentState?.pushNamed(
        '/order-tracking',
        arguments: message.data['orderId'],
      );
    }
  }
}

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // No need to initialize Firebase here since it's already initialized in main
  print('Background message received: ${message.messageId}');
}


/* File: ./client_customer\lib\services\order_service.dart */
// services/order_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/order.dart';
import 'auth_service.dart';
import 'restaurant_service.dart';

class OrderService {
  final String baseUrl = 'http://10.0.2.2:3002'; // Order service URL
  final AuthService _authService = AuthService();
  final RestaurantService _restaurantService = RestaurantService();

  // Get orders for the current customer
  Future<List<Order>> getCustomerOrders() async {
    try {
      final token = await _authService.getToken();
      final user = await _authService.getUser();

      if (token == null || user == null) {
        throw Exception('Authentication required');
      }

      final userId = user['_id'];

      final response = await http.get(
        Uri.parse('$baseUrl/api/orders/customer/$userId'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to load orders: ${response.statusCode}');
      }

      final List<dynamic> ordersJson = jsonDecode(response.body);
      final List<Order> orders = [];

      // Get restaurant details for each order
      for (var orderJson in ordersJson) {
        final restaurantId = orderJson['restaurantId'];
        String restaurantName = 'Restaurant';

        try {
          final restaurant =
              await _restaurantService.getRestaurantById(restaurantId);

          print('restaurant: $restaurant');
          restaurantName = restaurant.name;
        } catch (e) {
          print('Error fetching restaurant: $e');
        }

        orders.add(Order.fromJson(orderJson, restaurantName: restaurantName));
      }

      return orders;
    } catch (e) {
      print('Error fetching orders: $e');
      throw Exception('Failed to load orders: $e');
    }
  }

  // // Get a specific order by ID
  // Future<Order> getOrderDetails(String orderId) async {
  //   // Implementation similar to getCustomerOrders but for a single order
  //   // Omitted for brevity
  // }
}


/* File: ./client_customer\lib\services\payhere_service.dart */
// services/payhere_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:payhere_mobilesdk_flutter/payhere_mobilesdk_flutter.dart';
import '../services/auth_service.dart';

class PayhereService {
  static const String _baseUrl =
      'http://10.0.2.2:3003/api/payments'; // Update with your payment service URL

  // PayHere sandbox credentials
  static const String _merchantId = "1230199"; // Replace with your merchant ID
  static const String _merchantSecret =
      "MjY3MzgyNDY4NjMzNTQ5NjgwOTY5MjE0ODU2ODM4NDAyODA0MzE="; // Replace with your merchant secret
  static const bool _isSandbox = true; // Set to false for production

  Future<Map<String, dynamic>> initiatePayment({
    required String orderId,
    required double amount,
    required String items,
    required String customerName,
    String? email,
    String? phone,
    String? address,
  }) async {
    try {
      if (amount <= 0) {
        return {
          "success": false,
          "message": "Invalid payment amount",
        };
      }

      // Format amount with 2 decimal places
      String formattedAmount = amount.toStringAsFixed(2);

      // Create the PayHere payment object with sandbox configuration
      Map<String, dynamic> paymentObject = {
        "sandbox": _isSandbox,
        "merchant_id": _merchantId,
        "return_url": "http://sample.com/return",
        "cancel_url": "http://sample.com/cancel",
        "notify_url": "http://sample.com/notify",
        "order_id": orderId,
        "items": items,
        "amount": formattedAmount,
        "currency": "LKR",
        "first_name": customerName.split(' ').first,
        "last_name": customerName.split(' ').length > 1
            ? customerName.split(' ').sublist(1).join(' ')
            : '',
        "email": email ?? "customer@email.com",
        "phone": phone ?? "0771234567",
        "address": address ?? "No.1, Galle Road",
        "city": "Colombo",
        "country": "Sri Lanka",
        "delivery_address": address ?? "No. 46, Galle road, Kalutara South",
        "delivery_city": "Kalutara",
        "delivery_country": "Sri Lanka",
        "platform": "mobile"
      };

      return {
        "success": true,
        "paymentObject": paymentObject,
      };
    } catch (e) {
      return {
        "success": false,
        "message": "Error creating payment: $e",
      };
    }
  }

  Future<Map<String, dynamic>> savePaymentDetails({
    required String orderId,
    required String paymentId,
    required double amount,
    required String status,
  }) async {
    try {
      final token = await AuthService().getToken();
      if (token == null) {
        return {
          'success': false,
          'message': 'Authentication token not found',
        };
      }

      final response = await http.post(
        Uri.parse('$_baseUrl/store'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode({
          'orderId': orderId,
          'paymentId': paymentId,
          'amount': amount,
          'status': status,
          'currency': 'LKR'
        }),
      );

      if (response.statusCode == 201) {
        return {"success": true};
      } else {
        return {"success": false, "message": "Failed to update payment status"};
      }
    } catch (e) {
      return {"success": false, "message": "Error saving payment details: $e"};
    }
  }
}


/* File: ./client_customer\lib\services\restaurant_service.dart */
// lib/services/restaurant_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/restaurant.dart';
import '../utils/constants.dart';
import 'auth_service.dart';

class RestaurantService {
  final AuthService _authService = AuthService();
  final String _baseUrl = ApiConstants.restaurantBaseUrl;

  Future<List<Restaurant>> getNearbyRestaurants({
    required double latitude,
    required double longitude,
    required double radius,
  }) async {
    try {
      final token = await _authService.getToken();
      if (token == null) {
        throw Exception('Authentication token not found');
      }

      final response = await http.get(
        Uri.parse(
          '${ApiConstants.restaurantBaseUrl}/nearby?latitude=$latitude&longitude=$longitude&radius=$radius',
        ),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        // The response is a JSON array, not an object
        List<dynamic> data = jsonDecode(response.body);
        return data.map((json) => Restaurant.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load restaurants: ${response.statusCode}');
      }
    } catch (e) {
      throw Exception('Failed to load restaurants: $e');
    }
  }

  Future<Restaurant> getRestaurantById(String id) async {
    try {
      final token = await _authService.getToken();
      if (token == null) {
        throw Exception('Authentication token not found');
      }

      final response = await http.get(
        Uri.parse('$_baseUrl/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        print('Restaurant API response received');
        print('Response body: ${response.body}');

        final Map<String, dynamic> responseData = json.decode(response.body);

        // Check if the restaurant data exists in the response
        if (responseData.containsKey('restaurant')) {
          // Extract the restaurant object and pass it to fromJson
          return Restaurant.fromJson(responseData['restaurant']);
        } else {
          throw Exception('Invalid response format: missing restaurant data');
        }
      } else {
        throw Exception('Failed to load restaurant: ${response.statusCode}');
      }
    } catch (e) {
      print('Error fetching restaurant: $e');
      throw Exception('Failed to load restaurant: $e');
    }
  }

  Future<List<Restaurant>> searchRestaurants(String query) async {
    try {
      final token = await _authService.getToken();
      if (token == null) {
        throw Exception('Authentication token not found');
      }

      final response = await http.get(
        Uri.parse('$_baseUrl/restaurants/search?query=$query'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        if (data['success'] == true) {
          return (data['data'] as List)
              .map((restaurantJson) => Restaurant.fromJson(restaurantJson))
              .toList();
        } else {
          throw Exception(data['message'] ?? 'Failed to search restaurants');
        }
      } else {
        throw Exception('Failed to search restaurants: ${response.statusCode}');
      }
    } catch (e) {
      throw Exception('Failed to search restaurants: $e');
    }
  }
}


/* File: ./client_customer\lib\theme\app_theme.dart */
import 'package:flutter/material.dart';

class AppColors {
  static const primary = Color(0xFFFFA000); // Orange for buttons and highlights
  static const secondary = Color(0xFF4F46E5); // Purple (optional)
  static const background = Color(0xFFFFFFFF);
  static const error = Color(0xFFEF4444);
  static const text = Color(0xFF111827);
  static const muted = Color(0xFF6B7280);
  static const border = Color(0xFFE5E7EB);
  static const lightprime = Color.fromARGB(255, 255, 226, 176); // Shadow color
}

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      fontFamily: 'InterVariable',
      scaffoldBackgroundColor: AppColors.background,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.light,
      ),
      textTheme: const TextTheme(
        displayLarge: TextStyle(fontSize: 32, fontWeight: FontWeight.w700),
        titleLarge: TextStyle(fontSize: 22, fontWeight: FontWeight.w600),
        bodyMedium: TextStyle(fontSize: 16, fontWeight: FontWeight.w400),
        labelLarge: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
      ),
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.background,
        foregroundColor: AppColors.text,
        elevation: 0,
        titleTextStyle: TextStyle(
          fontFamily: 'InterVariable',
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: AppColors.text,
        ),
      ),
      inputDecorationTheme: const InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
          borderSide: BorderSide(color: AppColors.border),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
          borderSide: BorderSide(color: AppColors.primary, width: 2),
        ),
        labelStyle: TextStyle(fontFamily: 'InterVariable'),
        contentPadding: EdgeInsets.symmetric(vertical: 18, horizontal: 16),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: Colors.white,
          minimumSize: const Size.fromHeight(56),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(32),
          ),
          textStyle: const TextStyle(
            fontFamily: 'InterVariable',
            fontWeight: FontWeight.w600,
            fontSize: 18,
          ),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
        fillColor: WidgetStateProperty.all(AppColors.primary),
      ),
    );
  }
}


/* File: ./client_customer\lib\utils\app_exceptions.dart */
// lib/utils/app_exceptions.dart
class AppException implements Exception {
  final String message;
  final String? prefix;
  final String? url;

  AppException([this.message = '', this.prefix, this.url]);

  @override
  String toString() {
    return "$prefix$message";
  }
}

class FetchDataException extends AppException {
  FetchDataException([String? message, String? url])
    : super(
        message ?? "Error During Communication",
        "Communication Error: ",
        url,
      );
}

class BadRequestException extends AppException {
  BadRequestException([String? message, String? url])
    : super(message ?? "Invalid Request", "Invalid Request: ", url);
}

class UnauthorisedException extends AppException {
  UnauthorisedException([String? message, String? url])
    : super(message ?? "Unauthorised", "Unauthorised: ", url);
}

class InvalidInputException extends AppException {
  InvalidInputException([String? message])
    : super(message ?? "Invalid Input", "Invalid Input: ");
}

class NetworkException extends AppException {
  NetworkException([String? message])
    : super(message ?? "Network Error", "Network Error: ");
}


/* File: ./client_customer\lib\utils\constants.dart */
class ApiConstants {
  static const String baseUrl = 'http://10.0.2.2:3001/api';

  static const String userBaseUrl = 'http://10.0.2.2:3000/api/users';
  static const String restaurantBaseUrl =
      'http://10.0.2.2:3001/api/restaurants';

  static const String cartBaseUrl = 'http://10.0.2.2:3001/api/cart';
}
class AppConstants {
  static const double defaultPadding = 16.0;
  static const double borderRadius = 8.0;
  static const int requestTimeout = 15; // seconds
}


/* File: ./client_customer\lib\utils\dialog_utils.dart */
// lib/utils/dialog_utils.dart
import 'package:flutter/material.dart';

class DialogUtils {
  static void showSnackBar(
    BuildContext context,
    String message, {
    bool isError = false,
    Duration duration = const Duration(seconds: 2),
  }) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? Colors.red : Colors.green,
        duration: duration,
      ),
    );
  }

  static Future<bool> showConfirmationDialog(
    BuildContext context,
    String title,
    String message,
  ) async {
    final result = await showDialog<bool>(
      context: context,
      builder:
          (context) => AlertDialog(
            title: Text(title),
            content: Text(message),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: const Text('Confirm'),
              ),
            ],
          ),
    );
    return result ?? false;
  }
}


/* File: ./client_customer\lib\utils\error_handler.dart */
// lib/utils/error_handler.dart
import 'dart:ui';

import 'package:flutter/material.dart';

class ErrorHandler {
  static void initialize() {
    // Catch Flutter errors
    FlutterError.onError = (FlutterErrorDetails details) {
      FlutterError.presentError(details);
      _reportError(details.exception, details.stack);
    };

    // Catch async errors that aren't caught by the Flutter framework
    PlatformDispatcher.instance.onError = (error, stack) {
      _reportError(error, stack);
      return true;
    };
  }

  static void _reportError(dynamic error, StackTrace? stack) {
    // Log the error (in a real app, you might send this to a service)
    debugPrint('Caught error: $error');
    if (stack != null) {
      debugPrint('Stack trace: $stack');
    }
  }

  // Helper method to show error snackbar
  static void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}


/* File: ./client_customer\lib\utils\screen_utils.dart */
// lib/utils/screen_utils.dart
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class ScreenUtil {
  static void init(
    BuildContext context, {
    Size designSize = const Size(360, 690),
  }) {
    ScreenUtilInit(designSize: designSize, builder: (_, __) => Container());
  }

  static double setWidth(double width) => width.w;
  static double setHeight(double height) => height.h;
  static double setRadius(double radius) => radius.r;
  static double setSp(double fontSize) => fontSize.sp;
}


/* File: ./client_customer\lib\utils\validation_utils.dart */
// lib/utils/validation_utils.dart
class ValidationUtils {
  static String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your email';
    }
    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
      return 'Please enter a valid email';
    }
    return null;
  }

  static String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your password';
    }
    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }

  static String? validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your phone number';
    }
    if (!RegExp(r'^\+?[\d\s-]{10,}$').hasMatch(value)) {
      return 'Enter a valid phone number (e.g. +94771234567)';
    }
    return null;
  }

  static String? validateRequired(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return 'Please enter your $fieldName';
    }
    return null;
  }
}


/* File: ./client_customer\lib\widgets\menu_item_card.dart */
// lib/widgets/menu_item_card.dart
import 'package:flutter/material.dart';
import '../models/restaurant.dart';
import '../theme/app_theme.dart';

class MenuItemCard extends StatelessWidget {
  final MenuItem menuItem;
  final String restaurantId;
  final VoidCallback onAddToCart;

  const MenuItemCard({
    super.key,
    required this.menuItem,
    required this.restaurantId,
    required this.onAddToCart,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16.0),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Menu item image with proper constraints
            ClipRRect(
              borderRadius: BorderRadius.circular(8.0),
              child: SizedBox(
                width: 80,
                height: 80,
                child: menuItem.image.isNotEmpty
                    ? Image.network(
                        menuItem.image,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) {
                          return Container(
                            color: Colors.grey[300],
                            child: const Icon(
                              Icons.restaurant,
                              color: Colors.grey,
                            ),
                          );
                        },
                        loadingBuilder: (context, child, loadingProgress) {
                          if (loadingProgress == null) return child;
                          return Container(
                            color: Colors.grey[200],
                            child: const Center(
                              child: CircularProgressIndicator(),
                            ),
                          );
                        },
                      )
                    : Container(
                        color: Colors.grey[300],
                        child: const Icon(
                          Icons.restaurant,
                          color: Colors.grey,
                        ),
                      ),
              ),
            ),
            const SizedBox(width: 16),
            // Menu item details
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    menuItem.name,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    menuItem.description,
                    style: TextStyle(color: Colors.grey[600], fontSize: 14),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'LKR ${menuItem.price.toStringAsFixed(2)}',
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: AppColors.primary,
                        ),
                      ),
                      ElevatedButton(
                        onPressed: onAddToCart,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppColors.primary,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(20),
                          ),
                          padding: const EdgeInsets.symmetric(
                            horizontal: 12,
                            vertical: 8,
                          ),
                        ),
                        child: const Text(
                          'Add',
                          style: TextStyle(color: Colors.white),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


/* File: ./client_customer\lib\widgets\rouded_text_field.dart */
// lib/widgets/rounded_text_field.dart
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../theme/app_theme.dart';

class RoundedTextField extends StatelessWidget {
  final TextEditingController controller;
  final String? hintText;
  final TextInputType? keyboardType;
  final bool obscureText;
  final Widget? suffixIcon;
  final String? Function(String?)? validator;
  final String? labelText;

  const RoundedTextField({
    super.key,
    required this.controller,
    this.hintText,
    this.keyboardType,
    this.obscureText = false,
    this.suffixIcon,
    this.validator,
    this.labelText,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (labelText != null) ...[
          Text(
            labelText!,
            style: Theme.of(context).textTheme.labelLarge?.copyWith(
                  color: Colors.black,
                  fontWeight: FontWeight.w600,
                ),
          ),
          SizedBox(height: 8.h),
        ],
        TextFormField(
          controller: controller,
          keyboardType: keyboardType,
          obscureText: obscureText,
          validator: validator,
          style: TextStyle(fontSize: 16.sp),
          decoration: InputDecoration(
            hintText: hintText,
            filled: true,
            fillColor: Colors.white,
            contentPadding: EdgeInsets.symmetric(
              vertical: 20.h,
              horizontal: 16.w,
            ),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14.r),
              borderSide: BorderSide(color: Colors.grey.shade300, width: 1.5),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14.r),
              borderSide: BorderSide(color: Colors.grey.shade300, width: 1.5),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14.r),
              borderSide: BorderSide(color: AppColors.primary, width: 2),
            ),
            suffixIcon: suffixIcon,
          ),
        ),
      ],
    );
  }
}


/* File: ./client_customer\lib\widgets\rounded_button.dart */
// lib/widgets/rounded_button.dart
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../theme/app_theme.dart';

class RoundedButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final Color? backgroundColor;
  final Color? textColor;
  final double? height;
  final double? width;
  final double? borderRadius;

  const RoundedButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.backgroundColor,
    this.textColor,
    this.height,
    this.width,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width ?? double.infinity,
      height: height ?? 56.h,
      child: ElevatedButton(
        onPressed: isLoading ? null : onPressed,
        style: ElevatedButton.styleFrom(
          backgroundColor: backgroundColor ?? AppColors.primary,
          foregroundColor: textColor ?? Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(borderRadius ?? 32.r),
          ),
          textStyle: TextStyle(fontWeight: FontWeight.w600, fontSize: 18.sp),
        ),
        child: isLoading
            ? const CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              )
            : Text(text),
      ),
    );
  }
}


/* File: ./client_customer\test\widget_test.dart */
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:client_customer/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}


/* File: ./client_web\eslint.config.js */
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


/* File: ./client_web\vite.config.js */

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    port: 5199,
  },
});



/* File: ./client_web\src\App.css */
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


/* File: ./client_web\src\App.jsx */
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./context/AuthContext";
import Layout from "./components/Layout";
import Login from "./pages/Auth/Login";
import RestaurantAdminRequest from "./pages/Auth/RestaurantAdminRequest";
import AdminDashboard from "./pages/admin/Dashboard";
import AdminUsers from "./pages/admin/Users";
import AdminRestaurantAdmins from "./pages/admin/RestaurantAdmins";
import RestaurantManagement from "./pages/admin/RestaurantManagement";
import AdminDeliveryPersonnel from "./pages/admin/DeliveryPersonnel";
import RestaurantAdminDashboard from "./pages/restaurant-admin/Dashboard";
import RestaurantAdminProfile from "./pages/restaurant-admin/Profile";
import NotFound from "./pages/NotFound";
import ProtectedRoute from "./components/ProtectedRoute";

function App() {
  return (
    <Router>
      <AuthProvider>
        <Routes>
          {/* Public routes */}
          <Route path="/login" element={<Login />} />
          <Route
            path="/restaurant-admin/request"
            element={<RestaurantAdminRequest />}
          />

          {/* Admin routes */}
          <Route
            path="/admin"
            element={<ProtectedRoute allowedRoles={["admin"]} />}
          >
            <Route element={<Layout role="admin" />}>
              <Route index element={<AdminDashboard />} />
              <Route path="users" element={<AdminUsers />} />
              <Route
                path="restaurant-admins"
                element={<AdminRestaurantAdmins />}
              />
              <Route
                path="delivery-personnel"
                element={<AdminDeliveryPersonnel />}
              />
              <Route
                path="restaurant-management"
                element={<RestaurantManagement />}
              />
            </Route>
          </Route>

          {/* Restaurant admin routes */}
          <Route
            path="/restaurant-admin"
            element={<ProtectedRoute allowedRoles={["restaurant_admin"]} />}
          >
            <Route element={<Layout role="restaurant_admin" />}>
              <Route index element={<RestaurantAdminDashboard />} />
              <Route path="profile" element={<RestaurantAdminProfile />} />
            </Route>
          </Route>

          {/* 404 */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;



/* File: ./client_web\src\index.css */

@import "tailwindcss";


/* File: ./client_web\src\main.jsx */

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



/* File: ./client_web\src\components\Layout.jsx */
import { Outlet } from "react-router-dom";
import Sidebar from "./layout/Sidebar";

const Layout = ({ role }) => {
  return (
    <div className="flex">
      <Sidebar role={role} />
      <div className="flex-1 ml-64 p-6">
        <Outlet />
      </div>
    </div>
  );
};

export default Layout;


/* File: ./client_web\src\components\ProtectedRoute.jsx */
import { useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";

const ProtectedRoute = ({ allowedRoles }) => {
  const { user, loading } = useContext(AuthContext);

  console.log("ProtectedRoute user:", user);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (!allowedRoles.includes(user.role)) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default ProtectedRoute;


/* File: ./client_web\src\components\RestaurantAdminAssignment.jsx */
import { useState, useEffect } from "react";
import { userServiceApi, restaurantServiceApi } from "../utils/api";
import { toast } from "react-toastify";

const RestaurantAdminAssignment = ({ restaurantId, onClose }) => {
  const [admins, setAdmins] = useState([]);
  const [newAdmin, setNewAdmin] = useState({
    name: "",
    email: "",
    phone: "",
    password: "",
    restaurantId: restaurantId
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [restaurantInfo, setRestaurantInfo] = useState(null);

  // Fetch restaurant info and admins
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch restaurant info
        const restaurantResponse = await restaurantServiceApi.get(
          `/api/restaurants/${restaurantId}`
        );
        setRestaurantInfo(restaurantResponse.data.data.restaurant);

        // Fetch admins
        const adminsResponse = await userServiceApi.get(
          `/api/users/restaurant/${restaurantId}/admins`
        );
        setAdmins(adminsResponse.data.data.admins);
      } catch (err) {
        setError("Failed to fetch data");
        console.error("Fetch error:", err);
      }
    };
    
    fetchData();
  }, [restaurantId]);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewAdmin(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleCreateAdmin = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    
    try {
      const response = await userServiceApi.post(
        "/api/users/restaurant-admin",
        {
          ...newAdmin,
          password: newAdmin.password || generateRandomPassword()
        }
      );

      setAdmins(prev => [...prev, response.data.data.user]);
      setNewAdmin({
        name: "",
        email: "",
        phone: "",
        password: "",
        restaurantId: restaurantId
      });
      toast.success("Restaurant admin created successfully");
    } catch (err) {
      const errorMsg = err.response?.data?.message || "Failed to create admin";
      setError(errorMsg);
      toast.error(errorMsg);
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveAdmin = async (adminId) => {
    if (!window.confirm("Are you sure you want to remove this admin?")) return;
    
    try {
      await userServiceApi.delete(`/api/users/restaurant-admin/${adminId}`);
      setAdmins(prev => prev.filter(admin => admin._id !== adminId));
      toast.success("Admin removed successfully");
    } catch (err) {
      const errorMsg = err.response?.data?.message || "Failed to remove admin";
      setError(errorMsg);
      toast.error(errorMsg);
    }
  };

  const generateRandomPassword = () => {
    return Math.random().toString(36).slice(-8);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-6 rounded-lg w-full max-w-2xl max-h-screen overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h2 className="text-xl font-bold">Manage Restaurant Admins</h2>
            {restaurantInfo && (
              <p className="text-sm text-gray-600">
                Restaurant: {restaurantInfo.name}
              </p>
            )}
          </div>
          <button 
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 text-2xl"
            aria-label="Close modal"
          >
            &times;
          </button>
        </div>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <div className="mb-6">
          <h3 className="text-lg font-semibold mb-2">Create New Admin</h3>
          <form onSubmit={handleCreateAdmin} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-700">
                  Name
                </label>
                <input
                  type="text"
                  id="name"
                  name="name"
                  value={newAdmin.name}
                  onChange={handleInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                  required
                />
              </div>
              <div>
                <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                  Email
                </label>
                <input
                  type="email"
                  id="email"
                  name="email"
                  value={newAdmin.email}
                  onChange={handleInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                  required
                />
              </div>
              <div>
                <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
                  Phone
                </label>
                <input
                  type="tel"
                  id="phone"
                  name="phone"
                  value={newAdmin.phone}
                  onChange={handleInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                  required
                />
              </div>
              <div>
                <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                  Password (leave blank to auto-generate)
                </label>
                <input
                  type="password"
                  id="password"
                  name="password"
                  value={newAdmin.password}
                  onChange={handleInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                />
              </div>
            </div>
            <div className="flex justify-end">
              <button
                type="submit"
                className="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                disabled={loading}
              >
                {loading ? (
                  <>
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Creating...
                  </>
                ) : "Create Admin"}
              </button>
            </div>
          </form>
        </div>

        <div>
          <h3 className="text-lg font-semibold mb-2">Current Admins</h3>
          {admins.length === 0 ? (
            <p className="text-gray-500">No admins assigned to this restaurant</p>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Name
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Email
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Phone
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {admins.map(admin => (
                    <tr key={admin._id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {admin.name}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {admin.email}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {admin.phone}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <button 
                          onClick={() => handleRemoveAdmin(admin._id)}
                          className="text-red-600 hover:text-red-900"
                        >
                          Remove
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default RestaurantAdminAssignment;

/* File: ./client_web\src\components\layout\Sidebar.jsx */
import { Link, useLocation } from "react-router-dom";
import { AuthContext } from "../../context/AuthContext";
import { useContext } from "react";
import {
  MdDashboard,
  MdPeople,
  MdRestaurant,
  MdDeliveryDining,
  MdLogout,
  MdPerson,
} from "react-icons/md";

const adminLinks = [
  { name: "Dashboard", path: "/admin", icon: <MdDashboard /> },
  { name: "Users", path: "/admin/users", icon: <MdPeople /> },
  {
    name: "Restaurant Management",  // Changed text from 'Restaurant Admins' to 'Restaurant Management'
    path: "/admin/restaurant-management",
    icon: <MdRestaurant />,
  },
  {
    name: "Delivery Personnel",
    path: "/admin/delivery-personnel",
    icon: <MdDeliveryDining />,
  },
];

const restaurantAdminLinks = [
  { name: "Dashboard", path: "/restaurant-admin", icon: <MdDashboard /> },
  { name: "Profile", path: "/restaurant-admin/profile", icon: <MdPerson /> },
];

const Sidebar = ({ role }) => {
  const location = useLocation();
  const { logout } = useContext(AuthContext);

  const links = role === "admin" ? adminLinks : restaurantAdminLinks;

  return (
    <div className="w-64 bg-gray-800 text-white h-screen fixed">
      <div className="p-4 border-b border-gray-700">
        <h1 className="text-xl font-bold">
          {role === "admin" ? "Admin Panel" : "Restaurant Admin"}
        </h1>
      </div>

      <nav className="p-4">
        <ul className="space-y-2">
          {links.map((link) => (
            <li key={link.path}>
              <Link
                to={link.path}
                className={`flex items-center p-2 rounded-lg hover:bg-gray-700 ${
                  location.pathname === link.path ? "bg-gray-700" : ""
                }`}
              >
                <span className="material-icons mr-3">{link.icon}</span>
                {link.name}
              </Link>
            </li>
          ))}
        </ul>
      </nav>

      <div className="absolute bottom-0 w-full p-4">
        <button
          onClick={logout}
          className="w-full flex items-center justify-center p-2 rounded-lg bg-red-600 hover:bg-red-700"
        >
          <span className="material-icons mr-2">logout</span>
          Logout
        </button>
      </div>
    </div>
  );
};

export default Sidebar;

/* File: ./client_web\src\components\ui\toaster.jsx */
function _optionalChain(ops) {
  let lastAccessLHS = undefined
  let value = ops[0]
  let i = 1
  while (i < ops.length) {
    const op = ops[i]
    const fn = ops[i + 1]
    i += 2
    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
      return undefined
    }
    if (op === 'access' || op === 'optionalAccess') {
      lastAccessLHS = value
      value = fn(value)
    } else if (op === 'call' || op === 'optionalCall') {
      value = fn((...args) => value.call(lastAccessLHS, ...args))
      lastAccessLHS = undefined
    }
  }
  return value
}
;('use client')

import {
  Toaster as ChakraToaster,
  Portal,
  Spinner,
  Stack,
  Toast,
  createToaster,
} from '@chakra-ui/react'

export const toaster = createToaster({
  placement: 'bottom-end',
  pauseOnPageIdle: true,
})

export const Toaster = () => {
  return (
    <Portal>
      <ChakraToaster toaster={toaster} insetInline={{ mdDown: '4' }}>
        {(toast) => (
          <Toast.Root width={{ md: 'sm' }}>
            {toast.type === 'loading' ? (
              <Spinner size='sm' color='blue.solid' />
            ) : (
              <Toast.Indicator />
            )}
            <Stack gap='1' flex='1' maxWidth='100%'>
              {toast.title && <Toast.Title>{toast.title}</Toast.Title>}
              {toast.description && (
                <Toast.Description>{toast.description}</Toast.Description>
              )}
            </Stack>
            {toast.action && (
              <Toast.ActionTrigger>{toast.action.label}</Toast.ActionTrigger>
            )}
            {_optionalChain([
              toast,
              'access',
              (_) => _.meta,
              'optionalAccess',
              (_2) => _2.closable,
            ]) && <Toast.CloseTrigger />}
          </Toast.Root>
        )}
      </ChakraToaster>
    </Portal>
  )
}


/* File: ./client_web\src\context\AuthContext.jsx */
import { createContext, useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { userServiceApi } from "../utils/api"; // Updated import to use userServiceApi

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const token = localStorage.getItem("token");
        console.log("Auth provider Token:", token);
        if (token) {
          const response = await userServiceApi.get("/api/users/me"); // Changed to use userServiceApi
          console.log("Auth check response:", response);
          if (response.status === 401 || response.status === 404) {
            logout();
          }
          setUser(response.data.data.user);
        }
      } catch (error) {
        console.error("Auth check failed:", error);
        console.log("Error response:", error.response);
        if (error.response?.status === 401 || error.response?.status === 404) {
          logout();
        }
        logout();
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (credentials) => {
    try {
      const response = await userServiceApi.post("/api/users/login", credentials); // Changed to use userServiceApi

      // Check for error in response body
      if (response.data.error) {
        throw new Error(response.data.error);
        console.log("Login error:", response.data.error);
      }

      localStorage.setItem("token", response.data.token);
      setUser(response.data.data.user);
      return { ...response.data, user: response.data.data.user };
    } catch (error) {
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem("token");
    setUser(null);
    navigate("/login");
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

/* File: ./client_web\src\pages\NotFound.jsx */
import { Link } from "react-router-dom";

const NotFound = () => {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="text-6xl font-bold text-gray-800 mb-4">404</h1>
        <h2 className="text-2xl font-semibold text-gray-700 mb-6">
          Page Not Found
        </h2>
        <p className="text-gray-600 mb-8">
          The page you are looking for doesn't exist or has been moved.
        </p>
        <Link
          to="/"
          className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition duration-300"
        >
          Go Back Home
        </Link>
      </div>
    </div>
  );
};

export default NotFound;


/* File: ./client_web\src\pages\admin\Dashboard.jsx */
import { useContext, useEffect, useState } from "react";
import { userServiceApi, restaurantServiceApi } from '../../utils/api';
import { AuthContext } from "../../context/AuthContext";

const AdminDashboard = () => {
  const { user } = useContext(AuthContext);
  const [stats, setStats] = useState({
    users: 0,
    restaurantAdmins: 0,
    deliveryPersonnel: 0,
    pendingRequests: 0,
  });

  useEffect(() => {
    const fetchStats = async () => {
      try {
        const [usersRes, restaurantAdminsRes, deliveryRes, pendingRes] =
          await Promise.all([
            userServiceApi.get("/api/users?role=customer"),
            userServiceApi.get("/api/users?role=restaurant_admin"),
            userServiceApi.get("/api/users?role=delivery_personnel"),
            userServiceApi.get("/api/users?status=pending"),
          ]);

        setStats({
          users: usersRes.data.results,
          restaurantAdmins: restaurantAdminsRes.data.results,
          deliveryPersonnel: deliveryRes.data.results,
          pendingRequests: pendingRes.data.results,
        });
      } catch (error) {
        console.error("Failed to fetch stats:", error);
      }
    };

    fetchStats();
  }, []);

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Admin Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Total Users</h3>
          <p className="text-3xl font-bold">{stats.users}</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Restaurant Admins</h3>
          <p className="text-3xl font-bold">{stats.restaurantAdmins}</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Delivery Personnel</h3>
          <p className="text-3xl font-bold">{stats.deliveryPersonnel}</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Pending Requests</h3>
          <p className="text-3xl font-bold">{stats.pendingRequests}</p>
        </div>
      </div>

      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">Recent Activities</h2>
        {/* Recent activities list would go here */}
      </div>
    </div>
  );
};

export default AdminDashboard;


/* File: ./client_web\src\pages\admin\DeliveryPersonnel.jsx */
import { useContext, useEffect, useState } from "react";
import { userServiceApi } from "../../utils/api"; // Import userServiceApi
import { AuthContext } from "../../context/AuthContext";

const AdminDeliveryPersonnel = () => {
  const { user } = useContext(AuthContext);
  const [deliveryPersons, setDeliveryPersons] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchDeliveryPersons = async () => {
      try {
        const response = await userServiceApi.get("/api/users?role=delivery_personnel"); // Use userServiceApi
        setDeliveryPersons(response.data.users);
      } catch (err) {
        setError(
          err.response?.data?.message || "Failed to fetch delivery personnel"
        );
      } finally {
        setLoading(false);
      }
    };

    fetchDeliveryPersons();
  }, []);

  const approveDeliveryPerson = async (userId) => {
    try {
      await userServiceApi.patch("/api/users/delivery/approve", { userId }); // Use userServiceApi
      setDeliveryPersons(
        deliveryPersons.map((person) =>
          person._id === userId
            ? { ...person, isActive: true, status: "approved" }
            : person
        )
      );
    } catch (err) {
      setError(
        err.response?.data?.message || "Failed to approve delivery person"
      );
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div className="text-red-500">{error}</div>;

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Delivery Personnel Management</h1>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Phone
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Vehicle
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Status
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {deliveryPersons.map((person) => (
              <tr key={person._id}>
                <td className="px-6 py-4 whitespace-nowrap">{person.name}</td>
                <td className="px-6 py-4 whitespace-nowrap">{person.phone}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {person.vehicleInfo?.type} ({person.vehicleInfo?.number})
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span
                    className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                    ${
                      person.status === "approved"
                        ? "bg-green-100 text-green-800"
                        : person.status === "pending"
                        ? "bg-yellow-100 text-yellow-800"
                        : "bg-red-100 text-red-800"
                    }`}
                  >
                    {person.status}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {!person.isActive && (
                    <button
                      onClick={() => approveDeliveryPerson(person._id)}
                      className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded text-sm"
                    >
                      Approve
                    </button>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default AdminDeliveryPersonnel;

/* File: ./client_web\src\pages\admin\RestaurantAdmins.jsx */
import { useContext, useEffect, useState } from "react";
import { userServiceApi } from "../../utils/api"; // Import userServiceApi
import { AuthContext } from "../../context/AuthContext";

const AdminRestaurantAdmins = () => {
  const { user } = useContext(AuthContext);
  const [admins, setAdmins] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchAdmins = async () => {
      try {
        const response = await userServiceApi.get("/api/users?role=restaurant_admin");
        setAdmins(response.data.users);
      } catch (err) {
        setError(err.response?.data?.message || "Failed to fetch admins");
      } finally {
        setLoading(false);
      }
    };

    fetchAdmins();
  }, []);

  const approveAdmin = async (userId, restaurantId) => {
    try {
      await userServiceApi.patch("/api/users/restaurant-admin/approve", {
        userId,
        restaurantId,
      });
      setAdmins(
        admins.map((admin) =>
          admin._id === userId
            ? { ...admin, isActive: true, status: "approved" }
            : admin
        )
      );
    } catch (err) {
      setError(err.response?.data?.message || "Failed to approve admin");
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div className="text-red-500">{error}</div>;

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Restaurant Admins Management</h1>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Email
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Restaurant
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Status
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {admins.map((admin) => (
              <tr key={admin._id}>
                <td className="px-6 py-4 whitespace-nowrap">{admin.name}</td>
                <td className="px-6 py-4 whitespace-nowrap">{admin.email}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {admin.restaurantDetails?.name || "N/A"}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span
                    className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                    ${
                      admin.status === "approved"
                        ? "bg-green-100 text-green-800"
                        : admin.status === "pending"
                        ? "bg-yellow-100 text-yellow-800"
                        : "bg-red-100 text-red-800"
                    }`}
                  >
                    {admin.status}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {!admin.isActive && (
                    <button
                      onClick={() =>
                        approveAdmin(admin._id, "restaurant-id-here")
                      }
                      className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded text-sm"
                    >
                      Approve
                    </button>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default AdminRestaurantAdmins;


/* File: ./client_web\src\pages\admin\RestaurantManagement.jsx */
import RestaurantAdminAssignment from "../../components/RestaurantAdminAssignment";
import { useState, useEffect } from "react";
import { restaurantServiceApi } from "../../utils/api";
import { useNavigate } from "react-router-dom";

const RestaurantManagement = () => {
  const navigate = useNavigate();
  const [restaurants, setRestaurants] = useState([]);
  const [newRestaurant, setNewRestaurant] = useState({
    name: "",
    description: "",
    address: {
      street: "",
      city: "",
      country: "",
      geoCoordinates: {
        longitude: "",
        latitude: "",
      },
    },
    operatingHours: {
      from: "",
      to: ""
    },
    menu: [
      {
        name: "",
        description: "",
        price: "",
        category: "",
        image: null
      }
    ]
  });
  const [coverImage, setCoverImage] = useState(null);
  const [menuItemImages, setMenuItemImages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [showModal, setShowModal] = useState(false);

  const [selectedRestaurant, setSelectedRestaurant] = useState(null);
  const [showAdminModal, setShowAdminModal] = useState(false);

  // Fetch restaurants when component mounts
  useEffect(() => {
    const fetchRestaurants = async () => {
      try {
        const response = await restaurantServiceApi.get("/api/restaurants");
        if (response.data?.status === "success" && Array.isArray(response.data?.data?.restaurants)) {
          setRestaurants(response.data.data.restaurants);
        } else {
          setError("Invalid response format: Expected an array.");
        }
      } catch (err) {
        setError("Error fetching restaurants.");
      }
    };

    fetchRestaurants();
  }, []);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setNewRestaurant(prev => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleAddressChange = (e) => {
    const { name, value } = e.target;
    setNewRestaurant(prev => ({
      ...prev,
      address: {
        ...prev.address,
        [name]: value,
      },
    }));
  };

  const handleGeoCoordinatesChange = (e) => {
    const { name, value } = e.target;
    setNewRestaurant(prev => ({
      ...prev,
      address: {
        ...prev.address,
        geoCoordinates: {
          ...prev.address.geoCoordinates,
          [name]: value,
        },
      },
    }));
  };

  const handleOperatingHoursChange = (e) => {
    const { name, value } = e.target;
    setNewRestaurant(prev => ({
      ...prev,
      operatingHours: {
        ...prev.operatingHours,
        [name]: value,
      },
    }));
  };

  const handleCoverImageChange = (e) => {
    setCoverImage(e.target.files[0]);
  };

  const handleMenuItemChange = (index, e) => {
    const { name, value } = e.target;
    const updatedMenu = [...newRestaurant.menu];
    updatedMenu[index] = {
      ...updatedMenu[index],
      [name]: value
    };
    setNewRestaurant(prev => ({
      ...prev,
      menu: updatedMenu
    }));
  };

  const handleMenuItemImageChange = (index, e) => {
    const files = e.target.files;
    if (files && files[0]) {
      const updatedImages = [...menuItemImages];
      updatedImages[index] = files[0];
      setMenuItemImages(updatedImages);
    }
  };

  const addMenuItem = () => {
    setNewRestaurant(prev => ({
      ...prev,
      menu: [
        ...prev.menu,
        {
          name: "",
          description: "",
          price: "",
          category: "",
          image: null
        }
      ]
    }));
  };

  const removeMenuItem = (index) => {
    const updatedMenu = [...newRestaurant.menu];
    updatedMenu.splice(index, 1);
    setNewRestaurant(prev => ({
      ...prev,
      menu: updatedMenu
    }));
    
    const updatedImages = [...menuItemImages];
    updatedImages.splice(index, 1);
    setMenuItemImages(updatedImages);
  };

    const handleCreateRestaurant = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
        // Validate required fields before sending
        if (!newRestaurant.name || !newRestaurant.address.geoCoordinates.longitude || !newRestaurant.address.geoCoordinates.latitude) {
        throw new Error('Name and geo coordinates are required');
        }

        const formData = new FormData();
        
        // Append basic fields
        formData.append("name", newRestaurant.name.trim());
        formData.append("description", newRestaurant.description?.trim() || '');
        
        // Append address with proper numeric conversion
        formData.append("address", JSON.stringify({
        street: newRestaurant.address.street?.trim() || '',
        city: newRestaurant.address.city?.trim() || '',
        country: newRestaurant.address.country?.trim() || '',
        geoCoordinates: {
            longitude: parseFloat(newRestaurant.address.geoCoordinates.longitude),
            latitude: parseFloat(newRestaurant.address.geoCoordinates.latitude)
        }
        }));
        
        // Append operating hours with defaults
        formData.append("operatingHours", JSON.stringify({
        from: newRestaurant.operatingHours.from || '09:00',
        to: newRestaurant.operatingHours.to || '21:00'
        }));
        
        // Process and validate menu items
        const validatedMenu = newRestaurant.menu.map(item => ({
        name: item.name?.trim() || 'Unnamed Item',
        description: item.description?.trim() || '',
        price: parseFloat(item.price) || 0,
        category: item.category?.trim() || 'other'
        }));
        
        formData.append("menu", JSON.stringify(validatedMenu));
        
        // Handle file uploads
        if (coverImage) {
        if (!coverImage.type.match('image.*')) {
            throw new Error('Cover image must be an image file');
        }
        formData.append("coverImage", coverImage);
        }

        menuItemImages.forEach((image, index) => {
        if (image) {
            if (!image.type.match('image.*')) {
            throw new Error(`Menu item image ${index + 1} must be an image file`);
            }
            formData.append("menuItemImages", image);
        }
        });

        // Debug: Log formData contents
        for (let [key, value] of formData.entries()) {
        console.log(key, typeof value === 'object' ? JSON.stringify(value) : value);
        }

        const response = await restaurantServiceApi.post("/api/restaurants", formData, {
        headers: {
            "Content-Type": "multipart/form-data",
            Authorization: `Bearer ${localStorage.getItem('token')}` // Ensure auth token is sent
        },
        timeout: 10000 // 10 second timeout
        });

        // Handle success response
        if (response.data?.status === 'success') {
        // Refresh restaurant list
        const restaurantResponse = await restaurantServiceApi.get("/api/restaurants");
        setRestaurants(restaurantResponse.data.data.restaurants);
        
        // Reset form
        setNewRestaurant({
            name: "",
            description: "",
            address: {
            street: "",
            city: "",
            country: "",
            geoCoordinates: {
                longitude: "",
                latitude: "",
            },
            },
            operatingHours: {
            from: "",
            to: ""
            },
            menu: [
            {
                name: "",
                description: "",
                price: "",
                category: "",
                image: null
            }
            ]
        });
        setCoverImage(null);
        setMenuItemImages([]);
        setShowModal(false);
        }
    } catch (err) {
        console.error("Error creating restaurant:", err);
        setError(err.response?.data?.message || 
                err.message || 
                "Error creating restaurant. Please check your inputs and try again.");
    } finally {
        setLoading(false);
    }
    };

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Restaurant Management</h1>

      {error && <div className="text-red-500 mb-4">{error}</div>}

      <button
        className="btn-primary mb-6"
        onClick={() => setShowModal(true)}
      >
        Create Restaurant
      </button>

      {showModal && (
        <div className="fixed inset-0 flex justify-center items-center bg-gray-500 bg-opacity-50 z-50">
          <div className="bg-white p-6 rounded-lg w-1/2 max-h-screen overflow-y-auto">
            <h2 className="text-xl font-semibold mb-4">Create New Restaurant</h2>
            <form onSubmit={handleCreateRestaurant} className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">Restaurant Name</label>
                <input
                  type="text"
                  name="name"
                  value={newRestaurant.name}
                  onChange={handleChange}
                  className="input-field"
                  required
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700">Description</label>
                <input
                  type="text"
                  name="description"
                  value={newRestaurant.description}
                  onChange={handleChange}
                  className="input-field"
                  required
                />
              </div>

              <div className="border p-4 rounded">
                <h3 className="text-lg font-semibold mb-2">Address</h3>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Street</label>
                    <input
                      type="text"
                      name="street"
                      value={newRestaurant.address.street}
                      onChange={handleAddressChange}
                      className="input-field"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">City</label>
                    <input
                      type="text"
                      name="city"
                      value={newRestaurant.address.city}
                      onChange={handleAddressChange}
                      className="input-field"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Country</label>
                    <input
                      type="text"
                      name="country"
                      value={newRestaurant.address.country}
                      onChange={handleAddressChange}
                      className="input-field"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Longitude</label>
                    <input
                      type="number"
                      name="longitude"
                      value={newRestaurant.address.geoCoordinates.longitude}
                      onChange={handleGeoCoordinatesChange}
                      step="any"
                      className="input-field"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Latitude</label>
                    <input
                      type="number"
                      name="latitude"
                      value={newRestaurant.address.geoCoordinates.latitude}
                      onChange={handleGeoCoordinatesChange}
                      step="any"
                      className="input-field"
                      required
                    />
                  </div>
                </div>
              </div>

              <div className="border p-4 rounded">
                <h3 className="text-lg font-semibold mb-2">Operating Hours</h3>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700">From</label>
                    <input
                      type="time"
                      name="from"
                      value={newRestaurant.operatingHours.from}
                      onChange={handleOperatingHoursChange}
                      className="input-field"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">To</label>
                    <input
                      type="time"
                      name="to"
                      value={newRestaurant.operatingHours.to}
                      onChange={handleOperatingHoursChange}
                      className="input-field"
                      required
                    />
                  </div>
                </div>
              </div>

              <div className="border p-4 rounded">
                <div className="flex justify-between items-center mb-2">
                  <h3 className="text-lg font-semibold">Menu Items</h3>
                  <button
                    type="button"
                    onClick={addMenuItem}
                    className="btn-secondary"
                  >
                    Add Menu Item
                  </button>
                </div>

                {newRestaurant.menu.map((item, index) => (
                  <div key={index} className="border p-4 mb-4 rounded">
                    <div className="flex justify-between items-center mb-2">
                      <h4 className="font-medium">Menu Item #{index + 1}</h4>
                      <button
                        type="button"
                        onClick={() => removeMenuItem(index)}
                        className="text-red-500 text-sm"
                      >
                        Remove
                      </button>
                    </div>

                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Name</label>
                        <input
                          type="text"
                          name="name"
                          value={item.name}
                          onChange={(e) => handleMenuItemChange(index, e)}
                          className="input-field"
                          required
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Category</label>
                        <input
                          type="text"
                          name="category"
                          value={item.category}
                          onChange={(e) => handleMenuItemChange(index, e)}
                          className="input-field"
                          required
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Price</label>
                        <input
                          type="number"
                          name="price"
                          value={item.price}
                          onChange={(e) => handleMenuItemChange(index, e)}
                          className="input-field"
                          step="0.01"
                          required
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Description</label>
                        <input
                          type="text"
                          name="description"
                          value={item.description}
                          onChange={(e) => handleMenuItemChange(index, e)}
                          className="input-field"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Image</label>
                        <input
                          type="file"
                          onChange={(e) => handleMenuItemImageChange(index, e)}
                          className="input-field"
                        />
                      </div>
                    </div>
                  </div>
                ))}
              </div>

              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700">
                  Cover Image
                </label>
                <input
                  type="file"
                  onChange={handleCoverImageChange}
                  className="input-field"
                />
              </div>

              <div className="flex justify-end space-x-4">
                <button
                  type="button"
                  onClick={() => setShowModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn-primary"
                  disabled={loading}
                >
                  {loading ? "Creating..." : "Create Restaurant"}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      <h2 className="text-xl font-semibold mb-4">All Restaurants</h2>
      <div className="overflow-x-auto">
        <table className="min-w-full table-auto">
          <thead className="bg-gray-100">
            <tr>
              <th className="px-4 py-2 text-left">Name</th>
              <th className="px-4 py-2 text-left">Description</th>
              <th className="px-4 py-2 text-left">Address</th>
              <th className="px-4 py-2 text-left">Operating Hours</th>
              <th className="px-4 py-2 text-left">Menu Items</th>
              <th className="px-4 py-2 text-left">Actions</th>
            </tr>
          </thead>
          <tbody>
            {restaurants.map((restaurant) => (
              <tr key={restaurant._id} className="border-b">
                <td className="px-4 py-2">{restaurant.name}</td>
                <td className="px-4 py-2">{restaurant.description}</td>
                <td className="px-4 py-2">
                  {restaurant.address?.street}, {restaurant.address?.city}, {restaurant.address?.country}
                </td>
                <td className="px-4 py-2">
                  {restaurant.operatingHours?.from} - {restaurant.operatingHours?.to}
                </td>
                <td className="px-4 py-2">
                  {restaurant.menu?.length || 0} items
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <button
                    onClick={() => {
                    setSelectedRestaurant(restaurant._id);
                    setShowAdminModal(true);
                    }}
                    className="text-blue-600 hover:text-blue-900 mr-4"
                >
                    Manage Admins
                </button>
                <button className="text-yellow-600 hover:text-yellow-900 mr-4">
                    Edit
                </button>
                <button className="text-red-600 hover:text-red-900">
                    Delete
                </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      {showAdminModal && (
                <RestaurantAdminAssignment 
                  restaurantId={selectedRestaurant}
                  onClose={() => setShowAdminModal(false)}
                />
        )}
    </div>
  );
};

export default RestaurantManagement;

/* File: ./client_web\src\pages\admin\Users.jsx */
import { useContext, useEffect, useState } from "react";
import {userServiceApi} from "../../utils/api";
import { AuthContext } from "../../context/AuthContext";

const AdminUsers = () => {
  const { user } = useContext(AuthContext);
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await userServiceApi.get("/api/users");
        setUsers(response.data.data.users);
      } catch (err) {
        setError(err.response?.data?.message || "Failed to fetch users");
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  const toggleUserStatus = async (userId, isActive) => {
    try {
      await userServiceApi.patch(`/api/users/${userId}`, { isActive: !isActive });
      setUsers(
        users.map((user) =>
          user._id === userId ? { ...user, isActive: !isActive } : user
        )
      );
    } catch (err) {
      setError(err.response?.data?.message || "Failed to update user status");
    }
  };

  const filteredUsers = users.filter(
    (user) =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
      user.phone.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (loading) return <div>Loading...</div>;
  if (error) return <div className="text-red-500">{error}</div>;

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Customer Management</h1>

      <div className="mb-6">
        <input
          type="text"
          placeholder="Search users..."
          className="border border-gray-300 rounded-md px-4 py-2 w-full md:w-1/2"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Email
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Phone
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Status
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {filteredUsers.map((user) => (
              <tr key={user._id}>
                <td className="px-6 py-4 whitespace-nowrap">{user.name}</td>
                <td className="px-6 py-4 whitespace-nowrap">{user.email}</td>
                <td className="px-6 py-4 whitespace-nowrap">{user.phone}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span
                    className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                    ${
                      user.isActive
                        ? "bg-green-100 text-green-800"
                        : "bg-red-100 text-red-800"
                    }`}
                  >
                    {user.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <button
                    onClick={() => toggleUserStatus(user._id, user.isActive)}
                    className={`mr-2 px-3 py-1 rounded text-sm font-medium 
                      ${
                        user.isActive
                          ? "bg-red-500 hover:bg-red-600 text-white"
                          : "bg-green-500 hover:bg-green-600 text-white"
                      }`}
                  >
                    {user.isActive ? "Deactivate" : "Activate"}
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default AdminUsers;


/* File: ./client_web\src\pages\Auth\Login.jsx */
import { useState, useContext } from "react";
import { useNavigate } from "react-router-dom";
import { AuthContext } from "../../context/AuthContext";

const Login = () => {
  const [credentials, setCredentials] = useState({
    email: "",
    phone: "",
    password: "",
  });
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  const { login } = useContext(AuthContext);
  const navigate = useNavigate();

  const handleChange = (e) => {
    setCredentials({
      ...credentials,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const { email, phone, password } = credentials;
      const response = await login({ email, phone, password });

      // Redirect based on role
      if (response.user.role === "admin") {
        navigate("/admin");
      } else if (response.user.role === "restaurant_admin") {
        navigate("/restaurant-admin");
      } else {
        navigate("/");
      }
    } catch (err) {
      setError(err.response?.data?.message || "Login failed");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
        </div>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
            {error}
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="rounded-md shadow-sm space-y-4">
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                Email address
              </label>
              <input
                id="email"
                name="email"
                type="email"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={credentials.email}
                onChange={handleChange}
              />
            </div>

            <div className="text-center">OR</div>

            <div>
              <label
                htmlFor="phone"
                className="block text-sm font-medium text-gray-700"
              >
                Phone number
              </label>
              <input
                id="phone"
                name="phone"
                type="tel"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={credentials.phone}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                Password
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                autoComplete="current-password"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={credentials.password}
                onChange={handleChange}
              />
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                name="remember-me"
                type="checkbox"
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              />
              <label
                htmlFor="remember-me"
                className="ml-2 block text-sm text-gray-900"
              >
                Remember me
              </label>
            </div>

            <div className="text-sm">
              <a
                href="#"
                className="font-medium text-blue-600 hover:text-blue-500"
              >
                Forgot your password?
              </a>
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
            >
              {loading ? "Signing in..." : "Sign in"}
            </button>
          </div>
        </form>

        <div className="text-center text-sm">
          <p>
            Need restaurant admin access?{" "}
            <a
              href="/restaurant-admin/request"
              className="font-medium text-blue-600 hover:text-blue-500"
            >
              Request access
            </a>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Login;


/* File: ./client_web\src\pages\Auth\RestaurantAdminRequest.jsx */
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import {userServiceApi, restaurantServiceApi} from "../../utils/api";

const RestaurantAdminRequest = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    phone: "",
    restaurantName: "",
    licenseNumber: "",
    address: "",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);
  const navigate = useNavigate();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      await userServiceApi.post("/api/users/restaurant-admin/request", formData);
      setSuccess(true);
      setTimeout(() => navigate("/login"), 3000);
    } catch (err) {
      setError(err.response?.data?.message || "Failed to submit request");
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-lg shadow-md max-w-md w-full text-center">
          <h2 className="text-2xl font-bold mb-4 text-green-600">
            Request Submitted!
          </h2>
          <p className="mb-6">
            Your restaurant admin request has been submitted for approval.
            You'll be notified once it's processed.
          </p>
          <p>Redirecting to login page...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 bg-white p-8 rounded-lg shadow-md">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Restaurant Admin Request
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Fill out the form to request restaurant admin access
          </p>
        </div>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
            {error}
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="rounded-md shadow-sm space-y-4">
            <div>
              <label
                htmlFor="name"
                className="block text-sm font-medium text-gray-700"
              >
                Full Name
              </label>
              <input
                id="name"
                name="name"
                type="text"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.name}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                Email Address
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.email}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="phone"
                className="block text-sm font-medium text-gray-700"
              >
                Phone Number
              </label>
              <input
                id="phone"
                name="phone"
                type="tel"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.phone}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="restaurantName"
                className="block text-sm font-medium text-gray-700"
              >
                Restaurant Name
              </label>
              <input
                id="restaurantName"
                name="restaurantName"
                type="text"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.restaurantName}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="licenseNumber"
                className="block text-sm font-medium text-gray-700"
              >
                License Number
              </label>
              <input
                id="licenseNumber"
                name="licenseNumber"
                type="text"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.licenseNumber}
                onChange={handleChange}
              />
            </div>

            <div>
              <label
                htmlFor="address"
                className="block text-sm font-medium text-gray-700"
              >
                Restaurant Address
              </label>
              <textarea
                id="address"
                name="address"
                rows="3"
                required
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                value={formData.address}
                onChange={handleChange}
              />
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
            >
              {loading ? "Submitting..." : "Submit Request"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default RestaurantAdminRequest;


/* File: ./client_web\src\pages\restaurant-admin\Dashboard.jsx */
import { useContext, useEffect, useState } from "react";
import { restaurantServiceApi } from "../../utils/api";
import { AuthContext } from "../../context/AuthContext";
import { toast } from "react-toastify";
import { MdEdit, MdDelete, MdAddPhotoAlternate, MdImage } from "react-icons/md";

const RestaurantAdminDashboard = () => {
  const { user } = useContext(AuthContext);
  const [restaurant, setRestaurant] = useState(null);
  const [menuItems, setMenuItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [newMenuItem, setNewMenuItem] = useState({
    name: "",
    description: "",
    price: "",
    category: "main",
    image: null
  });
  const [editMode, setEditMode] = useState(false);
  const [currentItemId, setCurrentItemId] = useState(null);
  const [stats, setStats] = useState({
    totalItems: 0,
    popularCategory: "",
    averagePrice: 0
  });

  // API base URL
  const API_BASE_URL = "http://localhost:3001"; // Adjust this to your actual API base URL

  // Fetch restaurant and menu data
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        
        // Fetch restaurant details
        const restaurantRes = await restaurantServiceApi.get(
          `/api/restaurants/${user.restaurantId}`
        );
        setRestaurant(restaurantRes.data.data);
        
        // Set menu items from restaurant data
        if (restaurantRes.data.data?.menu) {
          setMenuItems(restaurantRes.data.data.menu);
          calculateStats(restaurantRes.data.data.menu);
        }
        
      } catch (err) {
        setError(err.response?.data?.message || "Failed to fetch data");
        toast.error("Failed to load restaurant data");
      } finally {
        setLoading(false);
      }
    };

    if (user?.restaurantId) {
      fetchData();
    }
  }, [user]);

  const calculateStats = (items) => {
    if (!items || items.length === 0) return;
    
    // Calculate total items
    const totalItems = items.length;
    
    // Find popular category
    const categoryCount = {};
    items.forEach(item => {
      categoryCount[item.category] = (categoryCount[item.category] || 0) + 1;
    });
    const popularCategory = Object.keys(categoryCount).reduce((a, b) => 
      categoryCount[a] > categoryCount[b] ? a : b
    );
    
    // Calculate average price
    const totalPrice = items.reduce((sum, item) => sum + item.price, 0);
    const averagePrice = totalPrice / items.length;
    
    setStats({
      totalItems,
      popularCategory,
      averagePrice: parseFloat(averagePrice.toFixed(2))
    });
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewMenuItem(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleImageChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setNewMenuItem(prev => ({
        ...prev,
        image: e.target.files[0]
      }));
    }
  };

  // Add new menu item
  const handleAddMenuItem = async (e) => {
    e.preventDefault();
    try {
      const formData = new FormData();
      
      // Append menu item data
      formData.append("name", newMenuItem.name);
      formData.append("description", newMenuItem.description);
      formData.append("price", newMenuItem.price);
      formData.append("category", newMenuItem.category);
      
      if (newMenuItem.image) {
        formData.append("menuItemImage", newMenuItem.image);
      }

      const response = await restaurantServiceApi.post(
        `/api/restaurants/${user.restaurantId}/menu`,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          }
        }
      );

      if (response.data.status === "success") {
        setMenuItems(prev => [...prev, response.data.data.menuItem]);
        setNewMenuItem({
          name: "",
          description: "",
          price: "",
          category: "main",
          image: null
        });
        toast.success("Menu item added successfully");
      } else {
        throw new Error(response.data.message || "Failed to add menu item");
      }
    } catch (err) {
      console.error("Full error details:", err);
      console.error("Error response data:", err.response?.data);
      toast.error(
        err.response?.data?.message || 
        err.response?.data?.error || 
        err.message || 
        "Failed to add menu item"
      );
    }
  };

  const handleEditMenuItem = (item) => {
    setEditMode(true);
    setCurrentItemId(item._id);
    setNewMenuItem({
      name: item.name,
      description: item.description,
      price: item.price.toString(),
      category: item.category,
      image: null
    });
  };

  // Update menu item
  const handleUpdateMenuItem = async (e) => {
    e.preventDefault();
    try {
      const formData = new FormData();
      
      // Append menu item data
      formData.append("name", newMenuItem.name);
      formData.append("description", newMenuItem.description);
      formData.append("price", newMenuItem.price);
      formData.append("category", newMenuItem.category);
      
      if (newMenuItem.image) {
        formData.append("menuItemImage", newMenuItem.image);
      }

      const response = await restaurantServiceApi.put(
        `/api/restaurants/${user.restaurantId}/menu/${currentItemId}`,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        }
      );
      
      const updatedItems = menuItems.map(item => 
        item._id === currentItemId ? response.data.data.menuItem : item
      );
      setMenuItems(updatedItems);
      calculateStats(updatedItems);
      setEditMode(false);
      setNewMenuItem({
        name: "",
        description: "",
        price: "",
        category: "main",
        image: null
      });
      toast.success("Menu item updated successfully");
    } catch (err) {
      toast.error(err.response?.data?.message || "Failed to update menu item");
    }
  };

  // Delete menu item
  const handleDeleteMenuItem = async (itemId) => {
    if (!window.confirm("Are you sure you want to delete this menu item?")) return;
    
    try {
      await restaurantServiceApi.delete(
        `/api/restaurants/${user.restaurantId}/menu/${itemId}`
      );
      
      const updatedItems = menuItems.filter(item => item._id !== itemId);
      setMenuItems(updatedItems);
      calculateStats(updatedItems);
      toast.success("Menu item deleted successfully");
    } catch (err) {
      toast.error(err.response?.data?.message || "Failed to delete menu item");
    }
  };

  // Function to get the image URL
  const getImageUrl = (imagePath) => {
    if (!imagePath) return null;
    
    // Check if the image path already includes the base URL
    if (imagePath.startsWith('http')) {
      return imagePath;
    }
    
    // Ensure the path doesn't start with a slash if it's already in the image path
    const path = imagePath.startsWith('/') ? imagePath : `/${imagePath}`;
    return `${API_BASE_URL}${path}`;
  };

  if (loading) return <div className="p-6">Loading...</div>;
  if (error) return <div className="p-6 text-red-500">{error}</div>;
  if (!restaurant) return <div className="p-6">No restaurant data found</div>;

  return (
    <div className="p-4 max-w-full">
      <h1 className="text-2xl font-bold mb-6">
        {restaurant.name} - Dashboard
      </h1>

      {/* Statistics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Total Menu Items</h3>
          <p className="text-3xl font-bold">{stats.totalItems}</p>
        </div>
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Popular Category</h3>
          <p className="text-3xl font-bold capitalize">{stats.popularCategory || "N/A"}</p>
        </div>
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold">Average Price</h3>
          <p className="text-3xl font-bold">{`LKR ${stats.averagePrice.toFixed(2)}`}</p>
        </div>
      </div>

      <div className="bg-white p-4 rounded-lg shadow mb-6">
        <h2 className="text-xl font-semibold mb-4">
          {editMode ? "Edit Menu Item" : "Add New Menu Item"}
        </h2>
        <form onSubmit={editMode ? handleUpdateMenuItem : handleAddMenuItem} className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">Name</label>
              <input
                type="text"
                name="name"
                value={newMenuItem.name}
                onChange={handleInputChange}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Category</label>
              <select
                name="category"
                value={newMenuItem.category}
                onChange={handleInputChange}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                required
              >
                <option value="appetizer">Appetizer</option>
                <option value="main">Main Course</option>
                <option value="dessert">Dessert</option>
                <option value="beverage">Beverage</option>
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Price</label>
              <input
                type="number"
                name="price"
                value={newMenuItem.price}
                onChange={handleInputChange}
                step="0.01"
                min="0"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Description</label>
              <input
                type="text"
                name="description"
                value={newMenuItem.description}
                onChange={handleInputChange}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              />
            </div>
            <div className="md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                {editMode ? "Update Image (leave blank to keep current)" : "Image"}
              </label>
              <div className="mt-1 flex items-center">
                <label className="cursor-pointer bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                  <span className="flex items-center">
                    <MdAddPhotoAlternate className="mr-2" />
                    {newMenuItem.image ? newMenuItem.image.name : "Choose File"}
                  </span>
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleImageChange}
                    className="sr-only"
                  />
                </label>
              </div>
            </div>
          </div>
          <div className="flex justify-end space-x-4">
            {editMode && (
              <button
                type="button"
                onClick={() => {
                  setEditMode(false);
                  setNewMenuItem({
                    name: "",
                    description: "",
                    price: "",
                    category: "main",
                    image: null
                  });
                }}
                className="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
              >
                Cancel
              </button>
            )}
            <button
              type="submit"
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
            >
              {editMode ? "Update Item" : "Add Item"}
            </button>
          </div>
        </form>
      </div>

      <div className="bg-white p-4 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">Current Menu</h2>
        {menuItems.length === 0 ? (
          <p className="text-gray-500">No menu items added yet</p>
        ) : (
          <div className="w-full overflow-hidden">
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Image
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Name
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Category
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Price
                    </th>
                    <th className="hidden md:table-cell px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Description
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {menuItems.map((item) => (
                    <tr key={item._id}>
                      <td className="px-4 py-4 whitespace-nowrap">
                        {item.image ? (
                          <img 
                            src={getImageUrl(item.image)} 
                            alt={item.name}
                            className="h-10 w-10 rounded-full object-cover"
                            onError={(e) => {
                              console.log('Image failed to load:', item.image);
                              e.target.onerror = null;
                              e.target.src = ''; // Fallback to placeholder
                              e.target.classList.add('bg-gray-200');
                            }}
                          />
                        ) : (
                          <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center">
                            <MdImage className="text-gray-400 text-xl" />
                          </div>
                        )}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap text-sm">{item.name}</td>
                      <td className="px-4 py-4 whitespace-nowrap text-sm capitalize">{item.category}</td>
                      <td className="px-4 py-4 whitespace-nowrap text-sm">{`LKR ${item.price.toFixed(2)}`}</td>
                      <td className="hidden md:table-cell px-4 py-4 text-sm">
                        <div className="max-w-xs truncate">{item.description || "-"}</div>
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap text-sm">
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEditMenuItem(item)}
                            className="text-blue-600 hover:text-blue-900 flex items-center"
                            title="Edit"
                          >
                            <MdEdit className="mr-1" /> 
                            <span className="hidden sm:inline">Edit</span>
                          </button>
                          <button
                            onClick={() => handleDeleteMenuItem(item._id)}
                            className="text-red-600 hover:text-red-900 flex items-center"
                            title="Delete"
                          >
                            <MdDelete className="mr-1" /> 
                            <span className="hidden sm:inline">Delete</span>
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default RestaurantAdminDashboard;

/* File: ./client_web\src\pages\restaurant-admin\Profile.jsx */
import { useContext, useEffect, useState } from "react";
import { userServiceApi } from "../../utils/api";
import { AuthContext } from "../../context/AuthContext";

const RestaurantAdminProfile = () => {
  const { user } = useContext(AuthContext);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    phone: "",
    address: "",
  });

  useEffect(() => {
    const fetchProfile = async () => {
      try {
        const response = await userServiceApi.get("api/users/me");
        console.log("Full API Response:", response); // Debug log
        
        // Handle nested response structure
        const userData = response.data?.data?.user || response.data?.user || response.data;
        
        if (!userData) {
          throw new Error("User data not found in response");
        }

        console.log("Extracted User Data:", userData); // Debug log
        
        setProfile(userData);
        setFormData({
          name: userData.name || "",
          email: userData.email || "",
          phone: userData.phone || "",
          address: userData.address || "",
        });
      } catch (err) {
        console.error("Profile fetch error:", err);
        setError(err.response?.data?.message || err.message || "Failed to fetch profile");
      } finally {
        setLoading(false);
      }
    };

    fetchProfile();
  }, []);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await userServiceApi.patch("api/users/update-me", formData);
      const updatedUser = response.data?.data?.user || response.data?.user || response.data;
      setProfile(updatedUser);
      setEditMode(false);
    } catch (err) {
      setError(err.response?.data?.message || "Failed to update profile");
    }
  };

  if (loading) return <div className="p-6">Loading profile...</div>;
  if (error) return <div className="p-6 text-red-500">Error: {error}</div>;
  if (!profile) return <div className="p-6">No profile data available</div>;

  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Profile</h1>
        {!editMode && (
          <button
            onClick={() => setEditMode(true)}
            className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
          >
            Edit Profile
          </button>
        )}
      </div>

      {editMode ? (
        <form onSubmit={handleSubmit} className="bg-white p-6 rounded-lg shadow">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Name
              </label>
              <input
                type="text"
                name="name"
                value={formData.name}
                onChange={handleChange}
                className="w-full border border-gray-300 rounded-md px-3 py-2"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Email
              </label>
              <input
                type="email"
                name="email"
                value={formData.email}
                onChange={handleChange}
                className="w-full border border-gray-300 rounded-md px-3 py-2"
                required
                disabled
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Phone
              </label>
              <input
                type="tel"
                name="phone"
                value={formData.phone}
                onChange={handleChange}
                className="w-full border border-gray-300 rounded-md px-3 py-2"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Address
              </label>
              <input
                type="text"
                name="address"
                value={formData.address}
                onChange={handleChange}
                className="w-full border border-gray-300 rounded-md px-3 py-2"
              />
            </div>
          </div>

          <div className="flex space-x-4">
            <button
              type="submit"
              className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded"
            >
              Save Changes
            </button>
            <button
              type="button"
              onClick={() => setEditMode(false)}
              className="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
            >
              Cancel
            </button>
          </div>
        </form>
      ) : (
        <div className="bg-white p-6 rounded-lg shadow">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <h3 className="text-sm font-medium text-gray-500">Name</h3>
              <p className="mt-1 text-sm text-gray-900">{profile.name || "N/A"}</p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-500">Email</h3>
              <p className="mt-1 text-sm text-gray-900">{profile.email || "N/A"}</p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-500">Phone</h3>
              <p className="mt-1 text-sm text-gray-900">{profile.phone || "N/A"}</p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-500">Restaurant</h3>
              <p className="mt-1 text-sm text-gray-900">
                {profile.restaurantId || "N/A"}
              </p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-500">Address</h3>
              <p className="mt-1 text-sm text-gray-900">
                {profile.address || "N/A"}
              </p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-500">Status</h3>
              <p className="mt-1 text-sm text-gray-900">
                <span
                  className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                  ${
                    profile.isActive
                      ? "bg-green-100 text-green-800"
                      : "bg-red-100 text-red-800"
                  }`}
                >
                  {profile.isActive ? "Active" : "Inactive"}
                </span>
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default RestaurantAdminProfile;

/* File: ./client_web\src\utils\api.jsx */
import axios from "axios";

// Create an axios instance for user service (running on port 3000)
const userServiceApi = axios.create({
  baseURL: "http://localhost:3000", // User service running on port 3000
});

// Create an axios instance for restaurant service (running on port 3001)
const restaurantServiceApi = axios.create({
  baseURL: "http://localhost:3001", // Restaurant service running on port 3001
});

// Add a request interceptor to include the token for both services
const addAuthToken = (config) => {
  const token = localStorage.getItem("token");
  console.log("[INTERCEPTOR] Sending token:", token);

  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

// Interceptor for User Service API
userServiceApi.interceptors.request.use(
  addAuthToken,
  (error) => Promise.reject(error)
);

// Interceptor for Restaurant Service API
restaurantServiceApi.interceptors.request.use(
  addAuthToken,
  (error) => Promise.reject(error)
);

// Add a response interceptor (Optional): Can be used to handle token expiration or error logging
const handleResponseError = (error) => {
  if (error.response && error.response.status === 401) {
    console.error("Unauthorized request. Please login again.");
  }
  return Promise.reject(error);
};

// Add response interceptors for both services
userServiceApi.interceptors.response.use(
  (response) => response,
  handleResponseError
);

restaurantServiceApi.interceptors.response.use(
  (response) => response,
  handleResponseError
);

// Export the instances to use for different services
export { userServiceApi, restaurantServiceApi };

/* File: ./delivery_person_app\.dart_tool\dartpad\web_plugin_registrant.dart */
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// ignore_for_file: type=lint

void registerPlugins() {}


/* File: ./delivery_person_app\lib\main.dart */
import 'package:delivery_person_app/screens/SplashScreen.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const DeliveryApp());
}

class DeliveryApp extends StatelessWidget {
  const DeliveryApp({super.key});  // Fixed the class name to start with uppercase

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Delivery App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const SplashScreen(),  // Changed to SplashScreen instead of LoginScreen
    );
  }
}

/* File: ./delivery_person_app\lib\models\DeliveryModel.dart */
// models/delivery.dart
class Delivery {
  final String orderId;
  final String customerName;
  final String restaurant;
  final String address;
  final String time;
  final String price;
  final String status;
  final String distance;
  final String date;

  Delivery({
    required this.orderId,
    required this.customerName,
    required this.restaurant,
    required this.price,
    required this.time,
    this.address = '',
    this.status = '',
    this.distance = '',
    this.date = '',
  });
}

/* File: ./delivery_person_app\lib\models\PaymentModel.dart */
class Payment {
  final String date;
  final double amount;
  final String paymentMethod;
  final String status;

  Payment({
    required this.date,
    required this.amount,
    required this.paymentMethod,
    required this.status,
  });
}

/* File: ./delivery_person_app\lib\models\dummydata.dart */
import 'package:delivery_person_app/models/PaymentModel.dart';
import 'package:delivery_person_app/models/deliveryModel.dart';

class DummyData {
  // Sample data for active deliveries
  static List<Delivery> getActiveDeliveries() {
    return [
      Delivery(
        orderId: '#ORD1234',
        customerName: 'John Smith',
        restaurant: 'Burger King',
        address: '123 Main St, New York',
        time: '12:30 PM',
        price: '\$15.99',
        status: 'Pickup',
        distance: '2.5 km',
      ),
      Delivery(
        orderId: '#ORD5678',
        customerName: 'Emily Johnson',
        restaurant: 'Pizza Hut',
        address: '456 Park Ave, New York',
        time: '1:45 PM',
        price: '\$24.50',
        status: 'On the way',
        distance: '3.8 km',
      ),
    ];
  }

  // Sample data for completed deliveries
  static List<Delivery> getCompletedDeliveries() {
    return [
      Delivery(
        orderId: '#ORD1122',
        customerName: 'Michael Brown',
        restaurant: 'Subway',
        time: '11:20 AM',
        price: '\$12.30',
        date: 'Today',
      ),
      Delivery(
        orderId: '#ORD9876',
        customerName: 'Sarah Wilson',
        restaurant: 'KFC',
        time: '10:05 AM',
        price: '\$18.75',
        date: 'Today',
      ),
      Delivery(
        orderId: '#ORD5432',
        customerName: 'David Lee',
        restaurant: 'Taco Bell',
        time: '7:30 PM',
        price: '\$22.40',
        date: 'Yesterday',
      ),
    ];
  }

  // Sample data for delivery history
  static List<Delivery> getDeliveryHistory() {
    return [
      ...getCompletedDeliveries(),
      Delivery(
        orderId: '#ORD4321',
        customerName: 'Jennifer White',
        restaurant: 'McDonald\'s',
        time: '2:15 PM',
        price: '\$14.85',
        date: '24 Apr 2025',
      ),
      Delivery(
        orderId: '#ORD9870',
        customerName: 'Robert Thomas',
        restaurant: 'Starbucks',
        time: '9:30 AM',
        price: '\$9.50',
        date: '23 Apr 2025',
      ),
      Delivery(
        orderId: '#ORD5544',
        customerName: 'Patricia Moore',
        restaurant: 'Chipotle',
        time: '1:40 PM',
        price: '\$22.75',
        date: '22 Apr 2025',
      ),
    ];
  }

  // Sample data for earnings
  static Map<String, dynamic> getEarningsData() {
    return {
      'today': 78.50,
      'week': 342.75,
      'month': 1250.00,
      'pendingPayment': 78.50,
    };
  }

  // Sample data for payments
  static List<Payment> getRecentPayments() {
    return [
      Payment(
        date: '27 Apr 2025',
        amount: 78.50,
        paymentMethod: 'Direct Deposit',
        status: 'Completed',
      ),
      Payment(
        date: '18 Apr 2025',
        amount: 126.75,
        paymentMethod: 'Direct Deposit',
        status: 'Completed',
      ),
      Payment(
        date: '11 Apr 2025',
        amount: 93.20,
        paymentMethod: 'Direct Deposit',
        status: 'Completed',
      ),
    ];
  }
}

/* File: ./delivery_person_app\lib\models\testmodel.dart */

// utils/widgets.dart
import 'package:flutter/material.dart';

class CommonWidgets {
  static Widget buildEmptyState(String title, String subtitle, IconData icon) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 80,
            color: Colors.grey.shade400,
          ),
          const SizedBox(height: 16),
          Text(
            title,
            style: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            subtitle,
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Colors.grey.shade600,
            ),
          ),
        ],
      ),
    );
  }

  static Widget buildSectionHeader(String title, String actionText, {VoidCallback? onActionPressed}) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        TextButton(
          onPressed: onActionPressed ?? () {},
          child: Text(
            actionText,
            style: TextStyle(
              color: Colors.deepPurple.shade700,
            ),
          ),
        ),
      ],
    );
  }
}

/* File: ./delivery_person_app\lib\screens\DashboardScreen.dart */
// main_screen.dart
import 'package:delivery_person_app/models/dummydata.dart';

import 'package:delivery_person_app/screens/tabs/HomeTab.dart';
import 'package:delivery_person_app/screens/tabs/delivery_history_tab.dart';
import 'package:delivery_person_app/screens/tabs/earnings_tab.dart';
import 'package:delivery_person_app/screens/tabs/profile_tab.dart';
import 'package:flutter/material.dart';


class DashBoard extends StatefulWidget {
  const DashBoard({Key? key}) : super(key: key);

  @override
  State<DashBoard> createState() => _DashBoardState();
}

class _DashBoardState extends State<DashBoard> {
  int _selectedIndex = 0;
  bool _isOnline = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: _buildAppBar(),
      body: _getBody(),
      bottomNavigationBar: _buildBottomNavigationBar(),
    );
  }

  // Get appropriate widgets for each selected tab
 Widget _getBody() {
  switch (_selectedIndex) {
    case 0:
      return HomeTab(
        activeDeliveries: DummyData.getActiveDeliveries(),
        completedDeliveries: DummyData.getCompletedDeliveries(),
        earningsData: DummyData.getEarningsData(),
      );
    case 1:
      return DeliveryHistoryTab(
        completedDeliveries: DummyData.getDeliveryHistory(),
      );
    case 2:
      return EarningsTab(
        earningsData: DummyData.getEarningsData(),
        recentPayments: DummyData.getRecentPayments(),
      );
    case 3:
      return ProfileTab();
    default:
      return HomeTab(
        activeDeliveries: DummyData.getActiveDeliveries(),
        completedDeliveries: DummyData.getCompletedDeliveries(),
        earningsData: DummyData.getEarningsData(),
      );
  }
}
AppBar _buildAppBar() {
  return AppBar(
    elevation: 0,
    title: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Good day, Driver!',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: Colors.black54,
          ),
        ),
        Text(
          _isOnline ? 'You are online' : 'You are offline',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w400,
            color: _isOnline ? Colors.green : Colors.red,
          ),
        ),
      ],
    ),
    actions: [
      Switch(
        value: _isOnline,
        activeColor: Colors.green,
        onChanged: (value) {
          setState(() {
            _isOnline = value;
          });
        },
      ),
      IconButton(
        icon: const Icon(Icons.notifications_outlined),
        onPressed: () {
          // Navigate to notifications screen
        },
        color: Colors.deepPurple,
      ),
    ],
  );
}


  Widget _buildBottomNavigationBar() {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      currentIndex: _selectedIndex,
      onTap: (index) {
        setState(() {
          _selectedIndex = index;
        });
      },
      selectedItemColor: Colors.deepPurple,
      unselectedItemColor: Colors.grey,
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.home_outlined),
          activeIcon: Icon(Icons.home),
          label: 'Home',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.history_outlined),
          activeIcon: Icon(Icons.history),
          label: 'Orders',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.account_balance_wallet_outlined),
          activeIcon: Icon(Icons.account_balance_wallet),
          label: 'Earnings',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.person_outline),
          activeIcon: Icon(Icons.person),
          label: 'Profile',
        ),
      ],
    );
  }
}

/* File: ./delivery_person_app\lib\screens\HomeScreen.dart */
import 'package:flutter/material.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _selectedIndex = 0;
  bool _isOnline = false;

  // Sample data for active deliveries
  final List<Map<String, dynamic>> _activeDeliveries = [
    {
      'orderId': '#ORD1234',
      'customerName': 'John Smith',
      'restaurant': 'Burger King',
      'address': '123 Main St, New York',
      'time': '12:30 PM',
      'price': '\$15.99',
      'status': 'Pickup',
      'distance': '2.5 km',
    },
    {
      'orderId': '#ORD5678',
      'customerName': 'Emily Johnson',
      'restaurant': 'Pizza Hut',
      'address': '456 Park Ave, New York',
      'time': '1:45 PM',
      'price': '\$24.50',
      'status': 'On the way',
      'distance': '3.8 km',
    },
  ];

  // Sample data for earnings
  final Map<String, dynamic> _earningsData = {
    'today': 78.50,
    'week': 342.75,
    'month': 1250.00,
    'pendingPayment': 78.50,
  };

  // Sample data for completed deliveries
  final List<Map<String, dynamic>> _completedDeliveries = [
    {
      'orderId': '#ORD1122',
      'customerName': 'Michael Brown',
      'restaurant': 'Subway',
      'time': '11:20 AM',
      'price': '\$12.30',
      'date': 'Today',
    },
    {
      'orderId': '#ORD9876',
      'customerName': 'Sarah Wilson',
      'restaurant': 'KFC',
      'time': '10:05 AM',
      'price': '\$18.75',
      'date': 'Today',
    },
    {
      'orderId': '#ORD5432',
      'customerName': 'David Lee',
      'restaurant': 'Taco Bell',
      'time': '7:30 PM',
      'price': '\$22.40',
      'date': 'Yesterday',
    },
  ];

  // Get appropriate widgets for each selected tab
  Widget _getBody() {
    switch (_selectedIndex) {
      case 0:
        return _buildHomeTab();
      case 1:
        return _buildDeliveryHistoryTab();
      case 2:
        return _buildEarningsTab();
      case 3:
        return _buildProfileTab();
      default:
        return _buildHomeTab();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: _buildAppBar(),
      body: _getBody(),
      bottomNavigationBar: _buildBottomNavigationBar(),
    );
  }

  AppBar _buildAppBar() {
    return AppBar(
      elevation: 0,
      title: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Good day, Driver!',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: Colors.black54,
            ),
          ),
          Text(
            _isOnline ? 'You are online' : 'You are offline',
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w400,
              color: _isOnline ? Colors.green : Colors.red,
            ),
          ),
        ],
      ),
      actions: [
        Switch(
          value: _isOnline,
          activeColor: Colors.green,
          onChanged: (value) {
            setState(() {
              _isOnline = value;
            });
          },
        ),
        IconButton(
          icon: const Icon(Icons.notifications_outlined),
          onPressed: () {
            // Navigate to notifications screen
          },
          color: Colors.deepPurple,
        ),
      ],
    );
  }

  Widget _buildBottomNavigationBar() {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      currentIndex: _selectedIndex,
      onTap: (index) {
        setState(() {
          _selectedIndex = index;
        });
      },
      selectedItemColor: Colors.deepPurple,
      unselectedItemColor: Colors.grey,
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.home_outlined),
          activeIcon: Icon(Icons.home),
          label: 'Home',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.history_outlined),
          activeIcon: Icon(Icons.history),
          label: 'Orders',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.account_balance_wallet_outlined),
          activeIcon: Icon(Icons.account_balance_wallet),
          label: 'Earnings',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.person_outline),
          activeIcon: Icon(Icons.person),
          label: 'Profile',
        ),
      ],
    );
  }

  Widget _buildHomeTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Summary Cards
          _buildSummaryCards(),
          const SizedBox(height: 24),
          
          // Active Orders
          _buildSectionHeader('Active Orders', _activeDeliveries.length.toString()),
          const SizedBox(height: 12),
          _buildActiveDeliveries(),
          const SizedBox(height: 24),
          
          // Recent Completed Orders
          _buildSectionHeader('Recent Completed Orders', 'See All'),
          const SizedBox(height: 12),
          _buildCompletedDeliveries(),
        ],
      ),
    );
  }

  Widget _buildSummaryCards() {
    return Row(
      children: [
        Expanded(
          child: _buildSummaryCard(
            title: 'Today\'s Earnings',
            value: '\$${_earningsData['today']}',
            icon: Icons.monetization_on_outlined,
            color: Colors.green,
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: _buildSummaryCard(
            title: 'Total Orders',
            value: (_activeDeliveries.length + _completedDeliveries.length).toString(),
            icon: Icons.receipt_long_outlined,
            color: Colors.deepPurple,
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryCard({
    required String title,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color, size: 20),
              const SizedBox(width: 8),
              Text(
                title,
                style: TextStyle(
                  color: Colors.grey.shade600,
                  fontSize: 14,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title, String actionText) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        TextButton(
          onPressed: () {
            // Navigate to details screen
          },
          child: Text(
            actionText,
            style: TextStyle(
              color: Colors.deepPurple.shade700,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActiveDeliveries() {
    if (_activeDeliveries.isEmpty) {
      return _buildEmptyState(
        'No Active Orders',
        'You don\'t have any active deliveries at the moment.',
        Icons.delivery_dining_outlined,
      );
    }

    return Column(
      children: _activeDeliveries.map((order) => _buildActiveOrderCard(order)).toList(),
    );
  }

  Widget _buildActiveOrderCard(Map<String, dynamic> order) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        children: [
          // Order header
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.deepPurple.shade50,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Text(
                      order['orderId'],
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: order['status'] == 'Pickup' ? Colors.blue.shade100 : Colors.orange.shade100,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        order['status'],
                        style: TextStyle(
                          fontSize: 12,
                          color: order['status'] == 'Pickup' ? Colors.blue.shade800 : Colors.orange.shade800,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                Text(
                  order['price'],
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
              ],
            ),
          ),
          // Order details
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                _buildOrderInfoRow('Restaurant', order['restaurant'], Icons.restaurant_outlined),
                const SizedBox(height: 8),
                _buildOrderInfoRow('Customer', order['customerName'], Icons.person_outline),
                const SizedBox(height: 8),
                _buildOrderInfoRow('Address', order['address'], Icons.location_on_outlined),
                const SizedBox(height: 8),
                _buildOrderInfoRow('Time', order['time'], Icons.access_time),
                const SizedBox(height: 8),
                _buildOrderInfoRow('Distance', order['distance'], Icons.directions_bike_outlined),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          // Navigation logic
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurple,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        child: const Text('Navigate'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () {
                          // Call customer
                        },
                        style: OutlinedButton.styleFrom(
                          foregroundColor: Colors.deepPurple,
                          side: BorderSide(color: Colors.deepPurple.shade300),
                          padding: const EdgeInsets.symmetric(vertical: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        child: const Text('Call Customer'),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildOrderInfoRow(String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 18, color: Colors.grey),
        const SizedBox(width: 8),
        Text(
          '$label: ',
          style: TextStyle(
            fontSize: 14,
            color: Colors.grey.shade600,
          ),
        ),
        Expanded(
          child: Text(
            value,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildCompletedDeliveries() {
    if (_completedDeliveries.isEmpty) {
      return _buildEmptyState(
        'No Completed Orders',
        'Your completed orders will appear here.',
        Icons.check_circle_outline,
      );
    }

    return Column(
      children: _completedDeliveries.map((order) => _buildCompletedOrderCard(order)).toList(),
    );
  }

  Widget _buildCompletedOrderCard(Map<String, dynamic> order) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Order icon
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.deepPurple.shade50,
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Icon(
              Icons.check_circle_outline,
              color: Colors.deepPurple,
              size: 24,
            ),
          ),
          const SizedBox(width: 12),
          // Order details
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      order['orderId'],
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      order['price'],
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  order['restaurant'],
                  style: const TextStyle(
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  order['customerName'],
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(
                      Icons.calendar_today_outlined,
                      size: 14,
                      color: Colors.grey.shade600,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      order['date'],
                      style: TextStyle(
                        color: Colors.grey.shade600,
                        fontSize: 12,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Icon(
                      Icons.access_time,
                      size: 14,
                      color: Colors.grey.shade600,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      order['time'],
                      style: TextStyle(
                        color: Colors.grey.shade600,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(String title, String subtitle, IconData icon) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 80,
            color: Colors.grey.shade400,
          ),
          const SizedBox(height: 16),
          Text(
            title,
            style: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            subtitle,
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Colors.grey.shade600,
            ),
          ),
        ],
      ),
    );
  }

  // DELIVERY HISTORY TAB
  Widget _buildDeliveryHistoryTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildDeliveryHistoryFilter(),
          const SizedBox(height: 16),
          _buildDeliveryHistoryList(),
        ],
      ),
    );
  }

  Widget _buildDeliveryHistoryFilter() {
    return Row(
      children: [
        Expanded(
          child: TextField(
            decoration: InputDecoration(
              hintText: 'Search orders...',
              prefixIcon: const Icon(Icons.search),
              filled: true,
              fillColor: Colors.grey.shade100,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide: BorderSide.none,
              ),
              contentPadding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Container(
          decoration: BoxDecoration(
            color: Colors.grey.shade100,
            borderRadius: BorderRadius.circular(12),
          ),
          child: IconButton(
            icon: const Icon(Icons.filter_list),
            onPressed: () {
              // Show filter options
            },
          ),
        ),
      ],
    );
  }

  Widget _buildDeliveryHistoryList() {
    // We'll use the same completed deliveries list but add a few more for history
    final List<Map<String, dynamic>> historyDeliveries = [
      ..._completedDeliveries,
      {
        'orderId': '#ORD4321',
        'customerName': 'Jennifer White',
        'restaurant': 'McDonald\'s',
        'time': '2:15 PM',
        'price': '\$14.85',
        'date': '24 Apr 2025',
      },
      {
        'orderId': '#ORD9870',
        'customerName': 'Robert Thomas',
        'restaurant': 'Starbucks',
        'time': '9:30 AM',
        'price': '\$9.50',
        'date': '23 Apr 2025',
      },
      {
        'orderId': '#ORD5544',
        'customerName': 'Patricia Moore',
        'restaurant': 'Chipotle',
        'time': '1:40 PM',
        'price': '\$22.75',
        'date': '22 Apr 2025',
      },
    ];

    if (historyDeliveries.isEmpty) {
      return _buildEmptyState(
        'No Delivery History',
        'Your delivery history will appear here.',
        Icons.history_outlined,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recent Orders',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        Column(
          children: historyDeliveries.map((order) => _buildCompletedOrderCard(order)).toList(),
        ),
      ],
    );
  }

  // EARNINGS TAB
  Widget _buildEarningsTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildEarningsSummary(),
          const SizedBox(height: 24),
          _buildEarningsTimeFilter(),
          const SizedBox(height: 16),
          _buildEarningsChart(),
          const SizedBox(height: 24),
          _buildRecentPayments(),
        ],
      ),
    );
  }

  Widget _buildEarningsSummary() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.deepPurple.shade50,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Total Earnings',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.deepPurple.shade100,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: const Text(
                  'April 2025',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                    color: Colors.deepPurple,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            '\$${_earningsData['month']}',
            style: const TextStyle(
              fontSize: 32,
              fontWeight: FontWeight.bold,
              color: Colors.deepPurple,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: _buildEarningsInfoBox(
                  'Today',
                  '\$${_earningsData['today']}',
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildEarningsInfoBox(
                  'This Week',
                  '\$${_earningsData['week']}',
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildEarningsInfoBox(
                  'Pending',
                  '\$${_earningsData['pendingPayment']}',
                  isHighlighted: true,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildEarningsInfoBox(String label, String value, {bool isHighlighted = false}) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
      decoration: BoxDecoration(
        color: isHighlighted ? Colors.deepPurple.shade100 : Colors.white,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              color: isHighlighted ? Colors.deepPurple.shade800 : Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: isHighlighted ? Colors.deepPurple.shade800 : Colors.black,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEarningsTimeFilter() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildTimeFilterButton('Day', isSelected: true),
        _buildTimeFilterButton('Week'),
        _buildTimeFilterButton('Month'),
        _buildTimeFilterButton('Year'),
      ],
    );
  }

  Widget _buildTimeFilterButton(String label, {bool isSelected = false}) {
    return InkWell(
      onTap: () {
        // Change the selected time filter
      },
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected ? Colors.deepPurple : Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected ? Colors.deepPurple : Colors.grey.shade300,
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontWeight: FontWeight.w500,
            color: isSelected ? Colors.white : Colors.grey.shade700,
          ),
        ),
      ),
    );
  }

  Widget _buildEarningsChart() {
    // This is a placeholder for the earnings chart
    // In a real app, you'd use a chart library like fl_chart or charts_flutter
    return Container(
      height: 200,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Center(
        child: Text(
          'Earnings Chart',
          style: TextStyle(
            color: Colors.grey.shade600,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildRecentPayments() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recent Payments',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        _buildPaymentCard(
          date: '25 Apr 2025',
          amount: 78.50,
          paymentMethod: 'Direct Deposit',
          status: 'Completed',
        ),
        _buildPaymentCard(
          date: '18 Apr 2025',
          amount: 126.75,
          paymentMethod: 'Direct Deposit',
          status: 'Completed',
        ),
        _buildPaymentCard(
          date: '11 Apr 2025',
          amount: 93.20,
          paymentMethod: 'Direct Deposit',
          status: 'Completed',
        ),
      ],
    );
  }

  Widget _buildPaymentCard({
    required String date,
    required double amount,
    required String paymentMethod,
    required String status,
  }) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Row(
        children: [
          // Payment icon
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.green.shade50,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.payments_outlined,
              color: Colors.green.shade700,
            ),
          ),
          const SizedBox(width: 16),
          // Payment details
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  date,
                  style: const TextStyle(
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  paymentMethod,
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
          // Amount and status
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                '\$$amount',
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.green.shade100,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  status,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.green.shade800,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // PROFILE TAB
  Widget _buildProfileTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          _buildProfileHeader(),
          const SizedBox(height: 24),
          _buildProfileStats(),
          const SizedBox(height: 24),
          _buildProfileOptions(),
        ],
      ),
    );
  }

  Widget _buildProfileHeader() {
  return Column(
    children: [
      const CircleAvatar(
        radius: 50,
        backgroundColor: Colors.deepPurple,
        child: Icon(
          Icons.person,
          size: 50,
          color: Colors.white,
        ),
      ),
      const SizedBox(height: 16),
      const Text(
        'John Driver',
        style: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.bold,
        ),
      ),
      const SizedBox(height: 4),
      Text(
        'ID: #DRV1234',
        style: TextStyle(
          color: Colors.grey.shade600,
          fontSize: 16,
        ),
      ),
      const SizedBox(height: 8),
      Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: Colors.green.shade100,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.star,
              size: 16,
              color: Colors.amber.shade700,
            ),
            const SizedBox(width: 4),
            Text(
              '4.8',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.green.shade800,
              ),
            ),
            Text(
              ' (256 reviews)',
              style: TextStyle(
                fontSize: 12,
                color: Colors.green.shade800,
              ),
            ),
          ],
        ),
      ),
    ],
  );
}

Widget _buildProfileStats() {
  return Container(
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          spreadRadius: 1,
          blurRadius: 6,
          offset: const Offset(0, 3),
        ),
      ],
    ),
    child: Row(
      mainAxisAlignment: MainAxisAlignment.spaceAround,
      children: [
        _buildStatItem('Total Orders', '542'),
        _buildDivider(),
        _buildStatItem('Cancelled', '12'),
        _buildDivider(),
        _buildStatItem('Experience', '8 months'),
      ],
    ),
  );
}

Widget _buildDivider() {
  return Container(
    height: 40,
    width: 1,
    color: Colors.grey.shade300,
  );
}

Widget _buildStatItem(String label, String value) {
  return Column(
    children: [
      Text(
        value,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
        ),
      ),
      const SizedBox(height: 4),
      Text(
        label,
        style: TextStyle(
          fontSize: 14,
          color: Colors.grey.shade600,
        ),
      ),
    ],
  );
}

Widget _buildProfileOptions() {
  return Column(
    children: [
      _buildProfileOptionItem(
        icon: Icons.account_circle_outlined,
        title: 'Personal Information',
        onTap: () {
          // Navigate to personal information screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.directions_bike_outlined,
        title: 'Vehicle Information',
        onTap: () {
          // Navigate to vehicle information screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.work_outline,
        title: 'Work Schedule',
        onTap: () {
          // Navigate to work schedule screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.chat_outlined,
        title: 'Support',
        onTap: () {
          // Navigate to support screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.stars_outlined,
        title: 'My Reviews',
        onTap: () {
          // Navigate to reviews screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.notifications_outlined,
        title: 'Notification Settings',
        onTap: () {
          // Navigate to notification settings screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.privacy_tip_outlined,
        title: 'Privacy Policy',
        onTap: () {
          // Navigate to privacy policy screen
        },
      ),
      _buildProfileOptionItem(
        icon: Icons.help_outline,
        title: 'Help & FAQ',
        onTap: () {
          // Navigate to help screen
        },
      ),
      const SizedBox(height: 16),
      OutlinedButton.icon(
        onPressed: () {
          // Logout logic
        },
        icon: Icon(
          Icons.logout,
          color: Colors.red.shade700,
        ),
        label: Text(
          'Logout',
          style: TextStyle(
            color: Colors.red.shade700,
            fontWeight: FontWeight.w500,
          ),
        ),
        style: OutlinedButton.styleFrom(
          side: BorderSide(color: Colors.red.shade300),
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      const SizedBox(height: 24),
      Text(
        'App Version 1.0.0',
        style: TextStyle(
          color: Colors.grey.shade600,
          fontSize: 12,
        ),
      ),
      const SizedBox(height: 8),
    ],
  );
}

Widget _buildProfileOptionItem({
  required IconData icon,
  required String title,
  required VoidCallback onTap,
}) {
  return InkWell(
    onTap: onTap,
    child: Container(
      padding: const EdgeInsets.symmetric(vertical: 16),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(
            color: Colors.grey.shade200,
            width: 1,
          ),
        ),
      ),
      child: Row(
        children: [
          Icon(
            icon,
            color: Colors.deepPurple,
            size: 20,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Text(
              title,
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          const Icon(
            Icons.arrow_forward_ios,
            color: Colors.grey,
            size: 16,
          ),
        ],
      ),
    ),
  );
}
}


/* File: ./delivery_person_app\lib\screens\SignupScreen.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({Key? key}) : super(key: key);

  @override
  State<SignupScreen> createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _fullNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _licenseNumberController = TextEditingController();
  final _vehicleInfoController = TextEditingController();
  final _vehicleRegistrationController = TextEditingController();

  String _selectedVehicleType = 'Car';
  final List<String> _vehicleTypes = ['Car', 'Motorcycle', 'Bicycle', 'Scooter', 'Van'];
  bool _agreeToTerms = false;
  bool _isPasswordVisible = false;
  bool _isConfirmPasswordVisible = false;

  @override
  void dispose() {
    _fullNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _licenseNumberController.dispose();
    _vehicleInfoController.dispose();
    _vehicleRegistrationController.dispose();
    super.dispose();
  }

  void _submitForm() {
    if (_formKey.currentState!.validate() && _agreeToTerms) {
      // Registration logic would go here
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Registration successful! Verification pending.'),
          backgroundColor: Colors.green,
        ),
      );
    } else if (!_agreeToTerms) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please agree to terms and conditions'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.black),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Text(
          'Create Driver Account',
          style: TextStyle(color: Colors.black, fontWeight: FontWeight.bold),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  'Personal Information',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.deepPurple.shade800,
                  ),
                ),
                const SizedBox(height: 16),
                
                // Full Name
                TextFormField(
                  controller: _fullNameController,
                  decoration: const InputDecoration(
                    labelText: 'Full Name',
                    prefixIcon: Icon(Icons.person_outline),
                    hintText: 'Enter your full name',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Please enter your full name';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Email
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    labelText: 'Email',
                    prefixIcon: Icon(Icons.email_outlined),
                    hintText: 'your.email@example.com',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your email';
                    }
                    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
                    if (!emailRegex.hasMatch(value)) {
                      return 'Please enter a valid email address';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Phone Number
                TextFormField(
                  controller: _phoneController,
                  keyboardType: TextInputType.phone,
                  inputFormatters: [
                    FilteringTextInputFormatter.digitsOnly,
                    LengthLimitingTextInputFormatter(10),
                  ],
                  decoration: const InputDecoration(
                    labelText: 'Phone Number',
                    prefixIcon: Icon(Icons.phone_outlined),
                    hintText: 'Enter your phone number',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your phone number';
                    }
                    if (value.length < 10) {
                      return 'Please enter a valid phone number';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Password
                TextFormField(
                  controller: _passwordController,
                  obscureText: !_isPasswordVisible,
                  decoration: InputDecoration(
                    labelText: 'Password',
                    prefixIcon: const Icon(Icons.lock_outline),
                    hintText: 'Create a password',
                    filled: true,
                    fillColor: const Color(0xFFF5F5F5),
                    border: const OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _isPasswordVisible
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() {
                          _isPasswordVisible = !_isPasswordVisible;
                        });
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a password';
                    }
                    if (value.length < 8) {
                      return 'Password must be at least 8 characters';
                    }
                    // Check for at least one uppercase letter
                    if (!value.contains(RegExp(r'[A-Z]'))) {
                      return 'Password must contain at least one uppercase letter';
                    }
                    // Check for at least one number
                    if (!value.contains(RegExp(r'[0-9]'))) {
                      return 'Password must contain at least one number';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Confirm Password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: !_isConfirmPasswordVisible,
                  decoration: InputDecoration(
                    labelText: 'Confirm Password',
                    prefixIcon: const Icon(Icons.lock_outline),
                    hintText: 'Confirm your password',
                    filled: true,
                    fillColor: const Color(0xFFF5F5F5),
                    border: const OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _isConfirmPasswordVisible
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() {
                          _isConfirmPasswordVisible = !_isConfirmPasswordVisible;
                        });
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please confirm your password';
                    }
                    if (value != _passwordController.text) {
                      return 'Passwords do not match';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),
                
                // Driver Information
                Text(
                  'Driver Information',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.deepPurple.shade800,
                  ),
                ),
                const SizedBox(height: 16),
                
                // Driver's License
                TextFormField(
                  controller: _licenseNumberController,
                  decoration: const InputDecoration(
                    labelText: 'Driver\'s License Number',
                    prefixIcon: Icon(Icons.badge_outlined),
                    hintText: 'Enter your license number',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your license number';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Vehicle Type Dropdown
                DropdownButtonFormField<String>(
                  value: _selectedVehicleType,
                  decoration: const InputDecoration(
                    labelText: 'Vehicle Type',
                    prefixIcon: Icon(Icons.directions_car_outlined),
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  items: _vehicleTypes.map((String type) {
                    return DropdownMenuItem<String>(
                      value: type,
                      child: Text(type),
                    );
                  }).toList(),
                  onChanged: (String? newValue) {
                    setState(() {
                      _selectedVehicleType = newValue!;
                    });
                  },
                ),
                const SizedBox(height: 16),
                
                // Vehicle Information
                TextFormField(
                  controller: _vehicleInfoController,
                  decoration: const InputDecoration(
                    labelText: 'Vehicle Make/Model/Year',
                    prefixIcon: Icon(Icons.car_repair_outlined),
                    hintText: 'e.g., Toyota Corolla 2020',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter vehicle information';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // Vehicle Registration
                TextFormField(
                  controller: _vehicleRegistrationController,
                  decoration: const InputDecoration(
                    labelText: 'Vehicle Registration Number',
                    prefixIcon: Icon(Icons.article_outlined),
                    hintText: 'Enter vehicle registration number',
                    filled: true,
                    fillColor: Color(0xFFF5F5F5),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.all(Radius.circular(12)),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter vehicle registration number';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),
                
                // Upload Documents Section
                Text(
                  'Upload Documents',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.deepPurple.shade800,
                  ),
                ),
                const SizedBox(height: 16),
                
                // Document Upload Buttons
                Row(
                  children: [
                    Expanded(
                      child: _buildDocumentUploadButton(
                        'License Photo', 
                        Icons.badge_outlined,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: _buildDocumentUploadButton(
                        'Vehicle Registration', 
                        Icons.description_outlined,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: _buildDocumentUploadButton(
                        'Profile Photo',
                        Icons.person_outline,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: _buildDocumentUploadButton(
                        'Insurance Document',
                        Icons.policy_outlined,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                
                // Terms and Conditions
                Row(
                  children: [
                    Checkbox(
                      value: _agreeToTerms,
                      onChanged: (bool? value) {
                        setState(() {
                          _agreeToTerms = value!;
                        });
                      },
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4),
                      ),
                    ),
                    Expanded(
                      child: GestureDetector(
                        onTap: () {
                          setState(() {
                            _agreeToTerms = !_agreeToTerms;
                          });
                        },
                        child: Text.rich(
                          TextSpan(
                            text: 'I agree to the ',
                            style: TextStyle(color: Colors.grey.shade700),
                            children: [
                              TextSpan(
                                text: 'Terms & Conditions',
                                style: TextStyle(
                                  color: Colors.deepPurple.shade700,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              const TextSpan(
                                text: ' and ',
                              ),
                              TextSpan(
                                text: 'Privacy Policy',
                                style: TextStyle(
                                  color: Colors.deepPurple.shade700,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                
                // Submit Button
                ElevatedButton(
                  onPressed: _submitForm,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  child: const Text(
                    'Create Account',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  ),
                ),
                const SizedBox(height: 16),
                
                // Login Option
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      'Already have an account?',
                      style: TextStyle(color: Colors.grey.shade600),
                    ),
                    TextButton(
                      onPressed: () {
                        Navigator.of(context).pop();
                      },
                      child: Text(
                        'Sign In',
                        style: TextStyle(
                          color: Colors.deepPurple.shade700,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDocumentUploadButton(String title, IconData icon) {
    return OutlinedButton(
      onPressed: () {
        // Document upload logic would go here
      },
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(vertical: 16),
        side: BorderSide(color: Colors.deepPurple.shade300),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      child: Column(
        children: [
          Icon(
            icon,
            color: Colors.deepPurple,
          ),
          const SizedBox(height: 8),
          Text(
            title,
            style: TextStyle(
              color: Colors.deepPurple.shade700,
            ),
          ),
        ],
      ),
    );
  }
}

/* File: ./delivery_person_app\lib\screens\SplashScreen.dart */
import 'package:flutter/material.dart';
import 'package:delivery_person_app/screens/login_screen.dart';
import 'dart:async';

class SplashScreen extends StatefulWidget {
  const SplashScreen({Key? key}) : super(key: key);

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    
    // Create animation controller
    _animationController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    );
    
    // Create a curved animation for a nice effect
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
    
    // Start animation
    _animationController.forward();
    
    // Navigate to login screen after a delay
    Timer(const Duration(seconds: 3), () {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => const LoginScreen()),
      );
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Center(
        child: FadeTransition(
          opacity: _animation,
          child: ScaleTransition(
            scale: _animation,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                SizedBox(
                  height: 250,
                  width: 250,
                  child: Image.asset(
                    'lib/assets/images/logo.png', // Replace with your logo path
                    fit: BoxFit.contain,
                  ),
                ),
                const SizedBox(height: 24),
                // Text(
                //   'TastyTrail Delivery',
                //   style: TextStyle(
                //     fontSize: 24,
                //     fontWeight: FontWeight.bold,
                //     color: Colors.deepPurple,
                //   ),
                // ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/* File: ./delivery_person_app\lib\screens\login_screen.dart */
import 'package:delivery_person_app/screens/DashboardScreen.dart';
import 'package:delivery_person_app/screens/HomeScreen.dart';
import 'package:delivery_person_app/screens/SignupScreen.dart';
import 'package:flutter/material.dart';




class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isPasswordVisible = false;
  bool _rememberMe = false;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _submitForm() {
    if (_formKey.currentState!.validate()) {
      // Login logic would go here 
      //navigate to home
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => const DashBoard()),
      );
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Login successful!'),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Logo and welcome text
                _buildHeader(),
                const SizedBox(height: 40),
                
                // Form
                Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      // Email field
                      _buildEmailField(),
                      const SizedBox(height: 16),
                      
                      // Password field
                      _buildPasswordField(),
                      const SizedBox(height: 8),
                      
                      // Remember me and Forgot password
                      _buildRememberForgotRow(),
                      const SizedBox(height: 24),
                      
                      // Login button
                      _buildLoginButton(),
                      const SizedBox(height: 16),
                      
                      // Or continue with
                      _buildDivider(),
                      const SizedBox(height: 16),
                      
                      // Social login options
                      _buildSocialLoginRow(),
                      const SizedBox(height: 24),
                      
                      // Sign up option
                      _buildSignUpOption(),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Column(
      children: [
        Container(
          height: 70,
          width: 70,
          decoration: BoxDecoration(
            color: Colors.blue.shade50,
            borderRadius: BorderRadius.circular(20),
          ),
          child: Icon(
            Icons.lock_outline_rounded,
            size: 40,
            color: Colors.blue.shade800,
          ),
        ),
        const SizedBox(height: 24),
        const Text(
          'Welcome back!',
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 28,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Please sign in to your account',
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 16,
            color: Colors.grey.shade600,
          ),
        ),
      ],
    );
  }

  Widget _buildEmailField() {
    return TextFormField(
      controller: _emailController,
      keyboardType: TextInputType.emailAddress,
      decoration: const InputDecoration(
        labelText: 'Email',
        prefixIcon: Icon(Icons.email_outlined),
        hintText: 'your.email@example.com',
      ),
      validator: (value) {
        if (value == null || value.isEmpty) {
          return 'Please enter your email';
        }
        
        final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
        if (!emailRegex.hasMatch(value)) {
          return 'Please enter a valid email address';
        }
        
        return null;
      },
    );
  }

  Widget _buildPasswordField() {
    return TextFormField(
      controller: _passwordController,
      obscureText: !_isPasswordVisible,
      decoration: InputDecoration(
        labelText: 'Password',
        prefixIcon: const Icon(Icons.lock_outline),
        hintText: 'Enter your password',
        suffixIcon: IconButton(
          icon: Icon(
            _isPasswordVisible ? Icons.visibility_outlined : Icons.visibility_off_outlined,
          ),
          onPressed: () {
            setState(() {
              _isPasswordVisible = !_isPasswordVisible;
            });
          },
        ),
      ),
      validator: (value) {
        if (value == null || value.isEmpty) {
          return 'Please enter your password';
        }
        if (value.length < 6) {
          return 'Password must be at least 6 characters';
        }
        return null;
      },
    );
  }

  Widget _buildRememberForgotRow() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            SizedBox(
              height: 24,
              width: 24,
              child: Checkbox(
                value: _rememberMe,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                onChanged: (value) {
                  setState(() {
                    _rememberMe = value!;
                  });
                },
              ),
            ),
            const SizedBox(width: 8),
            Text(
              'Remember me',
              style: TextStyle(color: Colors.grey.shade700),
            ),
          ],
        ),
        TextButton(
          onPressed: () {
            // Handle forgot password
          },
          child: Text(
            'Forgot password?',
            style: TextStyle(
              color: Colors.blue.shade700,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildLoginButton() {
    return ElevatedButton(
      onPressed: _submitForm,
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.blue.shade800,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(vertical: 16),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      child: const Text(
        'Sign In',
        style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
      ),
    );
  }

  Widget _buildDivider() {
    return Row(
      children: [
        Expanded(
          child: Divider(
            color: Colors.grey.shade300,
            thickness: 1,
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(
            'Or continue with',
            style: TextStyle(color: Colors.grey.shade600),
          ),
        ),
        Expanded(
          child: Divider(
            color: Colors.grey.shade300,
            thickness: 1,
          ),
        ),
      ],
    );
  }

  Widget _buildSocialLoginRow() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        _buildSocialButton(Icons.g_mobiledata_rounded, 'Google'),
        const SizedBox(width: 16),
        _buildSocialButton(Icons.apple, 'Apple'),
        const SizedBox(width: 16),
        _buildSocialButton(Icons.facebook, 'Facebook'),
      ],
    );
  }

  Widget _buildSocialButton(IconData icon, String label) {
    return InkWell(
      onTap: () {
        // Handle social login
      },
      borderRadius: BorderRadius.circular(12),
      child: Container(
        width: 60,
        height: 60,
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey.shade300),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(
          icon,
          size: 30,
          color: Colors.grey.shade800,
        ),
      ),
    );
  }

  Widget _buildSignUpOption() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          'Don\'t have an account?',
          style: TextStyle(color: Colors.grey.shade600),
        ),
        TextButton(
          onPressed: () {
             Navigator.of(context).push(
      MaterialPageRoute(builder: (_) => const SignupScreen()),
    );
          },
          child: Text(
            'Sign Up',
            style: TextStyle(
              color: Colors.blue.shade700,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    );
  }
}

/* File: ./delivery_person_app\lib\screens\tabs\HomeTab.dart */
import 'package:delivery_person_app/models/deliveryModel.dart';
import 'package:flutter/material.dart';

class HomeTab extends StatelessWidget {
  final List<Delivery> activeDeliveries;
final List<Delivery> completedDeliveries;
final Map<String, dynamic> earningsData;


  const HomeTab({
    Key? key,
    required this.activeDeliveries,
    required this.completedDeliveries,
    required this.earningsData,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSummaryCards(),
          const SizedBox(height: 24),
          _buildSectionHeader('Active Orders', activeDeliveries.length.toString()),
          const SizedBox(height: 12),
          _buildActiveDeliveries(),

          const SizedBox(height: 24),
          _buildSectionHeader('Recent Completed Orders', 'See All'),
          const SizedBox(height: 12),
          _buildCompletedDeliveries(),
        ],
      ),
    );
  }

Widget _buildSummaryCards() {
    return Row(
      children: [
        Expanded(
          child: _buildSummaryCard(
            title: 'Today\'s Earnings',
             value: '\$${earningsData['today']}',
            icon: Icons.monetization_on_outlined,
            color: Colors.green,
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: _buildSummaryCard(
            title: 'Total Orders',
            value: (activeDeliveries.length + completedDeliveries.length).toString(),
            icon: Icons.receipt_long_outlined,
            color: Colors.deepPurple,
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryCard({
    required String title,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color, size: 20),
              const SizedBox(width: 8),
              Text(
                title,
                style: TextStyle(
                  color: Colors.grey.shade600,
                  fontSize: 14,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

   Widget _buildSectionHeader(String title, String actionText) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        TextButton(
          onPressed: () {
            // Navigate to details screen
          },
          child: Text(
            actionText,
            style: TextStyle(
              color: Colors.deepPurple.shade700,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActiveDeliveries() {
    if (activeDeliveries.isEmpty) {
      return _buildEmptyState('No Active Orders', 'You don\'t have any active deliveries.', Icons.delivery_dining_outlined);
    }
    return Column(
      children: activeDeliveries.map((order) => _buildOrderCard(order, isActive: true)).toList(),

    );
  }

  Widget _buildCompletedDeliveries() {
    if (completedDeliveries.isEmpty) {
      return _buildEmptyState('No Completed Orders', 'Your completed orders will appear here.', Icons.check_circle_outline);
    }
    return Column(
      children: completedDeliveries.map((order) => _buildCompletedOrderCard(order)).toList(),

    );
  }
  Widget _buildCompletedOrderCard(Delivery order) {
  return Container(
    margin: const EdgeInsets.only(bottom: 12),
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          spreadRadius: 1,
          blurRadius: 6,
          offset: const Offset(0, 3),
        ),
      ],
    ),
    child: Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Order icon
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Colors.deepPurple.shade50,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(
            Icons.check_circle_outline,
            color: Colors.deepPurple,
            size: 24,
          ),
        ),
        const SizedBox(width: 12),
        // Order details
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    order.orderId ?? '',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    order.price ?? '',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Text(
                order.restaurant ?? '',
                style: const TextStyle(
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                order.customerName ?? '',
                style: TextStyle(
                  color: Colors.grey.shade600,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 4),
              Row(
                children: [
                  Icon(
                    Icons.calendar_today_outlined,
                    size: 14,
                    color: Colors.grey.shade600,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    order.date ?? '',
                    style: TextStyle(
                      color: Colors.grey.shade600,
                      fontSize: 12,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Icon(
                    Icons.access_time,
                    size: 14,
                    color: Colors.grey.shade600,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    order.time ?? '',
                    style: TextStyle(
                      color: Colors.grey.shade600,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    ),
  );
}


 Widget _buildOrderCard(Delivery order, {bool isActive = false}) {
  return Container(
    margin: const EdgeInsets.only(bottom: 16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          spreadRadius: 1,
          blurRadius: 6,
          offset: const Offset(0, 3),
        ),
      ],
    ),
    child: Column(
      children: [
        // Order header
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.deepPurple.shade50,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Row(
                children: [
                  Text(
                    order.orderId ?? '',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(width: 8),
                  if (order.status != null) 
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: order.status == 'Pickup' ? Colors.blue.shade100 : Colors.orange.shade100,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        order.status ?? '',
                        style: TextStyle(
                          fontSize: 12,
                          color: order.status == 'Pickup' ? Colors.blue.shade800 : Colors.orange.shade800,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                ],
              ),
              Text(
                order.price ?? '',
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
        ),
        // Order details
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              _buildOrderInfoRow('Restaurant', order.restaurant ?? '', Icons.restaurant_outlined),
              const SizedBox(height: 8),
              _buildOrderInfoRow('Customer', order.customerName ?? '', Icons.person_outline),
              const SizedBox(height: 8),
              _buildOrderInfoRow('Address', order.address ?? '', Icons.location_on_outlined),
              const SizedBox(height: 8),
              _buildOrderInfoRow('Time', order.time ?? '', Icons.access_time),
              const SizedBox(height: 8),
              _buildOrderInfoRow('Distance', order.distance ?? '', Icons.directions_bike_outlined),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton(
                      onPressed: () {
                        // Navigation logic
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurple,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      child: const Text('Navigate'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        // Call customer logic
                      },
                      style: OutlinedButton.styleFrom(
                        foregroundColor: Colors.deepPurple,
                        side: BorderSide(color: Colors.deepPurple.shade300),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      child: const Text('Call Customer'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    ),
  );
}

  Widget _buildOrderInfoRow(String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 18, color: Colors.grey),
        const SizedBox(width: 8),
        Text(
          '$label: ',
          style: TextStyle(
            fontSize: 14,
            color: Colors.grey.shade600,
          ),
        ),
        Expanded(
          child: Text(
            value,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState(String title, String subtitle, IconData icon) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          children: [
            Icon(icon, size: 80, color: Colors.grey.shade400),
            const SizedBox(height: 16),
            Text(title, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text(subtitle, style: TextStyle(color: Colors.grey.shade600)),
          ],
        ),
      ),
    );
  }
}


/* File: ./delivery_person_app\lib\screens\tabs\delivery_history_tab.dart */
import 'package:flutter/material.dart';
import 'package:delivery_person_app/models/deliveryModel.dart';

class DeliveryHistoryTab extends StatelessWidget {
  final List<Delivery> completedDeliveries;

  const DeliveryHistoryTab({
    Key? key,
    required this.completedDeliveries,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSearchAndFilter(),
          const SizedBox(height: 16),
          _buildDeliveryList(),
        ],
      ),
    );
  }

  Widget _buildSearchAndFilter() {
    return Row(
      children: [
        Expanded(
          child: TextField(
            decoration: InputDecoration(
              hintText: 'Search orders...',
              prefixIcon: const Icon(Icons.search),
              filled: true,
              fillColor: Colors.grey.shade100,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide: BorderSide.none,
              ),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Container(
          decoration: BoxDecoration(
            color: Colors.grey.shade100,
            borderRadius: BorderRadius.circular(12),
          ),
          child: IconButton(
            icon: const Icon(Icons.filter_list),
            onPressed: () {},
          ),
        ),
      ],
    );
  }

  Widget _buildDeliveryList() {
    if (completedDeliveries.isEmpty) {
      return _buildEmptyState('No Delivery History', 'Your completed orders will appear here.', Icons.history_outlined);
    }

    return Column(
      children: completedDeliveries.map((delivery) => _buildDeliveryCard(delivery)).toList(),
    );
  }

  Widget _buildDeliveryCard(Delivery delivery) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [BoxShadow(color: Colors.grey.withOpacity(0.1), blurRadius: 6, spreadRadius: 1)],
      ),
      child: Row(
        children: [
          const Icon(Icons.check_circle_outline, color: Colors.deepPurple),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(delivery.orderId ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 4),
                Text(delivery.restaurant ?? ''),
                const SizedBox(height: 4),
                Text(delivery.customerName ?? '', style: TextStyle(color: Colors.grey.shade600)),
                const SizedBox(height: 4),
                Text('${delivery.date ?? ''} - ${delivery.time ?? ''}', style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(String title, String subtitle, IconData icon) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          children: [
            Icon(icon, size: 80, color: Colors.grey.shade400),
            const SizedBox(height: 16),
            Text(title, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text(subtitle, style: TextStyle(color: Colors.grey.shade600)),
          ],
        ),
      ),
    );
  }
}


/* File: ./delivery_person_app\lib\screens\tabs\earnings_tab.dart */
import 'package:flutter/material.dart';
import 'package:delivery_person_app/models/PaymentModel.dart';

class EarningsTab extends StatelessWidget {
  final Map<String, dynamic> earningsData;
  final List<Payment> recentPayments;

  const EarningsTab({
    Key? key,
    required this.earningsData,
    required this.recentPayments,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildEarningsSummary(),
          const SizedBox(height: 24),
          _buildEarningsTimeFilter(),
          const SizedBox(height: 16),
          _buildEarningsChart(),
          const SizedBox(height: 24),
          _buildRecentPayments(),
        ],
      ),
    );
  }

  Widget _buildEarningsSummary() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.deepPurple.shade50,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Total Earnings',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.deepPurple.shade100,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: const Text(
                  'April 2025', // You can make this dynamic if needed
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                    color: Colors.deepPurple,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            '\$${earningsData['month']}',
            style: const TextStyle(
              fontSize: 32,
              fontWeight: FontWeight.bold,
              color: Colors.deepPurple,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: _buildEarningsInfoBox('Today', '\$${earningsData['today']}'),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildEarningsInfoBox('This Week', '\$${earningsData['week']}'),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildEarningsInfoBox('Pending', '\$${earningsData['pendingPayment']}', isHighlighted: true),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildEarningsInfoBox(String label, String value, {bool isHighlighted = false}) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
      decoration: BoxDecoration(
        color: isHighlighted ? Colors.deepPurple.shade100 : Colors.white,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              color: isHighlighted ? Colors.deepPurple.shade800 : Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: isHighlighted ? Colors.deepPurple.shade800 : Colors.black,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEarningsTimeFilter() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildTimeFilterButton('Day', isSelected: true),
        _buildTimeFilterButton('Week'),
        _buildTimeFilterButton('Month'),
        _buildTimeFilterButton('Year'),
      ],
    );
  }

  Widget _buildTimeFilterButton(String label, {bool isSelected = false}) {
    return InkWell(
      onTap: () {
        // Add onTap logic if you want dynamic filtering
      },
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected ? Colors.deepPurple : Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected ? Colors.deepPurple : Colors.grey.shade300,
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontWeight: FontWeight.w500,
            color: isSelected ? Colors.white : Colors.grey.shade700,
          ),
        ),
      ),
    );
  }

  Widget _buildEarningsChart() {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Center(
        child: Text(
          'Earnings Chart', // Later you can replace with fl_chart or charts_flutter
          style: TextStyle(
            color: Colors.grey.shade600,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildRecentPayments() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recent Payments',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        Column(
          children: recentPayments.map((payment) => _buildPaymentCard(payment)).toList(),
        ),
      ],
    );
  }

  Widget _buildPaymentCard(Payment payment) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Row(
        children: [
          // Payment icon
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.green.shade50,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.payments_outlined,
              color: Colors.green.shade700,
            ),
          ),
          const SizedBox(width: 16),
          // Payment details
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  payment.date,
                  style: const TextStyle(
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  payment.paymentMethod,
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
          // Amount and status
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                '\$${payment.amount}',
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.green.shade100,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  payment.status,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.green.shade800,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}


/* File: ./delivery_person_app\lib\screens\tabs\profile_tab.dart */
import 'package:flutter/material.dart';

class ProfileTab extends StatelessWidget {
  const ProfileTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          _buildProfileHeader(),
          const SizedBox(height: 24),
          _buildProfileStats(),
          const SizedBox(height: 24),
          _buildProfileOptions(context),
        ],
      ),
    );
  }

  Widget _buildProfileHeader() {
    return Column(
      children: [
        const CircleAvatar(
          radius: 50,
          backgroundColor: Colors.deepPurple,
          child: Icon(Icons.person, size: 50, color: Colors.white),
        ),
        const SizedBox(height: 16),
        const Text(
          'John Driver',
          style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 4),
        Text(
          'ID: #DRV1234',
          style: TextStyle(color: Colors.grey.shade600, fontSize: 16),
        ),
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          decoration: BoxDecoration(
            color: Colors.green.shade100,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.star, size: 16, color: Colors.amber.shade700),
              const SizedBox(width: 4),
              Text(
                '4.8',
                style: TextStyle(fontWeight: FontWeight.bold, color: Colors.green.shade800),
              ),
              Text(
                ' (256 reviews)',
                style: TextStyle(fontSize: 12, color: Colors.green.shade800),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildProfileStats() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
          ),
        ],
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          _buildStatItem('Total Orders', '542'),
          _buildDivider(),
          _buildStatItem('Cancelled', '12'),
          _buildDivider(),
          _buildStatItem('Experience', '8 months'),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyle(fontSize: 14, color: Colors.grey.shade600),
        ),
      ],
    );
  }

  Widget _buildDivider() {
    return Container(
      height: 40,
      width: 1,
      color: Colors.grey.shade300,
    );
  }

  Widget _buildProfileOptions(BuildContext context) {
    return Column(
      children: [
        _buildProfileOptionItem(
          icon: Icons.account_circle_outlined,
          title: 'Personal Information',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.directions_bike_outlined,
          title: 'Vehicle Information',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.work_outline,
          title: 'Work Schedule',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.chat_outlined,
          title: 'Support',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.stars_outlined,
          title: 'My Reviews',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.notifications_outlined,
          title: 'Notification Settings',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.privacy_tip_outlined,
          title: 'Privacy Policy',
          onTap: () {},
        ),
        _buildProfileOptionItem(
          icon: Icons.help_outline,
          title: 'Help & FAQ',
          onTap: () {},
        ),
        const SizedBox(height: 16),
        OutlinedButton.icon(
          onPressed: () {
            // TODO: Logout action
          },
          icon: Icon(Icons.logout, color: Colors.red.shade700),
          label: Text(
            'Logout',
            style: TextStyle(color: Colors.red.shade700, fontWeight: FontWeight.w500),
          ),
          style: OutlinedButton.styleFrom(
            side: BorderSide(color: Colors.red.shade300),
            padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
        ),
        const SizedBox(height: 24),
        Text(
          'App Version 1.0.0',
          style: TextStyle(color: Colors.grey.shade600, fontSize: 12),
        ),
        const SizedBox(height: 8),
      ],
    );
  }

  Widget _buildProfileOptionItem({
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 16),
        decoration: BoxDecoration(
          border: Border(bottom: BorderSide(color: Colors.grey.shade200, width: 1)),
        ),
        child: Row(
          children: [
            Icon(icon, color: Colors.deepPurple, size: 20),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                title,
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
              ),
            ),
            const Icon(Icons.arrow_forward_ios, color: Colors.grey, size: 16),
          ],
        ),
      ),
    );
  }
}


/* File: ./delivery_person_app\test\widget_test.dart */
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:delivery_person_app/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}


/* File: ./server\delivery-service\server.js */
require('dotenv').config(); // Load environment variables from .env file
const connectDB = require("./config/db");
const express = require('express');
const mongoose = require('mongoose');
const http = require('http');
const socketIo = require('socket.io');
const messageBroker = require('./utils/messagebroker_neworder'); // Correctly import your message broker
const deliveryRoutes = require('./routes/deliveryRoutes'); // Delivery routes
const RegmessageBroker = require('./utils/delivery_person_register_Listner'); // Use the correct file


const app = express();

// MongoDB connection
connectDB();

// Start listening for new orders from RabbitMQ
messageBroker.listenForNewOrders(); // Make sure listenForNewOrders() is implemented correctly
// Start listening for delivery person registration events
RegmessageBroker.listenForDeliveryPersonRegistration(); // Make sure listenForDeliveryPersonRegistration() is implemented correctly

// Create server and setup socket.io
const server = http.createServer(app);
const io = socketIo(server);

// Handle WebSocket connections
io.on('connection', (socket) => {
  console.log('A user connected');

  socket.on('statusUpdate', (data) => {
    io.emit('statusUpdate', data); // Broadcast the update to all connected clients
  });

  socket.on('disconnect', () => {
    console.log('A user disconnected');
  });
});

// Middleware setup (if you need to parse JSON or set headers)
app.use(express.json()); // This will parse incoming requests with JSON payloads

// Use delivery routes
app.use('/api/delivery', deliveryRoutes);

// Define the server port
const PORT = process.env.PORT || 3008;
server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});


/* File: ./server\delivery-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
    try {
        console.log("Mongo URI: ", process.env.MONGODB_URI);  // Log the Mongo URI
        mongoose.connect(process.env.MONGODB_URI, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        })
        .then(() => console.log('Connected to MongoDB'))
        .catch(err => console.error('MongoDB connection error:', err));
    } catch (error) {
        console.error("Error connecting to MongoDB:", error.message);
        process.exit(1); // Exit process with failure
    }
};

module.exports = connectDB;

/* File: ./server\delivery-service\controllers\deliveryController.js */
const Order = require('../models/orders');
const DeliveryPerson = require('../models/deliveryPerson');

const assignDelivery = async (req, res) => {
    const { orderId, requiredVehicleType } = req.body;
  
    try {
      // Find the order by ID
      const order = await Order.findById(orderId);
      if (!order) {
        return res.status(404).send({ message: 'Order not found' });
      }
  
      // Find the available delivery person with the required vehicle type
      const availableDriver = await DeliveryPerson.findOne({ 
        availability: true,
        vehicleType: requiredVehicleType,
      });
  
      if (!availableDriver) {
        return res.status(400).send({ message: 'No available delivery personnel with the required vehicle type' });
      }
  
      // Assign delivery to the driver
      order.deliveryPersonId = availableDriver._id;
      order.status = 'Assigned';
      await order.save();
  
      // Update the delivery person's availability
      availableDriver.availability = false;
      await availableDriver.save();
  
      res.status(200).send({ message: 'Delivery assigned', order });
    } catch (error) {
      console.error(error);
      res.status(500).send({ message: 'Internal server error' });
    }
  };

  // Get the current status of an order
const getDeliveryStatus = async (req, res) => {
    const { orderId } = req.params;
    const order = await Order.findById(orderId);
  
    if (!order) {
      return res.status(404).send({ message: 'Order not found' });
    }
  
    res.status(200).send({ orderId, status: order.status });
  };
  
  // Update the status of an order (e.g., when delivery person accepts, starts delivery, etc.)
  const updateOrderStatus = async (req, res) => {
    const { orderId, newStatus } = req.body;
  
    try {
      const order = await Order.findById(orderId);
      if (!order) {
        return res.status(404).send({ message: 'Order not found' });
      }
  
      // Ensure the new status is valid
      const validStatuses = ['Pending', 'Assigned', 'Accepted', 'Picked Up', 'In Transit', 'Delivered', 'Cancelled'];
      if (!validStatuses.includes(newStatus)) {
        return res.status(400).send({ message: 'Invalid status' });
      }
  
      // Update the order status
      order.status = newStatus;
      await order.save();
  
      // Broadcast status update to clients using Socket.io (optional, for real-time updates)
      io.emit('statusUpdate', { orderId, newStatus }); 
  
      res.status(200).send({ message: 'Order status updated', order });
    } catch (error) {
      console.error(error);
      res.status(500).send({ message: 'Internal server error' });
    }
  };

  module.exports = {
    assignDelivery,
    getDeliveryStatus,
    updateOrderStatus,
  };

  
  


/* File: ./server\delivery-service\models\deliveryPerson.js */
const mongoose = require('mongoose');

const deliveryPersonSchema = new mongoose.Schema({
  name: { type: String, required: true },
  phone: { type: String, required: true },
  location: { type: String, default: "Not Provided" }, // Default value for location
  availability: { type: Boolean, default: true },
  vehicleType: { type: String, required: true }, 
  vehicleLicensePlate: { type: String, required: true },
});

module.exports = mongoose.model('DeliveryPerson', deliveryPersonSchema);


/* File: ./server\delivery-service\models\orders.js */
const mongoose = require('mongoose');

const orderSchema = new mongoose.Schema({
  customerId: { type: mongoose.Schema.Types.ObjectId, ref: 'Customer' },
  restaurantId: { type: mongoose.Schema.Types.ObjectId, ref: 'Restaurant' },
  status: {
    type: String,
    enum: ['Pending', 'Assigned', 'Accepted', 'Picked Up', 'In Transit', 'Delivered', 'Cancelled'],
    default: 'Pending',
  },
  deliveryPersonId: { type: mongoose.Schema.Types.ObjectId, ref: 'DeliveryPerson', default: null },
  deliveryLocation: String,
  deliveryTime: Date,
});

module.exports = mongoose.model('Order', orderSchema); 


/* File: ./server\delivery-service\routes\deliveryRoutes.js */
const express = require('express');
const router = express.Router();
const { assignDelivery, getDeliveryStatus, updateOrderStatus } = require('../controllers/deliveryController');

// Route to assign a delivery to a driver
router.post('/assign', assignDelivery);

// Route to get the current status of a delivery
router.get('/status/:orderId', getDeliveryStatus);

// Route to update the status of an order
router.put('/update-status', updateOrderStatus);  // Method for updating the status of an order

module.exports = router;


/* File: ./server\delivery-service\utils\delivery_person_register_Listner.js */
const amqp = require('amqplib/callback_api');
const DeliveryPerson = require('../models/deliveryPerson');  // DeliveryPerson model for saving the details

// Function to listen for delivery person registration events
const listenForDeliveryPersonRegistration = () => {
  amqp.connect('amqp://localhost', (error, connection) => {
    if (error) {
      throw error;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        throw error;
      }

      const queue = 'delivery_person_registered_queue';  // Queue name for listening

      channel.assertQueue(queue, { durable: true });
      console.log('Waiting for delivery person registration events...');

      // Consume the message from the queue
      channel.consume(queue, async (msg) => {
        if (msg !== null) {
          const deliveryPersonData = JSON.parse(msg.content.toString());
          console.log(`Received delivery person event: ${deliveryPersonData.name}`);

          // Save the delivery person details in the DeliveryPerson model
          await saveDeliveryPerson(deliveryPersonData);

          // Acknowledge the message after processing
          channel.ack(msg);
        }
      });
    });
  });
};

// Function to save the delivery person in the DeliveryPerson model
const saveDeliveryPerson = async (data) => {
  try {
    const newDeliveryPerson = new DeliveryPerson({
      name: data.name,
      phone: data.phone,
      location: "",  // You can leave it empty or update later
      availability: true, // Default availability
      vehicleType: data.vehicleType,
      vehicleLicensePlate: data.vehicleLicensePlate,
    });

    // Save the delivery person in the database
    await newDeliveryPerson.save();
    console.log(`Saved delivery person: ${newDeliveryPerson.name}`);
  } catch (error) {
    console.error('Error saving delivery person:', error);
  }
};

// Start listening for the delivery person registration events
listenForDeliveryPersonRegistration();

module.exports = {
  listenForDeliveryPersonRegistration,
};


/* File: ./server\delivery-service\utils\messagebroker_neworder.js */
const amqp = require('amqplib/callback_api');
const DeliveryPerson = require('../models/deliveryPerson');
const Order = require('../models/orders');

const listenForNewOrders = () => {
    amqp.connect('amqp://localhost', (error, connection) => {
        if (error) {
            throw error;
        }

        connection.createChannel((error, channel) => {
            if (error) {
                throw error;
            }

            const queue = 'order_created_queue'; // Queue name used by Order Service

            channel.assertQueue(queue, { durable: true });
            console.log('Waiting for new orders...');

            channel.consume(queue, async (msg) => {
                if (msg !== null) {
                    const order = JSON.parse(msg.content.toString());
                    console.log(`Received order ID: ${order.orderId}`);

                    // Process the order in the Delivery Service (assign delivery to driver)
                    await assignDelivery(order.orderId);

                    // Acknowledge the message after processing
                    channel.ack(msg);
                }
            });
        });
    });
};

const assignDelivery = async (orderId) => {
    try {
        const order = await Order.findById(orderId);
        if (!order) {
            console.log(`Order not found: ${orderId}`);
            return;
        }

        const availableDriver = await DeliveryPerson.findOne({ availability: true });
        if (!availableDriver) {
            console.log(`No available drivers for order ${orderId}`);
            return;
        }

        // Assign the delivery to the available driver
        order.deliveryPersonId = availableDriver._id;
        order.status = 'Assigned';
        await order.save();

        // Update the delivery person's availability
        availableDriver.availability = false;
        await availableDriver.save();

        console.log(`Assigned driver ${availableDriver._id} to order ${orderId}`);
    } catch (error) {
        console.error('Error assigning delivery:', error);
    }
};

module.exports = { listenForNewOrders };


/* File: ./server\notification-service\server.js */
const express = require("express");
const cors = require("cors");
const bodyParser = require("body-parser");
require("dotenv").config();
const connectDB = require("./config/db");

const app = express();
connectDB();

app.use(cors());
app.use(bodyParser.json());

const notificationRoutes = require("./routes/notificationRoutes");
app.use("/api/notifications", notificationRoutes);



const PORT = process.env.PORT || 3005;
app.listen(PORT, () => console.log(`Notification Service running on port ${PORT}`));


/* File: ./server\notification-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB connected");
  } catch (error) {
    console.error("MongoDB connection failed", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server\notification-service\controllers\notificationController.js */
const Token = require("../models/Token");
const { sendNotification } = require("../services/fcmService");

// Register token
exports.registerToken = async (req, res) => {
  const { userId, token, role } = req.body;

  if (!userId || !token || !role) {
    return res.status(400).json({ message: "Missing fields" });
  }

  const existing = await Token.findOne({ userId, role });
  if (existing) {
    existing.token = token;
    existing.updatedAt = new Date();
    await existing.save();
  } else {
    await Token.create({ userId, token, role });
  }

  res.json({ message: "Token registered successfully" });
};

// Send to a specific user
exports.sendToUser = async (req, res) => {
  const { userId, role, title, body, data } = req.body;

  const user = await Token.findOne({ userId, role });
  if (!user) return res.status(404).json({ message: "Token not found" });

  try {
    await sendNotification(user.token, title, body, data);
    res.json({ message: "Notification sent" });
  } catch (err) {
    res.status(500).json({ message: "Failed to send", error: err.message });
  }
};

// Broadcast to all users by role
exports.broadcast = async (req, res) => {
  const { role, title, body, data } = req.body;

  const users = await Token.find({ role });
  let results = [];

  for (const user of users) {
    try {
      const res = await sendNotification(user.token, title, body, data);
      results.push({ userId: user.userId, result: res });
    } catch (err) {
      results.push({ userId: user.userId, error: err.message });
    }
  }

  res.json({ message: "Broadcast complete", results });
};


/* File: ./server\notification-service\models\Token.js */
const mongoose = require("mongoose");

const TokenSchema = new mongoose.Schema({
  userId: { type: String, required: true },
  token: { type: String, required: true },
  role: { type: String, enum: ["customer", "admin", "delivery"], required: true },
  updatedAt: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Token", TokenSchema);


/* File: ./server\notification-service\routes\notificationRoutes.js */
const express = require("express");
const router = express.Router();
const controller = require("../controllers/notificationController");

router.post("/register", controller.registerToken);
router.post("/sendToUser", controller.sendToUser);
router.post("/broadcast", controller.broadcast);

module.exports = router;


/* File: ./server\notification-service\services\fcmService.js */
const admin = require("firebase-admin");
const serviceAccount = require("../tastytrail-c628e-firebase-adminsdk-fbsvc-d49e61e481.json");

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const sendNotification = async (token, title, body, data = {}) => {
  const message = {
    token,
    notification: { title, body },
    data,
  };

  return await admin.messaging().send(message);
};

const sendNotificationflutter = async (token, title, body, data = {}) => {
  try {
    const message = {
      notification: {
        title,
        body,
      },
      data: {
        ...data,
        click_action: "FLUTTER_NOTIFICATION_CLICK",
      },
      token,
    };

    const response = await admin.messaging().send(message);
    console.log("Successfully sent message:", response);
    return response;
  } catch (error) {
    console.error("Error sending notification:", error);
    throw error;
  }
};

module.exports = { sendNotification, sendNotificationflutter };


/* File: ./server\notification-service\services\notificationService.js */
const admin = require("firebase-admin");

const sendOrderStatusNotification = async (fcmToken, order) => {
  try {
    console.log("Attempting to send notification:", {
      fcmToken: fcmToken?.substring(0, 10) + "...", // Log partial token for security
      orderId: order._id,
      status: order.status,
    });

    const message = {
      notification: {
        title: "Order Status Update",
        body: `Your order #${order._id} is now ${order.status}`,
      },
      data: {
        orderId: order._id.toString(),
        status: order.status,
        type: "order_update",
      },
      token: fcmToken,
    };

    const response = await admin.messaging().send(message);
    console.log("✅ FCM Response:", {
      messageId: response,
      success: true,
      timestamp: new Date().toISOString(),
    });
    return response;
  } catch (error) {
    console.error("❌ Notification Error:", {
      error: error.message,
      code: error.code,
      fcmToken: fcmToken?.substring(0, 10) + "...",
      timestamp: new Date().toISOString(),
    });
    throw error;
  }
};


/* File: ./server\order-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const morgan = require("morgan");
const connectDB = require("./config/db");
const orderRoutes = require("./routes/orderRoutes");
const cartRoutes = require("./routes/cartRoutes");
const errorHandler = require("./utils/errorHandler");
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan("dev"));

// Database connection
connectDB();

// Routes
app.use("/api/orders", orderRoutes);
app.use("/api/cart", cartRoutes);

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
  console.log(`Order service running on port ${PORT}`);
});

module.exports = app;


/* File: ./server\order-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("MongoDB connected successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server\order-service\controllers\cartController.js */
const Cart = require("../models/Cart");
const restaurantService = require("../services/restaurantService");
const userService = require("../services/userService");
const paymentService = require("../services/paymentService");
const estimationService = require("../services/estimationService");
const orderSplitter = require("../services/orderSplitter");
const Order = require("../models/Order");
const amqp = require("amqplib/callback_api");

// Function to publish the order created event to RabbitMQ
const publishOrderCreatedEvent = (orderId) => {
  amqp.connect("amqp://localhost", (error, connection) => {
    if (error) {
      console.error("RabbitMQ connection error:", error);
      return;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        console.error("RabbitMQ channel error:", error);
        return;
      }

      const queue = "order_created_queue";
      const msg = JSON.stringify({ orderId });

      channel.assertQueue(queue, { durable: true });
      channel.sendToQueue(queue, Buffer.from(msg), { persistent: true });

      console.log(`Order Created Event Sent: ${msg}`);
    });

    setTimeout(() => {
      connection.close();
    }, 500);
  });
};

// Get cart contents
const getCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;

    let cart = await Cart.findOne({ customerId });
    if (!cart) {
      cart = new Cart({ customerId, items: [] });
      await cart.save();
    }

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Add item to cart
const addToCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { restaurantId, menuItemId, name, price, quantity } = req.body;

    // Validate restaurant availability
    const restaurantAvailability =
      await restaurantService.getRestaurantAvailability(restaurantId);
    if (!restaurantAvailability.isAvailable) {
      return res
        .status(400)
        .json({ message: "Restaurant is not available for orders" });
    }

    let cart = await Cart.findOne({ customerId });
    if (!cart) {
      cart = new Cart({ customerId, items: [] });
    }

    // Check if cart already has items from a different restaurant
    const existingRestaurantIds = [
      ...new Set(cart.items.map((item) => item.restaurantId.toString())),
    ];
    if (
      existingRestaurantIds.length > 0 &&
      !existingRestaurantIds.includes(restaurantId.toString())
    ) {
      // We'll still allow adding the item, but include a warning
      cart.items.push({ restaurantId, menuItemId, name, price, quantity });
      await cart.save();

      return res.status(200).json({
        cart,
        warning:
          "Your cart now contains items from multiple restaurants. These will be processed as separate orders during checkout.",
      });
    }

    // Check if item already exists in cart
    const existingItemIndex = cart.items.findIndex(
      (item) =>
        item.menuItemId.toString() === menuItemId &&
        item.restaurantId.toString() === restaurantId
    );

    if (existingItemIndex > -1) {
      // Update quantity if item exists
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item
      cart.items.push({ restaurantId, menuItemId, name, price, quantity });
    }

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Update cart item quantity
const updateCartItem = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { itemId, quantity } = req.body;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    const itemIndex = cart.items.findIndex(
      (item) => item._id.toString() === itemId
    );
    if (itemIndex === -1) {
      return res.status(404).json({ message: "Item not found in cart" });
    }

    if (quantity <= 0) {
      // Remove item if quantity is 0 or negative
      cart.items.splice(itemIndex, 1);
    } else {
      // Update quantity
      cart.items[itemIndex].quantity = quantity;
    }

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Remove item from cart
const removeFromCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { itemId } = req.params;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    cart.items = cart.items.filter((item) => item._id.toString() !== itemId);

    await cart.save();
    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// Clear cart
const clearCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;

    const cart = await Cart.findOne({ customerId });
    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    cart.items = [];
    await cart.save();

    res.status(200).json({ message: "Cart cleared successfully", cart });
  } catch (error) {
    next(error);
  }
};

// Convert cart to order(s)
const checkoutCart = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { deliveryAddress, deliveryLocation } = req.body;
    const token = req.headers.authorization?.split(" ")[1];

    console.log("checkoutCart", req.body);

    const cart = await Cart.findOne({ customerId });
    if (!cart || cart.items.length === 0) {
      return res.status(400).json({ message: "Cart is empty" });
    }

    // Get customer info from user service
    let customerInfo;
    try {
      customerInfo = await userService.getUserInfo(customerId, token);
    } catch (error) {
      console.error("Failed to get user info, using fallback data:", error);
      customerInfo = {
        name: "Customer",
        phone: "Unknown",
      };
    }

    // Group cart items by restaurant
    const itemsByRestaurant = {};
    cart.items.forEach((item) => {
      if (!itemsByRestaurant[item.restaurantId]) {
        itemsByRestaurant[item.restaurantId] = [];
      }
      itemsByRestaurant[item.restaurantId].push(item);
    });

    // Create separate orders for each restaurant
    const orderPromises = Object.keys(itemsByRestaurant).map(
      async (restaurantId) => {
        const restaurantItems = itemsByRestaurant[restaurantId];

        // Calculate total amount for this restaurant's items
        const totalAmount = orderSplitter.calculateOrderTotal(restaurantItems);

        console.log("rest items", restaurantItems);

        // Calculate estimated delivery time
        const estimatedTime = await estimationService.calculateEstimatedTime(
          restaurantItems,
          deliveryLocation,
          [restaurantId]
        );

        // Create order for this restaurant
        const order = new Order({
          customerId,
          customerInfo: {
            name: customerInfo.name || "Customer",
            phone: customerInfo.phone || "Unknown",
          },
          items: restaurantItems,
          deliveryAddress,
          deliveryLocation,
          totalAmount,
          paymentStatus: "pending",
          estimatedDeliveryTime: estimatedTime,
          trackingStatus: "placed",
          statusUpdates: [
            {
              status: "placed",
              timestamp: Date.now(),
              note: "Order placed successfully",
            },
          ],
          restaurantId,
        });

        // Save the order
        const savedOrder = await order.save();

        // Initiate payment process for this order
        const paymentResponse = await paymentService.createPayment(
          savedOrder._id,
          totalAmount,
          customerId,
          `Order #${savedOrder._id} for restaurant ${restaurantId}`,
          token
        );

        // Update order with payment ID
        savedOrder.paymentId = paymentResponse.paymentId;
        await savedOrder.save();

        return {
          order: savedOrder,
          payment: {
            paymentId: paymentResponse.paymentId,
            checkoutUrl: paymentResponse.checkoutUrl,
            paymentParams: paymentResponse.paymentParams,
          },
        };
      }
    );

    // Wait for all orders to be created
    const results = await Promise.all(orderPromises);

    // Clear cart after successful orders
    cart.items = [];
    await cart.save();

    res.status(201).json({
      message: `Created ${results.length} orders from your cart`,
      orders: results,
    });
  } catch (error) {
    next(error);
  }
};

// Checkout items from a specific restaurant only - NEW FUNCTION
const checkoutRestaurant = async (req, res, next) => {
  try {
    const customerId = req.user.id;
    const { restaurantId, deliveryAddress, paymentMethod } = req.body;
    const token = req.headers.authorization?.split(" ")[1];

    if (!req.body.deliveryLocation || !req.body.deliveryLocation.coordinates) {
      return res.status(400).json({
        message: "Delivery location coordinates are required",
      });
    }

    if (!deliveryAddress) {
      console.log("Delivery address is required");
      return res.status(400).json({ message: "Delivery address is required" });
    }

    // Use default delivery location if not provided
    const deliveryLocation = req.body.deliveryLocation || { lat: 0, lng: 0 };

    const cart = await Cart.findOne({ customerId });
    if (!cart || cart.items.length === 0) {
      return res.status(400).json({ message: "Cart is empty" });
    }

    // Filter for items only from the specified restaurant
    const restaurantItems = cart.items.filter(
      (item) => item.restaurantId.toString() === restaurantId.toString()
    );

    if (restaurantItems.length === 0) {
      return res.status(400).json({
        message: "No items found for this restaurant in your cart",
      });
    }

    // Get customer info from user service
    let customerInfo;
    try {
      customerInfo = await userService.getUserInfo(customerId, token);
    } catch (error) {
      console.error("Failed to get user info, using fallback data:", error);
      customerInfo = {
        name: "Customer",
        phone: "Unknown",
      };
    }

    // Calculate total amount for this restaurant's items
    const totalAmount = orderSplitter.calculateOrderTotal(restaurantItems);

    console.log("rest items", restaurantItems);

    console.log("Delivery location:", deliveryLocation);

    // Calculate estimated delivery time
    const estimatedTime = await estimationService.calculateEstimatedTime(
      restaurantItems,
      deliveryLocation,
      restaurantId
    );

    console.log("estimated time", estimatedTime);

    // Create order for this restaurant
    const order = new Order({
      customerId,
      customerInfo: {
        name: customerInfo.name || "Customer",
        phone: customerInfo.phone || "Unknown",
      },
      items: restaurantItems,
      deliveryAddress,
      deliveryLocation,
      totalAmount,
      paymentStatus: "pending",
      paymentType: paymentMethod,
      estimatedDeliveryTime: estimatedTime,
      trackingStatus: "placed",
      statusUpdates: [
        {
          status: "placed",
          timestamp: Date.now(),
          note: "Order placed successfully",
        },
      ],
      restaurantId,
    });

    // Save the order
    const savedOrder = await order.save();

    // Initiate payment process for this order
    const paymentResponse = await paymentService.createPayment(
      savedOrder._id,
      totalAmount,
      customerId,
      `Order #${savedOrder._id} for restaurant ${restaurantId}`,
      token,
      paymentMethod
    );

    // Update order with payment ID
    savedOrder.paymentId = paymentResponse.paymentId;
    await savedOrder.save();

    // Publish the order created event to RabbitMQ
    publishOrderCreatedEvent(savedOrder._id);

    // IMPORTANT FIX: Remove ONLY the items from this restaurant
    cart.items = cart.items.filter(
      (item) => item.restaurantId.toString() !== restaurantId.toString()
    );
    await cart.save();

    res.status(201).json({
      message: "Order created successfully",
      order: savedOrder,
      payment: {
        paymentId: paymentResponse.paymentId,
        checkoutUrl: paymentResponse.checkoutUrl,
        paymentParams: paymentResponse.paymentParams,
      },
      cart: cart,
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
  checkoutCart,
  checkoutRestaurant, // Export the new function
};


/* File: ./server\order-service\controllers\orderController.js */
const Order = require("../models/Order");
const Cart = require("../models/Cart");
const axios = require("axios");
const orderSplitter = require("../services/orderSplitter");
const restaurantService = require("../services/restaurantService");
const paymentService = require("../services/paymentService");
const notificationService = require("../services/notificationService");
const estimationService = require("../services/estimationService");
const userService = require("../services/userService");
const { RESTAURANT_SERVICE_URL } = process.env;
const amqp = require("amqplib/callback_api");

// Function to publish an event to RabbitMQ
// Function to publish the order created event to RabbitMQ
const publishOrderCreatedEvent = (orderId) => {
  amqp.connect("amqp://localhost", (error, connection) => {
    if (error) {
      throw error;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        throw error;
      }

      const queue = "order_created_queue"; // Queue name where delivery service listens
      const msg = JSON.stringify({ orderId }); // Message payload (only orderId)

      channel.assertQueue(queue, { durable: true });
      channel.sendToQueue(queue, Buffer.from(msg), { persistent: true });

      console.log(`Order Created Event Sent: ${msg}`);
    });

    setTimeout(() => {
      connection.close();
    }, 500);
  });
};

// Create a new order with items from a single restaurant
const createOrder = async (req, res, next) => {
  try {
    const {
      customerId,
      customerInfo,
      items,
      deliveryAddress,
      deliveryLocation,
    } = req.body;

    if (!deliveryAddress) {
      return res.status(400).json({ message: "Delivery address is required" });
    }

    // Ensure all items are from the same restaurant
    const restaurantIds = [
      ...new Set(items.map((item) => item.restaurantId.toString())),
    ];
    if (restaurantIds.length > 1) {
      return res.status(400).json({
        message: "An order can only contain items from a single restaurant",
        restaurantIds,
      });
    }

    const restaurantId = restaurantIds[0];

    // Validate restaurant availability
    const restaurantAvailability =
      await restaurantService.getRestaurantAvailability(restaurantId);
    if (!restaurantAvailability.isAvailable) {
      return res.status(400).json({
        message: "Restaurant is not available for orders",
        restaurantId,
      });
    }

    // Calculate total amount
    const totalAmount = orderSplitter.calculateOrderTotal(items);

    console.log("Delivery location:", deliveryLocation);

    // Calculate estimated delivery time
    const estimatedTime = await estimationService.calculateEstimatedTime(
      items,
      deliveryLocation,
      restaurantId
    );

    // Create the order
    const order = new Order({
      customerId,
      customerInfo,
      items,
      deliveryAddress,
      deliveryLocation,
      totalAmount,
      paymentStatus: "pending",
      estimatedDeliveryTime: estimatedTime,
      trackingStatus: "placed",
      statusUpdates: [
        {
          status: "placed",
          timestamp: Date.now(),
          note: "Order placed successfully",
        },
      ],
      restaurantId,
    });

    const savedOrder = await order.save();

    // Create response data object
    const responseData = {
      order: savedOrder,
    };

    let paymentResponse;

    // Initiate payment process
    try {
      const token = req.headers.authorization?.split(" ")[1];
      console.log("Token being used:", token); // Debug log
      paymentResponse = await paymentService.createPayment(
        savedOrder._id,
        totalAmount,
        customerId,
        `Order #${savedOrder._id} with ${items.length} items`,
        token
      );

      // Store payment ID in order
      savedOrder.paymentId = paymentResponse.paymentId;
      await savedOrder.save();

      // Include payment information in response
      responseData.payment = {
        paymentId: paymentResponse.paymentId,
        checkoutUrl: paymentResponse.checkoutUrl,
        paymentParams: paymentResponse.paymentParams,
      };
    } catch (error) {
      console.error("Error initiating payment:", error);
      return res.status(500).json({ message: "Error initiating payment" });
    }

    // Now paymentResponse is accessible here
    if (paymentResponse) {
      // Update order with payment ID
      savedOrder.paymentId = paymentResponse.paymentId;
      await savedOrder.save();
    }

    // Publish the order created event to RabbitMQ after the order is created
    publishOrderCreatedEvent(savedOrder._id);

    res.status(201).json(savedOrder);
  } catch (error) {
    next(error);
  }
};

// Get order details
const getOrderWithSubOrders = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    res.json(order);
  } catch (error) {
    next(error);
  }
};

// Get orders by customer
const getCustomerOrders = async (req, res, next) => {
  try {
    const orders = await Order.find({ customerId: req.params.customerId }).sort(
      { createdAt: -1 }
    );

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Get orders by restaurant
const getRestaurantOrders = async (req, res, next) => {
  try {
    const orders = await Order.find({
      restaurantId: req.params.restaurantId,
    })
      .sort({ createdAt: -1 })
      .populate("customerId", "name");

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Update order tracking status
const updateOrderStatus = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const { status, note } = req.body;

    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    // Update tracking status
    order.trackingStatus = status;
    order.statusUpdates.push({
      status,
      timestamp: Date.now(),
      note: note || "",
    });

    await order.save();

    // Send notification to customer
    try {
      await axios.post(
        `${process.env.NOTIFICATION_SERVICE_URL}/api/notifications/send`,
        {
          userId: order.customerId,
          role: "customer",
          title: "Order Status Update",
          body: `Your order #${order._id} is now ${status}`,
          data: {
            orderId: order._id.toString(),
            status,
            type: "order_update",
          },
        }
      );
    } catch (notificationError) {
      console.error("Failed to send notification:", notificationError);
    }

    res.status(200).json(order);
  } catch (error) {
    next(error);
  }
};

// Get orders assigned to delivery person
const getDeliveryPersonOrders = async (req, res, next) => {
  try {
    const deliveryPersonId = req.user.id;

    const orders = await Order.find({
      deliveryPersonId,
      trackingStatus: { $in: ["ready_for_pickup", "out_for_delivery"] },
    })
      .sort({ createdAt: -1 })
      .populate("customerId", "name")
      .populate("items.restaurantId", "name address")
      .populate("restaurantId", "name address");

    res.json(orders);
  } catch (error) {
    next(error);
  }
};

// Get specific order for delivery person
const getDeliveryOrder = async (req, res, next) => {
  try {
    const deliveryPersonId = req.user.id;
    const orderId = req.params.id;

    const order = await Order.findOne({
      _id: orderId,
      deliveryPersonId,
    })
      .populate("customerId", "name email")
      .populate("items.restaurantId", "name address")
      .populate("restaurantId", "name address");

    if (!order) {
      return res
        .status(404)
        .json({ message: "Order not found or not assigned to you" });
    }

    res.json(order);
  } catch (error) {
    next(error);
  }
};

const updateOrderPaymentStatus = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const { paymentStatus, paymentId } = req.body;

    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ message: "Order not found" });
    }

    // Update payment status
    order.paymentStatus = paymentStatus;
    order.paymentId = paymentId;

    // If payment is completed, update order status
    if (paymentStatus === "completed") {
      order.trackingStatus = "confirmed";
      order.statusUpdates.push({
        status: "confirmed",
        timestamp: Date.now(),
        note: "Payment completed, order confirmed",
      });

      // Notify customer about confirmed order
      await notificationService
        .sendNotification(
          order.customerId,
          "order_confirmed",
          `Your order #${order._id} has been confirmed and is being prepared`,
          { orderId: order._id }
        )
        .catch((err) => console.error("Notification service error:", err));
    } else if (paymentStatus === "failed" || paymentStatus === "cancelled") {
      order.trackingStatus = "cancelled";
      order.statusUpdates.push({
        status: "cancelled",
        timestamp: Date.now(),
        note: "Order cancelled due to payment issues",
      });

      // Notify customer about cancelled order
      await notificationService
        .sendNotification(
          order.customerId,
          "order_cancelled",
          `Your order #${order._id} has been cancelled due to payment issues`,
          { orderId: order._id }
        )
        .catch((err) => console.error("Notification service error:", err));
    }

    await order.save();
    res.status(200).json({ message: "Order payment status updated", order });
  } catch (error) {
    next(error);
  }
};

const updateSubOrderStatus = async (req, res, next) => {
  try {
    const { subOrderId } = req.params;
    const { status, note } = req.body;

    // Find the order containing this sub-order
    const order = await Order.findOne({ "items._id": subOrderId });

    if (!order) {
      return res.status(404).json({ message: "Sub-order not found" });
    }

    // Find the specific item in the order
    const subOrderIndex = order.items.findIndex(
      (item) => item._id.toString() === subOrderId
    );

    if (subOrderIndex === -1) {
      return res.status(404).json({ message: "Sub-order not found in order" });
    }

    // Update the status of the sub-order
    order.items[subOrderIndex].status = status;

    // Add to status updates history if note is provided
    if (note) {
      order.statusUpdates.push({
        status: `sub_order_${status}`,
        timestamp: Date.now(),
        note: note,
        subOrderId: subOrderId,
      });
    }

    await order.save();

    // Notify customer about status update
    await notificationService
      .sendNotification(
        order.customerId,
        "sub_order_status_update",
        `Your item "${order.items[subOrderIndex].name}" is now ${status}`,
        { orderId: order._id, subOrderId: subOrderId, status }
      )
      .catch((err) => console.error("Notification service error:", err));

    res.status(200).json({
      message: "Sub-order status updated successfully",
      order,
    });
  } catch (error) {
    next(error);
  }
};

// Export all controller functions
module.exports = {
  createOrder,
  getOrderWithSubOrders,
  getCustomerOrders,
  getRestaurantOrders,
  updateOrderStatus,
  getDeliveryPersonOrders,
  getDeliveryOrder,
  updateOrderPaymentStatus,
  updateSubOrderStatus,
};


/* File: ./server\order-service\models\Cart.js */
const mongoose = require("mongoose");

const cartItemSchema = new mongoose.Schema({
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  menuItemId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  price: {
    type: Number,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
  },
});

const cartSchema = new mongoose.Schema({
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "User",
    unique: true,
  },
  items: [cartItemSchema],
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

cartSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("Cart", cartSchema);


/* File: ./server\order-service\models\Order.js */
const mongoose = require("mongoose");

const orderItemSchema = new mongoose.Schema({
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  menuItemId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  price: {
    type: Number,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
  },
  status: {
    type: String,
    enum: [
      "pending",
      "confirmed",
      "preparing",
      "ready",
      "picked_up",
      "delivered",
      "cancelled",
    ],
    default: "pending",
  },
});

const orderSchema = new mongoose.Schema({
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "User",
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "Restaurant",
  },
  customerInfo: {
    name: {
      type: String,
      required: true,
    },
    phone: {
      type: String,
      required: true,
    },
  },
  items: [orderItemSchema],
  deliveryAddress: {
    type: String,
    required: true,
  },
  deliveryLocation: {
    type: {
      type: String,
      default: "Point",
    },
    coordinates: [Number], // [longitude, latitude]
  },
  deliveryPersonId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  totalAmount: {
    type: Number,
    required: true,
  },
  paymentType: {
    type: String,
    enum: ["cash", "card"],
    required: true,
    default: "cash",
  },
  paymentStatus: {
    type: String,
    enum: ["pending", "completed", "failed", "refunded"],
    default: "pending",
  },
  paymentId: {
    type: String,
  },
  trackingStatus: {
    type: String,
    enum: [
      "placed",
      "confirmed",
      "preparing",
      "ready_for_pickup",
      "out_for_delivery",
      "delivered",
      "cancelled",
    ],
    default: "placed",
  },
  statusUpdates: [
    {
      status: String,
      timestamp: {
        type: Date,
        default: Date.now,
      },
      note: String,
    },
  ],
  estimatedDeliveryTime: {
    preparationTime: Number,
    travelTime: Number,
    totalEstimatedTime: Number,
    estimatedDeliveryAt: Date,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

orderSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("Order", orderSchema);


/* File: ./server\order-service\routes\cartRoutes.js */
const express = require("express");
const router = express.Router();
const {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
  checkoutCart,
  checkoutRestaurant,
} = require("../controllers/cartController");
const authMiddleware = require("../utils/authMiddleware");

// All cart routes require customer authentication
router.use(authMiddleware(["customer"]));

// Cart routes
router.get("/", getCart);
router.post("/items", addToCart);
router.patch("/items", updateCartItem);
router.delete("/items/:itemId", removeFromCart);
router.delete("/", clearCart);
router.post("/checkout", checkoutRestaurant);

module.exports = router;


/* File: ./server\order-service\routes\orderRoutes.js */
const express = require("express");
const router = express.Router();
const {
  createOrder,
  getOrderWithSubOrders,
  updateSubOrderStatus,
  getCustomerOrders,
  getRestaurantOrders,
  updateOrderStatus,
  getDeliveryPersonOrders,
  getDeliveryOrder,
  updateOrderPaymentStatus,
} = require("../controllers/orderController");
const authMiddleware = require("../utils/authMiddleware");

// Customer routes
router.post("/", authMiddleware(["customer"]), createOrder);
router.get(
  "/customer/:customerId",
  authMiddleware(["customer"]),
  getCustomerOrders
);
router.get(
  "/:id",
  authMiddleware([
    "customer",
    "restaurant_admin",
    "delivery_personnel",
    "internal_service",
  ]),
  getOrderWithSubOrders
);

// Restaurant admin routes
router.patch(
  "/:id/suborders",
  authMiddleware(["restaurant_admin"]),
  updateSubOrderStatus
);
router.get(
  "/restaurant/:restaurantId",
  authMiddleware(["restaurant_admin"]),
  getRestaurantOrders
);

// Order tracking routes
router.patch(
  "/:orderId/status",
  authMiddleware(["restaurant_admin", "delivery_personnel", "admin"]),
  updateOrderStatus
);

// Delivery personnel routes
router.patch(
  "/suborders/:subOrderId/status",
  authMiddleware(["delivery_personnel"]),
  updateSubOrderStatus
);

router.get(
  "/delivery/assigned",
  authMiddleware(["delivery_personnel"]),
  getDeliveryPersonOrders
);

router.get(
  "/delivery/order/:id",
  authMiddleware(["delivery_personnel"]),
  getDeliveryOrder
);

router.post(
  "/:orderId/payment-update",
  authMiddleware(["internal_service"]),
  updateOrderPaymentStatus
);

module.exports = router;


/* File: ./server\order-service\services\estimationService.js */
const axios = require("axios");
const { RESTAURANT_SERVICE_URL } = process.env;

const calculateEstimatedTime = async (
  items,
  deliveryLocation,
  restaurantId
) => {
  try {
    console.log("Fetching restaurant details for ID:", restaurantId);

    // Fetch restaurant data from restaurant service
    const response = await axios.get(
      `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}`
    );

    if (!response.data || !response.data.restaurant) {
      throw new Error("Restaurant data not found");
    }

    const restaurant = response.data.restaurant;
    console.log("Restaurant data received:", restaurant);

    // Validate restaurant has location data
    if (!restaurant.address?.geoCoordinates?.coordinates) {
      throw new Error("Restaurant coordinates not found");
    }

    // Validate delivery location
    if (!deliveryLocation?.coordinates) {
      throw new Error("Delivery coordinates not provided");
    }

    const restaurantCoords = restaurant.address.geoCoordinates.coordinates;
    const deliveryCoords = deliveryLocation.coordinates;

    console.log("Restaurant coordinates:", restaurantCoords);
    console.log("Delivery coordinates:", deliveryCoords);

    // Calculate base preparation time (5 mins per item)
    const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
    const preparationTime = totalItems * 5;

    // Calculate distance and delivery time
    const distance = calculateDistance(
      restaurantCoords[1], // latitude
      restaurantCoords[0], // longitude
      deliveryCoords[1], // latitude
      deliveryCoords[0] // longitude
    );

    // Assume average speed of 30 km/h
    const deliveryTime = Math.ceil((distance / 30) * 60);

    // Total estimated time in minutes
    const totalEstimatedTime = preparationTime + deliveryTime;

    console.log("Estimated delivery time:", {
      preparationTime,
      deliveryTime,
      totalEstimatedTime,
    });

    return totalEstimatedTime;
  } catch (error) {
    console.error("Error in calculateEstimatedTime:", error);
    throw error;
  }
};

// Helper function to calculate distance between two points using Haversine formula
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in km
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(degrees) {
  return degrees * (Math.PI / 180);
}

module.exports = {
  calculateEstimatedTime,
};


/* File: ./server\order-service\services\notificationService.js */
const axios = require("axios");
require("dotenv").config();

const { NOTIFICATION_SERVICE_URL } = process.env;

module.exports = {
  sendNotification: async (userId, type, message, metadata) => {
    try {
      // Check if notification service URL is defined
      if (!NOTIFICATION_SERVICE_URL) {
        console.log(
          "Notification service URL not defined, skipping notification"
        );
        return;
      }

      await axios.post(`${NOTIFICATION_SERVICE_URL}/api/notifications`, {
        userId,
        type,
        message,
        metadata,
      });
    } catch (error) {
      console.error("Error sending notification:", error.message);
      // Fail silently as notification is not critical
    }
  },
};


/* File: ./server\order-service\services\orderSplitter.js */
const _ = require("lodash");

module.exports = {
  // Group items by restaurant
  groupItemsByRestaurant: (items) => {
    return _.groupBy(items, "restaurantId");
  },

  // Calculate total amount for items
  calculateOrderTotal: (items) => {
    return items.reduce((total, item) => {
      return total + item.price * item.quantity;
    }, 0);
  },
};


/* File: ./server\order-service\services\paymentService.js */
// order-service/services/paymentService.js
const axios = require("axios");

const PAYMENT_SERVICE_URL =
  process.env.PAYMENT_SERVICE_URL || "http://localhost:3001";

// Create a payment for an order
const createPayment = async (
  orderId,
  amount,
  customerId,
  description,
  token,
  paymentMethod
) => {
  try {
    console.log("Creating payment with token:", token); // Debug log
    const response = await axios.post(
      `${PAYMENT_SERVICE_URL}/api/payments`,
      {
        orderId,
        amount,
        customerId,
        description,
        paymentMethod,
      },
      {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      }
    );
    return response.data;
  } catch (error) {
    console.error("Error creating payment:", error);
    throw error;
  }
};

// Update order with payment status
const updateOrderPaymentStatus = async (orderId, paymentStatus) => {
  try {
    // Find the order
    const order = await Order.findById(orderId);

    if (!order) {
      throw new Error(`Order not found: ${orderId}`);
    }

    // Update payment status
    order.paymentStatus = paymentStatus;

    // If payment is successful, update order status accordingly
    if (paymentStatus === "SUCCESSFUL") {
      order.status = "CONFIRMED";

      // Notify restaurants about confirmed order
      for (const subOrder of order.subOrders) {
        await restaurantService.notifyOrderConfirmation(
          subOrder.restaurantId,
          orderId,
          subOrder._id
        );
      }

      // Notify customer about confirmed order
      await notificationService.sendNotification(
        order.customerId,
        "order_confirmed",
        `Your order #${order._id} has been confirmed and is being prepared`,
        { orderId: order._id }
      );
    } else if (paymentStatus === "FAILED" || paymentStatus === "CANCELED") {
      order.status = "CANCELLED";

      // Notify customer about cancelled order
      await notificationService.sendNotification(
        order.customerId,
        "order_cancelled",
        `Your order #${order._id} has been cancelled due to payment issues`,
        { orderId: order._id }
      );
    }

    await order.save();

    return order;
  } catch (error) {
    console.error("Error updating order payment status:", error);
    throw error;
  }
};

module.exports = {
  createPayment,
  updateOrderPaymentStatus,
};


/* File: ./server\order-service\services\restaurantService.js */
const axios = require("axios");
require("dotenv").config();

const { RESTAURANT_SERVICE_URL } = process.env;

module.exports = {
  getRestaurantAvailability: async (restaurantId) => {
    try {
      const response = await axios.get(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}/availability`
      );
      return response.data;
    } catch (error) {
      console.error("Error fetching restaurant availability:", error);
      throw error;
    }
  },

  notifyNewOrder: async (restaurantId, orderData) => {
    try {
      await axios.post(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}/orders`,
        orderData
      );
    } catch (error) {
      console.error("Error notifying restaurant about new order:", error);
      throw error;
    }
  },

  getRestaurantDetails: async (restaurantId) => {
    try {
      const response = await axios.get(
        `${RESTAURANT_SERVICE_URL}/api/restaurants/${restaurantId}`
      );
      return response.data;
    } catch (error) {
      console.error("Error fetching restaurant details:", error);
      throw error;
    }
  },
};


/* File: ./server\order-service\services\userService.js */
const axios = require("axios");
require("dotenv").config();

const { USER_SERVICE_URL } = process.env;

module.exports = {
  getUserInfo: async (userId, token) => {
    try {
      // Use the correct endpoint
      const response = await axios.get(`${USER_SERVICE_URL}/api/users/me`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      return response.data.data.user;
    } catch (error) {
      console.error("Error fetching user info:", error);
      // Implement fallback mechanism
      try {
        // Try to get user by ID as fallback
        const fallbackResponse = await axios.get(
          `${USER_SERVICE_URL}/api/users/${userId}`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        return fallbackResponse.data.data.user;
      } catch (fallbackError) {
        console.error("Fallback also failed:", fallbackError);
        throw error; // Throw the original error
      }
    }
  },
  verifyDeliveryPerson: async (userId, token) => {
    try {
      const response = await axios.get(`${USER_SERVICE_URL}/api/users/me`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      // Check if the user has the delivery_personnel role
      return response.data.data.user.role === "delivery_personnel";
    } catch (error) {
      console.error("Error verifying delivery person:", error);
      return false;
    }
  },
};


/* File: ./server\order-service\utils\authMiddleware.js */
const jwt = require("jsonwebtoken");
const mongoose = require("mongoose");
require("dotenv").config();

module.exports = (allowedRoles) => {
  return (req, res, next) => {
    // First check for internal API key
    if (req.headers["x-api-key"] === process.env.INTERNAL_API_KEY) {
      // For internal service calls, create a valid ObjectId instead of "system"

      console.log(req.headers["x-api-key"]);
      req.user = {
        id: new mongoose.Types.ObjectId("000000000000000000000000"),
        role: "internal_service",
      };

      // Check if internal_service role is allowed
      if (!allowedRoles.includes("internal_service")) {
        return res
          .status(403)
          .json({ message: "Insufficient permissions for internal service" });
      }

      return next();
    }

    // If no internal API key, proceed with JWT authentication
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "Authentication required" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;

      if (!allowedRoles.includes(decoded.role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      next();
    } catch (error) {
      return res.status(401).json({ message: "Invalid token" });
    }
  };
};


/* File: ./server\order-service\utils\errorHandler.js */
module.exports = (err, req, res, next) => {
  console.error(err.stack);

  if (err.name === "ValidationError") {
    return res.status(400).json({
      message: "Validation error",
      details: err.message,
    });
  }

  if (err.isAxiosError) {
    return res.status(502).json({
      message: "Error communicating with dependent service",
      details: err.message,
    });
  }

  res.status(500).json({ message: "Something went wrong" });
};


/* File: ./server\payment-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const morgan = require("morgan");
const connectDB = require("./config/db");
const paymentRoutes = require("./routes/paymentRoutes");
const errorHandler = require("./utils/errorHandler");
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true })); // For parsing application/x-www-form-urlencoded
app.use(morgan("dev"));

// Database connection
connectDB();

// Routes
app.use("/api/payments", paymentRoutes);

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.status(200).json({ status: "OK", timestamp: new Date() });
});

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 3003;
app.listen(PORT, () => {
  console.log(`Payment service running on port ${PORT}`);
});

module.exports = app;


/* File: ./server\payment-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("MongoDB connected successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server\payment-service\controllers\paymentController.js */
const Payment = require("../models/Payment");
const paymentService = require("../services/paymentService");
const notificationService = require("../services/notificationService");
const axios = require("axios");
require("dotenv").config();

// // Create a new payment
// const createPayment = async (req, res, next) => {
//   try {
//     const { orderId, amount, customerId, description, paymentMethod } =
//       req.body;

//     // Validate required fields
//     if (!orderId || !amount || !customerId) {
//       return res.status(400).json({
//         message: "Missing required fields",
//         required: ["orderId", "amount", "customerId"],
//       });
//     }

//     // Check if payment already exists for this order
//     const existingPayment = await Payment.findOne({ orderId });
//     if (existingPayment) {
//       return res.status(400).json({
//         message: "Payment already exists for this order",
//         paymentId: existingPayment._id,
//       });
//     }

//     // Fetch customer info from user service using the user's token
//     let customerInfo;
//     try {
//       // Extract the token part from the Authorization header
//       const authHeader = req.headers.authorization;
//       const token =
//         authHeader &&
//         typeof authHeader === "string" &&
//         authHeader.startsWith("Bearer ")
//           ? authHeader.split(" ")[1]
//           : null;

//       if (!token) {
//         throw new Error("No valid authorization token provided");
//       }

//       // Use the /me endpoint with the user's token
//       const response = await axios.get(
//         `${process.env.USER_SERVICE_URL}/api/users/me`,
//         {
//           headers: {
//             Authorization: `Bearer ${token}`,
//           },
//         }
//       );
//       customerInfo = response.data.data.user;
//     } catch (error) {
//       console.error("Error fetching customer info:", error);
//       // Use fallback data instead of failing
//       customerInfo = {
//         name: "Customer",
//         phone: "Unknown",
//       };
//     }

//     // Convert description to string if it's an object
//     const descriptionStr =
//       typeof description === "object"
//         ? JSON.stringify(description)
//         : description || `Payment for order #${orderId}`;

//     // Create payment record (without items field)
//     const payment = new Payment({
//       orderId,
//       customerId,
//       amount,
//       currency: req.body.currency || "LKR",
//       description: descriptionStr,
//       paymentMethod: paymentMethod,
//     });

//     // Handle payment methods differently
//     if (paymentMethod === "cash") {
//       // For cash payments, create payment record with pending status
//       payment.status = "pending";
//       const savedPayment = await payment.save();

//       res.status(201).json({
//         paymentId: savedPayment._id,
//         status: "pending",
//       });
//     } else if (paymentMethod === "card") {
//       // For card payments, generate PayHere parameters
//       const savedPayment = await payment.save();

//       // Generate payment parameters and URL for PayHere
//       const paymentParams = paymentService.generatePaymentParams(
//         orderId,
//         amount,
//         payment.currency,
//         descriptionStr,
//         customerId,
//         customerInfo,
//         "card"
//       );

//       // Generate payment URL
//       const paymentUrl = paymentService.getPaymentUrl(paymentParams);

//       res.status(201).json({
//         paymentId: savedPayment._id,
//         checkoutUrl: paymentUrl,
//         paymentParams: paymentParams,
//       });
//     }
//   } catch (error) {
//     next(error);
//   }
// };

const createPayment = async (req, res, next) => {
  try {
    const { orderId, amount, customerId, description, paymentMethod } =
      req.body;

    // Validate required fields
    if (!orderId || !amount || !customerId) {
      return res.status(400).json({
        message: "Missing required fields",
        required: ["orderId", "amount", "customerId"],
      });
    }

    // Check if payment already exists for this order
    const existingPayment = await Payment.findOne({ orderId });
    if (existingPayment) {
      return res.status(400).json({
        message: "Payment already exists for this order",
        paymentId: existingPayment._id,
      });
    }

    // Create payment record (without PayHere integration)
    const payment = new Payment({
      orderId,
      customerId,
      amount,
      currency: req.body.currency || "LKR",
      description: description || `Payment for order #${orderId}`,
      paymentMethod: paymentMethod || "cash",
      status: paymentMethod === "cash" ? "pending" : "pending",
    });

    const savedPayment = await payment.save();

    res.status(201).json({
      paymentId: savedPayment._id,
      status: savedPayment.status,
    });
  } catch (error) {
    next(error);
  }
};

// Process payment notification from PayHere
const processNotification = async (req, res, next) => {
  try {
    const {
      merchant_id,
      order_id,
      payment_id,
      payhere_amount,
      payhere_currency,
      status_code,
      md5sig,
      method,
    } = req.body;

    // Verify the signature...
    const isValidSignature = paymentService.verifyPaymentSignature(
      merchant_id,
      order_id,
      payhere_amount,
      payhere_currency,
      status_code,
      md5sig
    );

    if (!isValidSignature) {
      console.error("Invalid payment signature for order:", order_id);
      return res.status(400).json({ message: "Invalid payment signature" });
    }

    // Find the payment
    const payment = await Payment.findOne({ orderId: order_id });
    if (!payment) {
      console.error("Payment not found for order:", order_id);
      return res.status(404).json({ message: "Payment not found" });
    }

    // Update payment status based on status code
    let paymentStatus;
    switch (status_code) {
      case "2":
        paymentStatus = "completed";
        break;
      case "0":
        paymentStatus = "pending";
        break;
      case "-1":
        paymentStatus = "cancelled";
        break;
      case "-2":
        paymentStatus = "failed";
        break;
      case "-3":
        paymentStatus = "chargedback";
        break;
      default:
        paymentStatus = "pending";
    }

    // Update payment record
    payment.status = paymentStatus;
    payment.paymentId = payment_id;
    payment.paymentMethod = method;
    payment.statusCode = status_code;
    payment.md5sig = md5sig;
    await payment.save();

    // Notify order service about payment status
    await notificationService.notifyOrderService(
      order_id,
      paymentStatus,
      payment_id
    );

    // Respond to PayHere
    res.status(200).send("Payment notification received");
  } catch (error) {
    console.error("Error processing payment notification:", error);
    next(error);
  }
};

// Get payment by ID
const getPaymentById = async (req, res, next) => {
  try {
    const payment = await Payment.findById(req.params.id);
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }
    res.status(200).json(payment);
  } catch (error) {
    next(error);
  }
};

// Get payment by order ID
const getPaymentByOrderId = async (req, res, next) => {
  try {
    const payment = await Payment.findOne({ orderId: req.params.orderId });
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }
    res.status(200).json(payment);
  } catch (error) {
    next(error);
  }
};

// Get payments by customer ID
const getPaymentsByCustomerId = async (req, res, next) => {
  try {
    const payments = await Payment.find({ customerId: req.params.customerId });
    res.status(200).json(payments);
  } catch (error) {
    next(error);
  }
};

// Process refund
const processRefund = async (req, res, next) => {
  try {
    const { paymentId, amount, reason } = req.body;
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }

    if (payment.status !== "completed") {
      return res
        .status(400)
        .json({ message: "Only completed payments can be refunded" });
    }

    // In a real implementation, you would call PayHere's refund API here
    // For sandbox, we'll just update the status
    payment.status = "refunded";
    await payment.save();

    // Notify order service about refund
    await notificationService.notifyOrderService(
      payment.orderId,
      "refunded",
      payment.paymentId
    );

    res.status(200).json({ message: "Refund processed successfully", payment });
  } catch (error) {
    next(error);
  }
};

const storePaymentDetails = async (req, res, next) => {
  try {
    const { orderId, paymentId, amount, status } = req.body;

    // Validate required fields
    if (!orderId || !paymentId || !amount || !status) {
      return res.status(400).json({
        message: "Missing required fields",
        required: ["orderId", "paymentId", "amount", "status"],
      });
    }

    // Extract bearer token
    const authHeader = req.headers.authorization;
    const token =
      authHeader && authHeader.startsWith("Bearer ")
        ? authHeader.split(" ")[1]
        : null;

    if (!token) {
      return res
        .status(401)
        .json({ message: "No valid authorization token provided" });
    }

    // Get user info using token
    let userInfo;
    try {
      const response = await axios.get(
        `${process.env.USER_SERVICE_URL}/api/users/me`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );
      userInfo = response.data.data.user;
    } catch (error) {
      console.error("Error fetching user info:", error);
      return res.status(401).json({ message: "Invalid or expired token" });
    }

    // Create or update payment record
    let payment = await Payment.findOne({ orderId });

    if (payment) {
      // Update existing payment
      payment.paymentId = paymentId;
      payment.status = status;
      payment.amount = amount;
      payment.paymentMethod = "card";
      payment.updatedAt = Date.now();
    } else {
      // Create new payment record
      payment = new Payment({
        orderId,
        customerId: userInfo.id, // Use ID from validated token
        paymentId,
        amount,
        currency: "LKR",
        status,
        paymentMethod: "card",
      });
    }

    const savedPayment = await payment.save();

    // Notify order service about payment status using internal API key
    await notificationService.notifyOrderService(orderId, status, paymentId);

    // Get updated order details
    const orderServiceResponse = await axios.get(
      `${process.env.ORDER_SERVICE_URL}/api/orders/${orderId}`,
      {
        headers: {
          "x-api-key": process.env.INTERNAL_API_KEY,
        },
      }
    );

    res.status(201).json({
      message: "Payment details stored successfully",
      payment: savedPayment,
      order: orderServiceResponse.data,
    });
  } catch (error) {
    console.error("Error storing payment details:", error);
    next(error);
  }
};

module.exports = {
  createPayment,
  processNotification,
  getPaymentById,
  getPaymentByOrderId,
  getPaymentsByCustomerId,
  processRefund,
  storePaymentDetails,
};


/* File: ./server\payment-service\models\Payment.js */
const mongoose = require("mongoose");

const paymentSchema = new mongoose.Schema({
  orderId: {
    type: String,
    required: true,
    unique: true,
  },
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: "User",
  },
  amount: {
    type: Number,
    required: true,
  },
  currency: {
    type: String,
    required: true,
    default: "LKR",
    enum: ["LKR"],
  },
  status: {
    type: String,
    enum: [
      "pending",
      "completed",
      "failed",
      "refunded",
      "cancelled",
      "chargedback",
    ],
    default: "pending",
  },
  paymentId: {
    type: String,
  },
  paymentMethod: {
    type: String,
  },
  statusCode: {
    type: String,
  },
  description: {
    type: String,
  },
  hash: {
    type: String,
  },
  md5sig: {
    type: String,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

paymentSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("Payment", paymentSchema);


/* File: ./server\payment-service\routes\paymentRoutes.js */
const express = require("express");
const router = express.Router();
const {
  createPayment,
  processNotification,
  getPaymentById,
  getPaymentByOrderId,
  getPaymentsByCustomerId,
  processRefund,
  storePaymentDetails,
} = require("../controllers/paymentController");
const authMiddleware = require("../utils/authMiddleware");

// Create a new payment (internal service call)
router.post(
  "/",
  authMiddleware(["customer", "restaurant_admin", "admin", "internal_service"]),
  createPayment
);

router.post(
  "/store",
  authMiddleware(["customer", "restaurant_admin", "admin", "internal_service"]),
  storePaymentDetails
);

// Process payment notification from PayHere (no auth - public endpoint)
router.post("/notify", processNotification);

// Get payment by ID
router.get(
  "/:id",
  authMiddleware(["customer", "restaurant_admin", "admin", "internal_service"]),
  getPaymentById
);

// Get payment by order ID
router.get(
  "/order/:orderId",
  authMiddleware(["customer", "restaurant_admin", "admin", "internal_service"]),
  getPaymentByOrderId
);

// Get payments by customer ID
router.get(
  "/customer/:customerId",
  authMiddleware(["customer", "admin", "internal_service"]),
  getPaymentsByCustomerId
);

// Process refund
router.post(
  "/refund",
  authMiddleware(["admin", "restaurant_admin", "internal_service"]),
  processRefund
);

module.exports = router;


/* File: ./server\payment-service\services\notificationService.js */
// Update ./server/payment-service/services/notificationService.js
const axios = require("axios");
require("dotenv").config();

const { ORDER_SERVICE_URL } = process.env;

module.exports = {
  notifyOrderService: async (orderId, paymentStatus, paymentId) => {
    try {
      // Add error handling for missing ORDER_SERVICE_URL
      if (!ORDER_SERVICE_URL) {
        console.error("ORDER_SERVICE_URL not defined in environment variables");
        return false;
      }

      // Use x-api-key instead of Bearer token for internal service communication
      await axios.post(
        `${ORDER_SERVICE_URL}/api/orders/${orderId}/payment-update`,
        {
          paymentStatus,
          paymentId,
        },
        {
          headers: {
            "x-api-key": process.env.INTERNAL_API_KEY,
          },
        }
      );
      console.log(
        `Order service notified about payment ${paymentStatus} for order ${orderId}`
      );
      return true;
    } catch (error) {
      console.error(
        `Error notifying order service about payment ${paymentStatus}:`,
        error.message
      );
      // Don't fail the whole process if notification fails
      return false;
    }
  },
};


/* File: ./server\payment-service\services\paymentService.js */
const crypto = require("crypto");
require("dotenv").config();

const MERCHANT_ID = process.env.PAYHERE_MERCHANT_ID;
const MERCHANT_SECRET = process.env.PAYHERE_MERCHANT_SECRET;
const PAYHERE_URL =
  process.env.NODE_ENV === "production"
    ? "https://www.payhere.lk/pay/checkout"
    : "https://sandbox.payhere.lk/pay/checkout";

const generateHash = (orderId, amount, currency) => {
  // Convert amount to string with 2 decimal places
  const amountStr = parseFloat(amount).toFixed(2);

  // Generate hash as per PayHere documentation
  return crypto
    .createHash("md5")
    .update(
      MERCHANT_ID +
        orderId +
        amountStr +
        currency +
        crypto
          .createHash("md5")
          .update(MERCHANT_SECRET)
          .digest("hex")
          .toUpperCase()
    )
    .digest("hex")
    .toUpperCase();
};

const verifyPaymentSignature = (
  merchantId,
  orderId,
  amount,
  currency,
  statusCode,
  receivedMd5sig
) => {
  try {
    // Convert amount to string with 2 decimal places
    const amountStr = parseFloat(amount).toFixed(2);

    // Generate local md5sig for verification
    const localMd5sig = crypto
      .createHash("md5")
      .update(
        merchantId +
          orderId +
          amountStr +
          currency +
          statusCode +
          crypto
            .createHash("md5")
            .update(MERCHANT_SECRET)
            .digest("hex")
            .toUpperCase()
      )
      .digest("hex")
      .toUpperCase();

    // Compare local signature with received signature
    return localMd5sig === receivedMd5sig;
  } catch (error) {
    console.error("Error verifying payment signature:", error);
    return false;
  }
};

const generatePaymentParams = (
  orderId,
  amount,
  currency,
  description,
  customerId,
  customerInfo,
  paymentMethod
) => {
  // Generate hash
  const hash = generateHash(orderId, amount, currency);

  // Prepare payment parameters
  return {
    merchant_id: MERCHANT_ID,
    return_url: process.env.PAYHERE_RETURN_URL,
    cancel_url: process.env.PAYHERE_CANCEL_URL,
    notify_url: process.env.PAYHERE_NOTIFY_URL,
    order_id: orderId,
    currency: currency,
    amount: parseFloat(amount).toFixed(2),
    first_name:
      customerInfo?.firstName ||
      customerInfo?.name?.split(" ")[0] ||
      "Customer",
    last_name:
      customerInfo?.lastName ||
      customerInfo?.name?.split(" ").slice(1).join(" ") ||
      "",
    email: customerInfo?.email || "customer@example.com",
    phone: customerInfo?.phone || "0000000000",
    address: customerInfo?.address || "N/A",
    city: customerInfo?.city || "Colombo",
    country: customerInfo?.country || "Sri Lanka",
    hash: hash,
    payment_method: paymentMethod,
  };
};

const getPaymentUrl = (params) => {
  // Convert params to URL query string
  const queryString = Object.entries(params)
    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
    .join("&");

  return `${PAYHERE_URL}?${queryString}`;
};

module.exports = {
  generateHash,
  verifyPaymentSignature,
  generatePaymentParams,
  getPaymentUrl,
  MERCHANT_ID,
  PAYHERE_URL,
};


/* File: ./server\payment-service\utils\authMiddleware.js */
const jwt = require("jsonwebtoken");
const mongoose = require("mongoose");
require("dotenv").config();

module.exports = (allowedRoles) => {
  return (req, res, next) => {
    // First check for internal API key
    if (req.headers["x-api-key"] === process.env.INTERNAL_API_KEY) {
      // For internal service calls, create a valid ObjectId instead of "system"

      console.log(req.headers["x-api-key"]);
      req.user = {
        id: new mongoose.Types.ObjectId("000000000000000000000000"),
        role: "internal_service",
      };

      // Check if internal_service role is allowed
      if (!allowedRoles.includes("internal_service")) {
        return res
          .status(403)
          .json({ message: "Insufficient permissions for internal service" });
      }

      return next();
    }

    // If no internal API key, proceed with JWT authentication
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "Authentication required" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;

      if (!allowedRoles.includes(decoded.role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      next();
    } catch (error) {
      return res.status(401).json({ message: "Invalid token" });
    }
  };
};


/* File: ./server\payment-service\utils\errorHandler.js */
module.exports = (err, req, res, next) => {
  console.error(err.stack);

  if (err.name === "ValidationError") {
    return res.status(400).json({
      message: "Validation error",
      details: err.message,
    });
  }

  if (err.isAxiosError) {
    return res.status(502).json({
      message: "Error communicating with dependent service",
      details: err.message,
    });
  }

  res.status(500).json({ message: "Something went wrong" });
};


/* File: ./server\restaurant-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const dotenv = require("dotenv");
const restaurantRoutes = require("./routes/restaurantRoutes");
const rateLimiter = require("./utils/rateLimiter");
const errorHandler = require("./utils/errorHandler");
const cors = require("cors");
const http = require("http"); // Import HTTP to create server
const socketIo = require("socket.io"); // Import socket.io for WebSocket

dotenv.config(); // Load environment variables

const app = express();
const PORT = process.env.PORT || 3001;

// Create HTTP server for Express app and Socket.IO
const httpServer = http.createServer(app);

// Initialize Socket.IO with the HTTP server
const io = socketIo(httpServer);

// Middleware setup
app.use(express.json()); // Parse JSON request bodies
app.use(cors()); // Enable cross-origin requests
app.use(rateLimiter); // Apply rate limiting

app.use("/uploads", express.static("uploads"));

// Routes
app.use("/api/restaurants", restaurantRoutes);

// MongoDB Connection
mongoose
  .connect(process.env.DB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Connected to MongoDB");
  })
  .catch((err) => {
    console.error("MongoDB connection error:", err);
  });

// Error handling middleware
app.use(errorHandler);

// Real-time communication with Socket.IO
io.on("connection", (socket) => {
  console.log("A user connected");
  socket.on("disconnect", () => {
    console.log("A user disconnected");
  });
});

// Start the server and listen for incoming requests
httpServer.listen(PORT, () => {
  console.log(`Restaurant Service running on port ${PORT}`);
});


/* File: ./server\restaurant-service\config\dbConfig.js */
const mongoose = require('mongoose');

const connectDB = () => {
  mongoose.connect(process.env.DB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  }).then(() => {
    console.log('MongoDB Connected');
  }).catch((err) => {
    console.error('DB Connection Failed', err);
  });
};

module.exports = connectDB;

/* File: ./server\restaurant-service\config\multerConfig.js */
const multer = require('multer');
const path = require('path');

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const { name, menu } = req.body;
    
    try {
      // Parse menu if it's a string (from form-data)
      const parsedMenu = typeof menu === 'string' ? JSON.parse(menu) : (menu || []);
      
      if (file.fieldname === 'coverImage') {
        // Handle cover image filename
        const cleanName = name ? name.replace(/\s+/g, '_').toLowerCase() : 'restaurant';
        cb(null, `${cleanName}_cover_${Date.now()}${path.extname(file.originalname)}`);
      } 
      else if (file.fieldname === 'menuItemImages') {
        // Handle menu item images
        const index = req.files['menuItemImages']?.indexOf(file) || 0;
        const itemName = parsedMenu[index]?.name || `item_${index}`;
        cb(null, `${itemName.replace(/\s+/g, '_').toLowerCase()}_${Date.now()}${path.extname(file.originalname)}`);
      } 
      else {
        // Default filename
        cb(null, `${Date.now()}${path.extname(file.originalname)}`);
      }
    } catch (err) {
      console.error('Error generating filename:', err);
      cb(null, `${Date.now()}${path.extname(file.originalname)}`);
    }
  }
});

const fileFilter = (req, file, cb) => {
  const filetypes = /jpeg|jpg|png/;
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = filetypes.test(file.mimetype);

  if (extname && mimetype) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only jpg, jpeg, and png are allowed.'));
  }
};

const upload = multer({ 
  storage, 
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  }
});

module.exports = upload;

/* File: ./server\restaurant-service\controllers\restaurantController.js */
const axios = require("axios");
const mongoose = require("mongoose");
const path = require("path");
const Restaurant = require("../models/restaurantModel");
const { calculateDistance } = require("../utils/geolocation");
const upload = require("../config/multerConfig");

const addRestaurant = async (req, res) => {
  console.log("Request body:", req.body); // Debugging log
  console.log("Request files:", req.files); // Debugging log

  try {
    // Parse the incoming data (handling both stringified and direct objects)
    const name = req.body.name;
    const description = req.body.description;

    const address =
      typeof req.body.address === "string"
        ? JSON.parse(req.body.address)
        : req.body.address;

    const operatingHours =
      typeof req.body.operatingHours === "string"
        ? JSON.parse(req.body.operatingHours)
        : req.body.operatingHours;

    let menu = [];
    try {
      menu =
        typeof req.body.menu === "string"
          ? JSON.parse(req.body.menu)
          : req.body.menu || [];

      if (!Array.isArray(menu)) {
        throw new Error("Menu must be an array");
      }
    } catch (err) {
      console.error("Error parsing menu:", err);
      return res.status(400).json({ message: "Invalid menu format" });
    }

    // Validate required fields
    if (!name || !address) {
      return res.status(400).json({
        message: "Name and address are required",
        details: {
          received: { name, address },
        },
      });
    }

    // Validate address structure
    if (
      !address.geoCoordinates ||
      typeof address.geoCoordinates !== "object" ||
      isNaN(parseFloat(address.geoCoordinates.longitude)) ||
      isNaN(parseFloat(address.geoCoordinates.latitude))
    ) {
      return res.status(400).json({
        message: "Valid geo coordinates are required",
        details: {
          receivedCoordinates: address.geoCoordinates,
        },
      });
    }

    // Check if restaurant already exists
    const existingRestaurant = await Restaurant.findOne({ name });
    if (existingRestaurant) {
      return res.status(400).json({
        message: "Restaurant already exists",
        existingId: existingRestaurant._id,
      });
    }

    // Handle file uploads
    const coverImage = req.files?.coverImage?.[0]?.path || null;
    const menuItemImages = req.files?.menuItemImages || [];

    // Validate menu items match uploaded images
    if (menuItemImages.length > 0 && menuItemImages.length !== menu.length) {
      console.warn(
        `Mismatch: ${menuItemImages.length} images for ${menu.length} menu items`
      );
    }

    // Create new restaurant with proper data types
    const newRestaurant = new Restaurant({
      name: name.trim(),
      description: description ? description.trim() : "",
      address: {
        street: address.street ? address.street.trim() : "",
        city: address.city ? address.city.trim() : "",
        country: address.country ? address.country.trim() : "",
        geoCoordinates: {
          type: "Point",
          coordinates: [
            parseFloat(address.geoCoordinates.longitude),
            parseFloat(address.geoCoordinates.latitude),
          ],
        },
      },
      menu: menu.map((item, index) => ({
        name: item.name ? item.name.trim() : `Item ${index + 1}`,
        description: item.description ? item.description.trim() : "",
        price: parseFloat(item.price) || 0,
        category: item.category ? item.category.trim() : "other",
        image: menuItemImages[index]?.path || null,
      })),
      operatingHours: {
        from: operatingHours?.from || "09:00",
        to: operatingHours?.to || "21:00",
      },
      availability: true,
      coverImage,
    });

    // Validate the restaurant document before saving
    const validationError = newRestaurant.validateSync();
    if (validationError) {
      return res.status(400).json({
        message: "Validation failed",
        error: validationError.message,
        details: validationError.errors,
      });
    }

    await newRestaurant.save();

    res.status(201).json({
      status: "success",
      data: {
        restaurant: newRestaurant,
      },
    });
  } catch (err) {
    console.error("Error creating restaurant:", err);

    // Handle duplicate key errors separately
    if (err.code === 11000) {
      return res.status(400).json({
        message: "Restaurant with this name already exists",
        error: err.message,
      });
    }

    // Handle validation errors
    if (err.name === "ValidationError") {
      return res.status(400).json({
        message: "Validation failed",
        error: err.message,
        details: err.errors,
      });
    }

    res.status(500).json({
      message: "Error creating restaurant",
      error: err.message,
      stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

// Get all restaurants within a certain radius (nearby restaurants)
const getNearbyRestaurants = async (req, res) => {
  const { longitude, latitude, radius } = req.query;

  try {
    // Check if valid coordinates are provided
    const isValidCoordinates =
      longitude &&
      latitude &&
      !isNaN(parseFloat(longitude)) &&
      !isNaN(parseFloat(latitude));

    if (isValidCoordinates) {
      // Try to get nearby restaurants first with distance filter
      let restaurants = await Restaurant.aggregate([
        {
          $geoNear: {
            near: {
              type: "Point",
              coordinates: [parseFloat(longitude), parseFloat(latitude)],
            },
            distanceField: "distance",
            maxDistance: parseFloat(radius) * 1000, // Convert to meters
            spherical: true,
            includeLocs: "address.geoCoordinates",
          },
        },
        {
          $project: {
            name: 1,
            description: 1,
            coverImage: 1,
            menu: 1,
            availability: 1,
            operatingHours: 1,
            distance: 1,
          },
        },
      ]);

      // If no nearby restaurants found, get all restaurants with distance calculation
      // This maintains the same format as nearby restaurants
      if (restaurants.length === 0) {
        console.log(
          "No nearby restaurants found, getting all restaurants with distance"
        );
        restaurants = await Restaurant.aggregate([
          {
            $geoNear: {
              near: {
                type: "Point",
                coordinates: [parseFloat(longitude), parseFloat(latitude)],
              },
              distanceField: "distance",
              // No maxDistance filter here - return all restaurants
              spherical: true,
              includeLocs: "address.geoCoordinates",
            },
          },
          {
            $project: {
              name: 1,
              description: 1,
              coverImage: 1,
              menu: 1,
              availability: 1,
              operatingHours: 1,
              distance: 1,
            },
          },
        ]);
      }

      if (restaurants.length === 0) {
        return res.status(404).json({ message: "No restaurants found" });
      }

      return res.status(200).json(restaurants);
    } else {
      // If coordinates are not valid, just return all restaurants without distance
      const allRestaurants = await Restaurant.find(
        {},
        {
          name: 1,
          description: 1,
          coverImage: 1,
          menu: 1,
          availability: 1,
          operatingHours: 1,
        }
      );

      if (allRestaurants.length === 0) {
        return res.status(404).json({ message: "No restaurants found" });
      }

      // Add null distance field for format consistency
      const formattedRestaurants = allRestaurants.map((restaurant) => {
        const restaurantObj = restaurant.toObject();
        restaurantObj.distance = null;
        return restaurantObj;
      });

      return res.status(200).json(formattedRestaurants);
    }
  } catch (err) {
    console.error("Error fetching restaurants:", err);
    res.status(500).json({ message: "Error fetching restaurants", err });
  }
};

// Update restaurant availability
const toggleAvailability = async (req, res) => {
  const { id } = req.params;
  try {
    const restaurant = await Restaurant.findById(id);
    if (!restaurant) {
      console.error("Error fetching restaurant tog:", err);
      return res.status(404).json({ message: "Restaurant not found" });
    }

    restaurant.availability = !restaurant.availability; // Toggle availability
    await restaurant.save();

    res
      .status(200)
      .json({ message: "Restaurant availability updated", restaurant });
  } catch (err) {
    res.status(500).json({ message: "Error updating availability", err });
  }
};

// Get restaurant availability status
const getRestaurantAvailability = async (req, res) => {
  try {
    const { id } = req.params;
    const restaurant = await Restaurant.findById(id);

    if (!restaurant) {
      console.error("Error fetching restaurant aval:", err);
      return res.status(404).json({ message: "Restaurant not found" });
    }

    res.status(200).json({
      restaurantId: restaurant._id,
      isAvailable: restaurant.availability,
    });
  } catch (err) {
    res
      .status(500)
      .json({ message: "Error checking restaurant availability", err });
  }
};

// Get restaurant by ID
const getRestaurantById = async (req, res) => {
  const { id } = req.params;

  // 1. Validate ObjectId
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({
      status: "fail",
      message: "Invalid restaurant ID format",
    });
  }

  try {
    console.log("Fetching restaurant with ID:", req.params.id);
    const restaurant = await Restaurant.findById(req.params.id);
    console.log("Fetched restaurant:", restaurant);

    if (!restaurant) {
      console.log("Restaurant not found");
      return res.status(404).json({ message: "Restaurant not found" });
    }

    res.status(200).json({
      restaurant,
    });
  } catch (err) {
    console.error("Error verifying restaurant:", err);
    res.status(500).json({
      status: "error",
      message: "Error verifying restaurant",
    });
  }
};

// Verify Restaurant Existence
const verifyRestaurant = async (req, res) => {
  const { restaurantId } = req.params;

  if (!mongoose.Types.ObjectId.isValid(restaurantId)) {
    return res.status(400).json({
      status: "fail",
      message: "Invalid restaurant ID format",
    });
  }

  try {
    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({
        status: "fail",
        message: "Restaurant not found",
      });
    }

    res.status(200).json({
      status: "success",
      data: {
        exists: true,
        restaurant: {
          id: restaurant._id,
          name: restaurant.name,
        },
      },
    });
  } catch (err) {
    console.error("Error verifying restaurant:", err);
    res.status(500).json({
      status: "error",
      message: "Error verifying restaurant",
    });
  }
};

//get all restaurants
const getAllRestaurants = async (req, res) => {
  try {
    // Fetch all restaurants from the database
    const restaurants = await Restaurant.find(); // You can add query filters if needed

    if (restaurants.length === 0) {
      return res.status(404).json({ message: "No restaurants found" });
    }

    res.status(200).json({
      status: "success",
      data: {
        restaurants, // Return the list of restaurants
      },
    });
  } catch (err) {
    console.error("Error fetching restaurants:", err);
    res.status(500).json({ message: "Error fetching restaurants", err });
  }
};

// Add menu item to restaurant
const addMenuItem = async (req, res) => {
  try {
    const { restaurantId } = req.params;
    const menuItem = req.body;
    const menuItemImage = req.file
      ? path
          .join("uploads", "menu-items", req.file.filename)
          .replace(/\\/g, "/")
      : null;

    // Validate required fields
    if (!menuItem.name || !menuItem.price) {
      return res.status(400).json({
        status: "fail",
        message: "Name and price are required for menu items",
      });
    }

    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({
        status: "fail",
        message: "Restaurant not found",
      });
    }

    const newItem = {
      ...menuItem,
      _id: new mongoose.Types.ObjectId(),
      image: menuItemImage,
      price: parseFloat(menuItem.price),
    };

    restaurant.menu.push(newItem);
    const updatedRestaurant = await restaurant.save();

    return res.status(201).json({
      status: "success",
      data: {
        menuItem: updatedRestaurant.menu.slice(-1)[0],
      },
    });
  } catch (err) {
    console.error("Error in addMenuItem:", err);
    return res.status(500).json({
      status: "error",
      message: "Internal server error",
      error: err.message,
      stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

// Update menu item
const updateMenuItem = async (req, res) => {
  try {
    const { restaurantId, menuItemId } = req.params;
    const menuItem = req.body;
    const menuItemImage = req.file
      ? path
          .join("uploads", "menu-items", req.file.filename)
          .replace(/\\/g, "/")
      : null;

    // Validate required fields
    if (!menuItem.name || !menuItem.price) {
      return res.status(400).json({
        status: "fail",
        message: "Name and price are required for menu items",
      });
    }

    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({
        status: "fail",
        message: "Restaurant not found",
      });
    }

    const itemIndex = restaurant.menu.findIndex(
      (item) => item._id.toString() === menuItemId
    );
    if (itemIndex === -1) {
      return res.status(404).json({
        status: "fail",
        message: "Menu item not found",
      });
    }

    restaurant.menu[itemIndex] = {
      ...restaurant.menu[itemIndex],
      ...menuItem,
      price: parseFloat(menuItem.price),
      image: menuItemImage || restaurant.menu[itemIndex].image,
    };

    const updatedRestaurant = await restaurant.save();
    return res.status(200).json({
      status: "success",
      data: {
        menuItem: updatedRestaurant.menu[itemIndex],
      },
    });
  } catch (err) {
    console.error("Error in updateMenuItem:", err);
    return res.status(500).json({
      status: "error",
      message: "Internal server error",
      error: err.message,
      stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

// Delete menu item
const deleteMenuItem = async (req, res) => {
  try {
    const { restaurantId, menuItemId } = req.params;

    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({
        status: "fail",
        message: "Restaurant not found",
      });
    }

    const initialLength = restaurant.menu.length;
    restaurant.menu = restaurant.menu.filter(
      (item) => item._id.toString() !== menuItemId
    );

    if (restaurant.menu.length === initialLength) {
      return res.status(404).json({
        status: "fail",
        message: "Menu item not found",
      });
    }

    await restaurant.save();
    return res.status(204).json({
      status: "success",
      data: null,
    });
  } catch (err) {
    console.error("Error in deleteMenuItem:", err);
    return res.status(500).json({
      status: "error",
      message: "Internal server error",
      error: err.message,
      stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

// Search restaurants by filters (cuisine, price, rating)
const searchRestaurants = async (req, res) => {
  const { cuisine, priceRange, rating } = req.query;

  try {
    const query = {};

    if (cuisine) query["menu.category"] = cuisine;
    if (priceRange) query["menu.price"] = { $lte: priceRange };
    if (rating) query["rating"] = { $gte: rating };

    const restaurants = await Restaurant.find(query);
    res.status(200).json(restaurants);
  } catch (err) {
    res.status(500).json({ message: "Error searching restaurants", err });
  }
};

module.exports = {
  addRestaurant,
  getNearbyRestaurants,
  toggleAvailability,
  getRestaurantAvailability,
  getRestaurantById,
  verifyRestaurant,
  getAllRestaurants,
  addMenuItem,
  updateMenuItem,
  deleteMenuItem,
  searchRestaurants,
};


/* File: ./server\restaurant-service\middleware\authMiddleware.js */
// restaurant-service/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');

const verifyToken = (roles = []) => {
  return async (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }

    try {
      // Verify token directly (no API call needed)
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Attach user info from token
      req.user = {
        id: decoded.id,
        role: decoded.role
      };

      // Check if user has required role
      if (roles.length && !roles.includes(decoded.role)) {
        return res.status(403).json({ message: 'Insufficient permissions' });
      }

      next();
    } catch (err) {
      console.error('Token verification error:', err);
      return res.status(401).json({ message: 'Invalid token' });
    }
  };
};

module.exports = verifyToken;

/* File: ./server\restaurant-service\models\restaurantModel.js */
const mongoose = require('mongoose');

const menuItemSchema = new mongoose.Schema({
  name: String,
  description: String,
  price: Number,
  category: String,
  image: String, // menu item image
});

const restaurantSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  description: String,
  address: {
    street: String,
    city: String,
    country: String,
    geoCoordinates: {
      type: { type: String, default: 'Point' },
      coordinates: [Number], // [longitude, latitude]
    },
  },
  menu: [menuItemSchema],
  availability: { type: Boolean, default: true },
  operatingHours: {
    from: { type: String },
    to: { type: String },
  },
  rating: { type: Number, default: 0 },
  coverImage: String, // restaurant cover image
});

restaurantSchema.index({ 'address.geoCoordinates': '2dsphere' });

const Restaurant = mongoose.model('Restaurant', restaurantSchema);

module.exports = Restaurant;

/* File: ./server\restaurant-service\routes\restaurantRoutes.js */
const express = require("express");
const router = express.Router();
const restaurantController = require("../controllers/restaurantController");
const verifyToken = require("../middleware/authMiddleware");
const upload = require("../config/multerConfig");

const uploadFields = upload.fields([
    { name: 'coverImage', maxCount: 1 },
    { name: 'menuItemImages', maxCount: 10 } // Adjust as needed
  ]);

// Add a new restaurant should have verifyToken
router.post('/', 
    (req, res, next) => {
        // Log incoming request for debugging
        console.log('Incoming restaurant data:', req.body);
        next();
    },
    uploadFields, 
    verifyToken(['admin', 'super_admin']), 
    restaurantController.addRestaurant
    );

// Get nearby restaurants
router.get("/nearby", restaurantController.getNearbyRestaurants);

// Add this near the top with other routes
router.get('/verify/:restaurantId', 
    restaurantController.verifyRestaurant
  );

// get by id
router.get("/:id", restaurantController.getRestaurantById);

// Update restaurant availability should have verifyToken
router.put("/:id/availability", restaurantController.toggleAvailability);

router.get("/", restaurantController.getAllRestaurants); // Add this route to get all restaurants

// Get restaurant availability (public)
router.get("/:id/availability", restaurantController.getRestaurantAvailability);

// Get restaurant details by ID (public)
//router.get("/:id", restaurantController.getRestaurantById);

// Menu Item Management Routes
router.post(
  "/:restaurantId/menu",
  upload.single("menuItemImage"),
  verifyToken(['admin', 'restaurant_admin']),
  restaurantController.addMenuItem
);

router.put(
  "/:restaurantId/menu/:menuItemId",
  upload.single("menuItemImage"),
  verifyToken(['admin', 'restaurant_admin']),
  restaurantController.updateMenuItem
);

router.delete(
  "/:restaurantId/menu/:menuItemId",
  verifyToken(['admin', 'restaurant_admin']),
  restaurantController.deleteMenuItem
);

// search restaurants
router.get("/search", restaurantController.searchRestaurants);

module.exports = router;


/* File: ./server\restaurant-service\utils\errorHandler.js */
const errorHandler = (err, req, res, next) => {
    const statusCode = err.statusCode || 500;
    const message = err.message || 'Internal Server Error';
    res.status(statusCode).json({ message });
  };
  
  module.exports = errorHandler;  

/* File: ./server\restaurant-service\utils\geolocation.js */
const geolib = require('geolib');

// Function to calculate the distance between two geo-coordinates
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  return geolib.getDistance(
    { latitude: lat1, longitude: lon1 },
    { latitude: lat2, longitude: lon2 }
  );
};

module.exports = { calculateDistance };

/* File: ./server\restaurant-service\utils\rateLimiter.js */
const rateLimit = require('express-rate-limit');

// Apply a rate limit of 100 requests per 1 minute per IP address
const rateLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 100,                 // Limit each IP to 100 requests per windowMs
  message: "Too many requests, please try again later.", // Custom error message
});

module.exports = rateLimiter;

/* File: ./server\user-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const morgan = require("morgan");
const connectDB = require("./config/db");
const userRoutes = require("./routes/userRoutes");
const errorHandler = require("./utils/errorHandler");
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan("dev"));

// Database connection
connectDB();

// Update CORS middleware
app.use(cors());

// Routes
app.use("/api/users", userRoutes);

app.get("/api/health", (req, res) => {
  res.status(200).json({ status: "OK", timestamp: new Date() });
});

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 3000;
app.listen(PORT, "0.0.0.0", () => {
  console.log("Server running on port 3000");
});

module.exports = app;


/* File: ./server\user-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("MongoDB connected successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server\user-service\controllers\userController.js */
const User = require("../models/User");
const jwt = require("jsonwebtoken");
const mongoose = require("mongoose");
const authService = require("../services/authService");
const { sendEmail } = require("../services/emailService");
const passwordUtils = require("../utils/passwordUtils");
const axios = require("axios");
const { JWT_SECRET, JWT_EXPIRES_IN } = process.env;
const amqp = require("amqplib/callback_api");

// ==================== TOKEN VERIFICATION ====================
const verifyToken = async (req, res, next) => {
  try {
    // Get token from header

    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Get user from database
    const user = await User.findById(decoded.id).select("-password");

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Return user information
    res.status(200).json({
      status: "success",
      data: {
        id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isActive: user.isActive,
        // Include any other relevant user info
      },
    });
  } catch (error) {
    if (error.name === "JsonWebTokenError") {
      return res.status(401).json({ message: "Invalid token" });
    }
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ message: "Token expired" });
    }
    next(error);
  }
};

// ==================== ADMIN METHODS ====================
const createAdmin = async (req, res, next) => {
  try {
    // Only super admin can create other admins
    if (req.user.role !== "admin" || !req.user.isSuperAdmin) {
      return res
        .status(403)
        .json({ message: "Not authorized to create admins" });
    }

    const { name, email, phone, password } = req.body;

    const admin = await User.create({
      name,
      email,
      phone,
      password: await passwordUtils.hashPassword(password),
      role: "admin",
      isActive: true,
      emailVerified: true,
      phoneVerified: true,
    });

    res.status(201).json({
      status: "success",
      data: {
        user: admin,
      },
    });
  } catch (error) {
    next(error);
  }
};

// ==================== RESTAURANT ADMIN METHODS ====================

// Create a new Restaurant Admin
const createRestaurantAdmin = async (req, res, next) => {
  try {
    console.log("Incoming request body:", req.body); // Log the entire request
    const { name, email, phone, password, restaurantId } = req.body;

    // Validate required fields
    if (!name || !email || !phone || !restaurantId) {
      return res.status(400).json({
        status: "fail",
        message: "Name, email, phone and restaurantId are required",
      });
    }

    // Validate restaurant exists (call restaurant service)
    try {
      const restaurantResponse = await axios.get(
        `${process.env.RESTAURANT_SERVICE_URL}/api/restaurants/verify/${restaurantId}`,
        {
          headers: {
            Authorization: req.headers.authorization,
          },
        }
      );

      if (
        !restaurantResponse.data ||
        restaurantResponse.data.status !== "success"
      ) {
        return res.status(404).json({
          status: "fail",
          message: "Restaurant not found",
        });
      }
    } catch (err) {
      console.error("Error verifying restaurant:", err);
      return res.status(404).json({
        status: "fail",
        message: "Restaurant verification failed",
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ $or: [{ email }, { phone }] });
    if (existingUser) {
      return res.status(400).json({
        status: "fail",
        message: "Email or phone already in use",
      });
    }

    // Generate password if not provided
    const adminPassword = password || passwordUtils.generateRandomPassword();

    // Create the restaurant admin
    const restaurantAdmin = await User.create({
      name,
      email,
      phone,
      password: await passwordUtils.hashPassword(adminPassword),
      role: "restaurant_admin",
      isActive: true,
      restaurantId: new mongoose.Types.ObjectId(restaurantId),
      emailVerified: true,
      phoneVerified: true,
    });

    // Remove sensitive data before sending response
    restaurantAdmin.password = undefined;

    // Send welcome email
    try {
      await sendEmail(
        email,
        "Welcome as Restaurant Admin",
        `Hello ${name},\n\nYou have been assigned as the admin for restaurant ${restaurantId}.\n\nYour login credentials:\nEmail: ${email}\nPassword: ${adminPassword}`
      );
    } catch (emailError) {
      console.error("Failed to send welcome email:", emailError);
    }

    res.status(201).json({
      status: "success",
      data: {
        user: restaurantAdmin,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get Admins by Restaurant
const getAdminsByRestaurant = async (req, res, next) => {
  try {
    const { restaurantId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(restaurantId)) {
      return res.status(400).json({
        status: "fail",
        message: "Invalid restaurant ID format",
      });
    }

    const admins = await User.find({
      role: "restaurant_admin",
      restaurantId: new mongoose.Types.ObjectId(restaurantId),
    }).select("-password -__v");

    res.status(200).json({
      status: "success",
      results: admins.length,
      data: {
        admins,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Remove Restaurant Admin
const removeRestaurantAdmin = async (req, res, next) => {
  try {
    const { adminId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(adminId)) {
      return res.status(400).json({
        status: "fail",
        message: "Invalid admin ID format",
      });
    }

    const admin = await User.findOneAndDelete({
      _id: adminId,
      role: "restaurant_admin",
    });

    if (!admin) {
      return res.status(404).json({
        status: "fail",
        message: "Restaurant admin not found",
      });
    }

    res.status(204).json({
      status: "success",
      data: null,
    });
  } catch (error) {
    next(error);
  }
};

// const requestRestaurantAdminAccess = async (req, res, next) => {
//   try {
//     const { name, email, phone, restaurantName, licenseNumber, address } =
//       req.body;

//     const existingUser = await User.findOne({ $or: [{ email }, { phone }] });
//     if (existingUser) {
//       return res.status(400).json({ message: "Email or phone already in use" });
//     }

//     const restaurantAdmin = await User.create({
//       name,
//       email,
//       phone,
//       role: "restaurant_admin",
//       isActive: false,
//       status: "pending",
//       phoneVerified: true, // Automatically verify phone without OTP
//       restaurantDetails: {
//         name: restaurantName,
//         licenseNumber,
//         address,
//       },
//     });

//     if (email) {
//       await sendEmail(
//         restaurantAdmin.email,
//         "New restaurant admin request",
//         `New restaurant admin request from ${restaurantName}`
//       );
//     }
//     // // Notify super admin about new request
//     // await notificationService.sendAdminNotification(
//     //   "New restaurant admin request",
//     //   `New restaurant admin request from ${restaurantName}`
//     // );

//     res.status(201).json({
//       status: "success",
//       message: "Request submitted for approval",
//       data: {
//         user: {
//           _id: restaurantAdmin._id,
//           name: restaurantAdmin.name,
//           email: restaurantAdmin.email,
//         },
//       },
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// Approve Restaurant Admin
const approveRestaurantAdmin = async (req, res, next) => {
  try {
    const { userId, restaurantId } = req.body;

    const user = await User.findByIdAndUpdate(
      userId,
      {
        isActive: true,
        status: "approved",
        restaurantId,
        password: await passwordUtils.hashPassword(
          passwordUtils.generateRandomPassword()
        ),
      },
      { new: true }
    );

    if (email) {
      await sendEmail(
        user._id,
        user.email,
        "Your restaurant admin account has been approved"
      );
    }
    // Send welcome email with temporary password
    // await notificationService.sendWelcomeNotification(
    //   user._id,
    //   user.email,
    //   "Your restaurant admin account has been approved"
    // );

    res.status(200).json({
      status: "success",
      data: {
        user,
      },
    });
  } catch (error) {
    next(error);
  }
};

// ==================== CUSTOMER METHODS ====================
const registerCustomer = async (req, res, next) => {
  try {
    const { name, email, phone, password, address } = req.body;

    const existingUser = await User.findOne({ $or: [{ email }, { phone }] });
    if (existingUser) {
      return res.status(400).json({ message: "Email or phone already in use" });
    }

    const customer = await User.create({
      name,
      email,
      phone,
      password: await passwordUtils.hashPassword(password),
      role: "customer",
      address,
      isActive: true,
      phoneVerified: true,
    });

    // Generate JWT token
    const token = authService.generateToken(customer._id, customer.role);

    // Send welcome email (no OTP)
    if (email) {
      await sendEmail(
        customer.email,
        "Welcome to TastyTrail!",
        `Hello ${customer.name},\n\nThank you for registering at TastyTrail!`
      );
    }

    res.status(201).json({
      status: "success",
      token,
      data: {
        user: {
          _id: customer._id,
          name: customer.name,
          email: customer.email,
          role: customer.role,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// ==================== DELIVERY PERSONNEL METHODS ====================
// Function to register a new Delivery Person
const registerDeliveryPerson = async (req, res, next) => {
  try {
    const {
      name,
      password,
      phone,
      nicOrLicense,
      vehicleType,
      vehicleNumber,
      documents,
    } = req.body;

    // Check if the phone number is already in use
    const existingUser = await User.findOne({ phone });
    if (existingUser) {
      return res.status(400).json({ message: "Phone number already in use" });
    }

    // Create the new delivery person in the User model
    const deliveryPerson = await User.create({
      name,
      password: await passwordUtils.hashPassword(password),
      phone,
      role: "delivery_personnel",
      nicOrLicense,
      vehicleInfo: {
        type: vehicleType,
        number: vehicleNumber,
      },
      documents, // URL paths to the uploaded documents
      status: "pending", // Default status for delivery person (needs approval)
      isActive: false, // Default is inactive until approved
      phoneVerified: true, // Assuming phone is verified automatically
    });

    // Publish the event to RabbitMQ after the delivery person is created
    publishDeliveryPersonEvent(deliveryPerson);

    res.status(201).json({
      status: "success",
      message: "Delivery person registration submitted for approval",
      data: {
        user: {
          _id: deliveryPerson._id,
          password: deliveryPerson.password,
          name: deliveryPerson.name,
          phone: deliveryPerson.phone,
          status: deliveryPerson.status,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// Function to publish a message to RabbitMQ when a delivery person registers
const publishDeliveryPersonEvent = (deliveryPerson) => {
  amqp.connect("amqp://localhost", (error, connection) => {
    if (error) {
      throw error;
    }

    connection.createChannel((error, channel) => {
      if (error) {
        throw error;
      }

      const queue = "delivery_person_registered_queue"; // Queue for delivery person registration
      const message = JSON.stringify({
        deliveryPersonId: deliveryPerson._id,
        name: deliveryPerson.name,
        phone: deliveryPerson.phone,
        vehicleType: deliveryPerson.vehicleInfo.type,
        vehicleLicensePlate: deliveryPerson.vehicleInfo.number,
      });

      // Make sure the queue exists and then publish the message
      channel.assertQueue(queue, { durable: true });
      channel.sendToQueue(queue, Buffer.from(message), { persistent: true });

      console.log(`Published delivery person registration event: ${message}`);
    });

    setTimeout(() => {
      connection.close();
    }, 500);
  });
};

module.exports = {
  registerDeliveryPerson,
  // other methods...
};

const approveDeliveryPerson = async (req, res, next) => {
  try {
    const { userId } = req.body;

    const tempPassword = passwordUtils.generateRandomPassword();
    const deliveryPerson = await User.findByIdAndUpdate(
      userId,
      {
        isActive: true,
        status: "approved",
        password: await passwordUtils.hashPassword(tempPassword),
      },
      { new: true }
    );

    // // Send approval notification with temporary password
    // await notificationService.sendSMSNotification(
    //   deliveryPerson.phone,
    //   `Your delivery account has been approved. Temporary password: ${tempPassword}`
    // );

    res.status(200).json({
      status: "success",
      data: {
        user: deliveryPerson,
      },
    });
  } catch (error) {
    next(error);
  }
};

// ==================== COMMON METHODS ====================
const login = async (req, res, next) => {
  try {
    const { email, phone, password } = req.body;

    // Find user by email or phone
    let user;
    if (email) {
      user = await User.findOne({ email }).select("+password");
    } else if (phone) {
      user = await User.findOne({ phone }).select("+password");
    } else {
      return res.status(400).json({ message: "Email or phone required" });
    }

    if (
      !user ||
      !(await passwordUtils.comparePassword(password, user.password))
    ) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    // Check if user is active
    if (!user.isActive) {
      return res.status(403).json({
        message: "Account not active",
        details:
          user.role === "delivery_personnel"
            ? "Pending admin approval"
            : "Account deactivated",
      });
    }

    // Role-specific checks
    if (user.role === "restaurant_admin" && !user.restaurantId) {
      return res
        .status(403)
        .json({ message: "Restaurant admin not assigned to a restaurant" });
    }

    // Generate JWT token
    const token = authService.generateToken(user._id, user.role);

    res.status(200).json({
      status: "success",
      token,
      data: {
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          phone: user.phone,
          role: user.role,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// Update user profile
const updateMe = async (req, res, next) => {
  try {
    // Filter out unwanted fields
    const filteredBody = {};
    const allowedFields = ["name", "email", "phone", "address"];
    allowedFields.forEach((field) => {
      if (req.body[field]) filteredBody[field] = req.body[field];
    });

    const updatedUser = await User.findByIdAndUpdate(
      req.user.id,
      filteredBody,
      { new: true, runValidators: true }
    );

    res.status(200).json({
      status: "success",
      data: {
        user: updatedUser,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get all users (admin only)
const getAllUsers = async (req, res, next) => {
  try {
    const users = await User.find();
    res.status(200).json({
      status: "success",
      results: users.length,
      data: {
        users,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get user by ID (admin only)
const getUser = async (req, res, next) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(200).json({
      status: "success",
      data: {
        user,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get current user profile
const getMe = async (req, res, next) => {
  try {
    if (!mongoose.Types.ObjectId.isValid(req.user.id)) {
      return res.status(400).json({ message: "Invalid user ID format" });
    }

    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ message: "User not found" });

    res.status(200).json({ status: "success", data: { user } });
  } catch (error) {
    next(error);
  }
};

// Update user (admin only)
const updateUser = async (req, res, next) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(200).json({
      status: "success",
      data: {
        user: updatedUser,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Delete user (admin only)
const deleteUser = async (req, res, next) => {
  try {
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { isActive: false },
      { new: true }
    );
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(204).json({
      status: "success",
      data: null,
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  verifyToken,
  // Admin methods
  createAdmin,

  // Restaurant admin methods
  // requestRestaurantAdminAccess,
  approveRestaurantAdmin,
  createRestaurantAdmin,
  getAdminsByRestaurant,
  removeRestaurantAdmin,

  // Customer methods
  registerCustomer,

  // Delivery methods
  registerDeliveryPerson,
  approveDeliveryPerson,

  // Common methods
  login,
  getMe,
  updateMe,
  getAllUsers,
  getUser,
  updateUser,
  deleteUser,
};


/* File: ./server\user-service\models\User.js */
const mongoose = require("mongoose");
const validator = require("validator");

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, "Please provide your name"],
    trim: true,
  },
  email: {
    type: String,
    required: function () {
      return this.role !== "delivery_personnel"; // Delivery can register with phone only
    },
    lowercase: true,
    validate: [validator.isEmail, "Please provide a valid email"],
  },
  phone: {
    type: String,
    required: [true, "Please provide your phone number"],
    unique: true,
    validate: {
      validator: function (v) {
        return /^\+?[\d\s-]{10,}$/.test(v);
      },
      message: (props) => `${props.value} is not a valid phone number!`,
    },
  },
  password: {
    type: String,
    minlength: 8,
    select: false,
  },
  role: {
    type: String,
    enum: ["customer", "restaurant_admin", "delivery_personnel", "admin"],
    default: "customer",
  },
  address: {
    type: String,
    required: function () {
      return this.role === "customer";
    },
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Restaurant",
    required: function () {
      return this.role === "restaurant_admin";
    },
  },
  isActive: {
    type: Boolean,
    default: false, // Default false for delivery and restaurant admins (needs approval)
  },
  status: {
    type: String,
    enum: ["pending", "approved", "rejected", "active"],
    default: function () {
      if (this.role === "delivery_personnel") return "pending";
      return "active";
    },
  },
  // Delivery personnel specific fields
  nicOrLicense: {
    type: String,
    required: function () {
      return this.role === "delivery_personnel";
    },
  },
  vehicleInfo: {
    type: {
      type: String,
      enum: ["bike", "car", "scooter", "bicycle"],
      required: function () {
        return this.role === "delivery_personnel";
      },
    },
    number: {
      type: String,
      required: function () {
        return this.role === "delivery_personnel";
      },
    },
  },
  documents: [
    {
      type: String, // URLs to uploaded documents
      required: function () {
        return this.role === "delivery_personnel";
      },
    },
  ],
  // Verification fields
  emailVerified: {
    type: Boolean,
    default: false,
  },
  phoneVerified: {
    type: Boolean,
    default: false,
  },
  verificationToken: String,
  verificationTokenExpires: Date,
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

userSchema.index(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: { role: { $ne: "delivery_personnel" } },
  }
);

userSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("users", userSchema);


/* File: ./server\user-service\routes\userRoutes.js */
const express = require("express");
const router = express.Router();
const upload = require("../utils/multer");
const {
  verifyToken,
  // Admin
  createAdmin,

  // Restaurant Admin
  //requestRestaurantAdminAccess,
  //approveRestaurantAdmin,
  createRestaurantAdmin,  // <-- Import the new controller for creating restaurant admin
  getAdminsByRestaurant,
  removeRestaurantAdmin,
  
  // Customer
  registerCustomer,

  // Delivery
  registerDeliveryPerson,
  approveDeliveryPerson,

  // Common
  login,
  getMe,
  updateMe,
  getAllUsers,
  getUser,
  updateUser,
  deleteUser,
} = require("../controllers/userController");
const authMiddleware = require("../utils/authMiddleware");

// ==================== PUBLIC ROUTES ====================
// Restaurant admin request access
//router.post("/restaurant-admin/request", requestRestaurantAdminAccess);

// Customer registration
router.post("/customers/register", registerCustomer);

// Delivery personnel registration
router.post(
  "/delivery/register",
  upload.array("documents", 3),
  registerDeliveryPerson
);

// Login (all roles)
router.post("/login", login);

// ==================== AUTHENTICATED USER ROUTES ====================
// These routes require any authenticated user (customer, admin, etc.)
router.use(
  authMiddleware([
    "customer",
    "restaurant_admin",
    "delivery_personnel",
    "admin",
  ])
);

// Profile management (must come BEFORE any parameterized routes)
router.get("/me", getMe);
router.patch("/update-me", updateMe);
router.get('/verify-token', verifyToken);

// ==================== ADMIN PROTECTED ROUTES ====================
// These routes require admin role
router.use(authMiddleware(["admin"]));

// Admin user management
router.post("/admins", createAdmin);
//router.patch("/restaurant-admin/approve", approveRestaurantAdmin);
router.patch("/delivery/approve", approveDeliveryPerson);

// User management
router.get("/", getAllUsers);
router.get("/:id", getUser);
router.patch("/:id", updateUser);
router.delete("/:id", deleteUser);

// ==================== RESTAURANT ADMIN ROUTEs ====================

router.post('/restaurant-admin', 
  authMiddleware(['admin']), 
  createRestaurantAdmin
);

router.get('/restaurant/:restaurantId/admins', 
  authMiddleware(['admin']), 
  getAdminsByRestaurant
);

router.delete('/restaurant-admin/:adminId', 
  authMiddleware(['admin']), 
  removeRestaurantAdmin
);

module.exports = router;

/* File: ./server\user-service\services\authService.js */
const jwt = require("jsonwebtoken");
const mongoose = require("mongoose");
require("dotenv").config();

const { JWT_SECRET, JWT_EXPIRES_IN } = process.env;

module.exports = {
  generateToken: (userId, role) => {
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error("Invalid user ID for token generation");
    }
    return jwt.sign({ id: userId, role }, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
    });
  },

  verifyToken: (token) => {
    console.log("[AUTH] Verifying token:", token);
    if (!token) {
      throw new Error("No token provided");
    }
    return jwt.verify(token, JWT_SECRET);
  },
};


/* File: ./server\user-service\services\emailService.js */
// ./server/user-service/services/emailService.js
const nodemailer = require("nodemailer");
require("dotenv").config();

async function sendEmail(to, subject, text, html) {
  // Create a transporter using Gmail SMTP
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.G_USER, // your Gmail address
      pass: process.env.G_PASS, // your App Password (not Gmail password)
    },
  });

  // Send mail with defined transport object
  let info = await transporter.sendMail({
    from: `"TastyTrail" <${process.env.G_USER}>`,
    to,
    subject,
    text,
    html,
  });

  console.log("Message sent: %s", info.messageId);
  return info;
}

module.exports = { sendEmail };


/* File: ./server\user-service\services\notificationService.js */
const nodemailer = require("nodemailer");
require("dotenv").config();

const { EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASS, ADMIN_EMAIL } =
  process.env;

const emailTransporter = nodemailer.createTransport({
  host: EMAIL_HOST,
  port: EMAIL_PORT,
  secure: true,
  auth: {
    user: EMAIL_USER,
    pass: EMAIL_PASS,
  },
});

module.exports = {
  // Email Notifications
  sendEmailNotification: async (email, subject, message) => {
    try {
      await emailTransporter.sendMail({
        from: `"Food Delivery App" <${EMAIL_USER}>`,
        to: email,
        subject,
        text: message,
        html: `<p>${message}</p>`,
      });
      return true;
    } catch (error) {
      console.error("Error sending email:", error);
      return false;
    }
  },

  // Verification Email
  sendVerificationEmail: async (email, token) => {
    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${token}`;
    const message = `Please verify your email by clicking the link: ${verificationUrl}`;

    return this.sendEmailNotification(
      email,
      "Verify Your Email Address",
      message
    );
  },

  // Welcome Notifications
  sendWelcomeNotification: async (
    userId,
    email,
    message = "Welcome to our platform!"
  ) => {
    return this.sendEmailNotification(
      email,
      "Welcome to Food Delivery App",
      message
    );
  },

  // Admin Notifications
  sendAdminNotification: async (subject, message) => {
    return this.sendEmailNotification(ADMIN_EMAIL, subject, message);
  },

  // Password Reset
  sendPasswordResetEmail: async (email, resetToken) => {
    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;
    const message = `You requested a password reset. Click here to reset: ${resetUrl}`;

    return this.sendEmailNotification(email, "Password Reset Request", message);
  },
};


/* File: ./server\user-service\tests\mailtest.js */
const nodemailer = require("nodemailer");
require("dotenv").config();

// Create transporter using Gmail
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.G_USER,
    pass: process.env.G_PASS,
  },
});

// Email options
const mailOptions = {
  from: `"Bob from Your Business" <${process.env.G_USER}>`,
  to: "segroup80@gmail.com",
  subject: "Welcome! Your free trial is ready.",
  text: "Hey there! Welcome to Your Business. We're happy to have you!",
  html: `
    <p>Hey there!</p>
    <p>Welcome to Your Business, we're happy to have you here!</p>
    <p>Your free trial awaits — just log in and get started.</p>
    <br>
    <p>Regards,</p>
    <p>The Your Business Team</p>
  `,
};

// Send the email
transporter.sendMail(mailOptions, (error, info) => {
  if (error) {
    console.error("Error sending email:", error);
  } else {
    console.log("Email sent successfully:", info.response);
  }
});


/* File: ./server\user-service\utils\authMiddleware.js */
const jwt = require("jsonwebtoken");
const authService = require("../services/authService");
const User = require("../models/User");
const mongoose = require("mongoose");
require("dotenv").config();

module.exports = (allowedRoles) => {
  return async (req, res, next) => {
    // 1) Get token from header
    let token;
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    }

    console.log("[DEBUG] Token from header:", req.headers.authorization);

    if (!token) {
      return res.status(401).json({
        message: "You are not logged in! Please log in to get access.",
      });
    }

    try {
      // 2) Verify token
      const decoded = authService.verifyToken(token);
      console.log("[DEBUG] Decoded Token:", decoded);

      if (!mongoose.Types.ObjectId.isValid(decoded.id)) {
        return res.status(401).json({ message: "Invalid user ID in token" });
      }

      // 3) Check if user still exists
      const currentUser = await User.findById(decoded.id);
      console.log("[DEBUG] Current User:", currentUser);
      if (!currentUser) {
        return res.status(401).json({
          message: "User no longer exists",
        });
      }

      // 4) Check if user role is allowed
      if (!allowedRoles.includes(decoded.role)) {
        return res.status(403).json({
          message: "You do not have permission to perform this action",
        });
      }

      // 5) Grant access to protected route
      req.user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({
        message: "Invalid token. Please log in again. by AuthMiddleware",
      });
    }
  };
};


/* File: ./server\user-service\utils\errorHandler.js */
module.exports = (err, req, res, next) => {
  console.error(err.stack);

  // Mongoose validation error
  if (err.name === "ValidationError") {
    const messages = Object.values(err.errors).map((val) => val.message);
    return res.status(400).json({
      message: "Validation error",
      details: messages,
    });
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    return res.status(400).json({
      message: "Duplicate field value",
      details: `${field} already exists`,
    });
  }

  if (err.name === "CastError") {
    return res.status(400).json({
      message: "Invalid ID format",
    });
  }

  // JWT errors
  if (err.name === "JsonWebTokenError") {
    return res.status(401).json({
      message: "Invalid token. Please log in again.",
    });
  }

  if (err.name === "TokenExpiredError") {
    return res.status(401).json({
      message: "Your token has expired! Please log in again.",
    });
  }

  // Default error handling
  res.status(500).json({
    message: "Something went wrong",
  });
};


/* File: ./server\user-service\utils\multer.js */
const multer = require("multer");
const path = require("path");

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/documents/");
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(
      null,
      file.fieldname + "-" + uniqueSuffix + path.extname(file.originalname)
    );
  },
});

const fileFilter = (req, file, cb) => {
  const filetypes = /jpeg|jpg|png|pdf/;
  const mimetype = filetypes.test(file.mimetype);
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());

  if (mimetype && extname) {
    return cb(null, true);
  }
  cb(new Error("Only images (JPEG, JPG, PNG) and PDFs are allowed"));
};

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: fileFilter,
});

module.exports = upload;


/* File: ./server\user-service\utils\passwordUtils.js */
const bcrypt = require("bcryptjs");

module.exports = {
  hashPassword: async (password) => {
    return await bcrypt.hash(password, 12);
  },

  comparePassword: async (candidatePassword, userPassword) => {
    return await bcrypt.compare(candidatePassword, userPassword);
  },

  generateRandomPassword: () => {
    const length = 12;
    const charset =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+~`|}{[]:;?><,./-=";
    let password = "";
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  },
};

