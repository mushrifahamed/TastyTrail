
/* File: ./server/user-service\server.js */
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const morgan = require("morgan");
const connectDB = require("./config/db");
const userRoutes = require("./routes/userRoutes");
const errorHandler = require("./utils/errorHandler");
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan("dev"));

// Database connection
connectDB();

// Routes
app.use("/api/users", userRoutes);

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`User service running on port ${PORT}`);
});

module.exports = app;


/* File: ./server/user-service\config\db.js */
const mongoose = require("mongoose");
require("dotenv").config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("MongoDB connected successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


/* File: ./server/user-service\controllers\userController.js */
const User = require("../models/User");
const jwt = require("jsonwebtoken");
const authService = require("../services/authService");
const notificationService = require("../services/notificationService");
const passwordUtils = require("../utils/passwordUtils");
const { JWT_SECRET, JWT_EXPIRES_IN } = process.env;

// Register a new user
const register = async (req, res, next) => {
  try {
    const { name, email, phone, password, role, address, restaurantId } =
      req.body;

    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "Email already in use" });
    }

    // Hash password
    const hashedPassword = await passwordUtils.hashPassword(password);

    // Create user
    const user = await User.create({
      name,
      email,
      phone,
      password: hashedPassword,
      role,
      address,
      restaurantId,
    });

    // Generate JWT token
    const token = authService.generateToken(user._id, user.role);

    // Send welcome notification
    await notificationService.sendWelcomeNotification(user._id, user.email);

    res.status(201).json({
      status: "success",
      token,
      data: {
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// Login user
const login = async (req, res, next) => {
  try {
    const { email, password } = req.body;

    // Check if user exists and password is correct
    const user = await User.findOne({ email }).select("+password");
    if (
      !user ||
      !(await passwordUtils.comparePassword(password, user.password))
    ) {
      return res.status(401).json({ message: "Invalid email or password" });
    }

    // Check if user is active
    if (!user.isActive) {
      return res.status(403).json({ message: "Account is deactivated" });
    }

    // Generate JWT token
    const token = authService.generateToken(user._id, user.role);

    res.status(200).json({
      status: "success",
      token,
      data: {
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get current user profile
const getMe = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    res.status(200).json({
      status: "success",
      data: {
        user,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Update user profile
const updateMe = async (req, res, next) => {
  try {
    // Filter out unwanted fields
    const filteredBody = {};
    const allowedFields = ["name", "email", "phone", "address"];
    allowedFields.forEach((field) => {
      if (req.body[field]) filteredBody[field] = req.body[field];
    });

    const updatedUser = await User.findByIdAndUpdate(
      req.user.id,
      filteredBody,
      { new: true, runValidators: true }
    );

    res.status(200).json({
      status: "success",
      data: {
        user: updatedUser,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get all users (admin only)
const getAllUsers = async (req, res, next) => {
  try {
    const users = await User.find();
    res.status(200).json({
      status: "success",
      results: users.length,
      data: {
        users,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Get user by ID (admin only)
const getUser = async (req, res, next) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(200).json({
      status: "success",
      data: {
        user,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Update user (admin only)
const updateUser = async (req, res, next) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(200).json({
      status: "success",
      data: {
        user: updatedUser,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Delete user (admin only)
const deleteUser = async (req, res, next) => {
  try {
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { isActive: false },
      { new: true }
    );
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(204).json({
      status: "success",
      data: null,
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  register,
  login,
  getMe,
  updateMe,
  getAllUsers,
  getUser,
  updateUser,
  deleteUser,
};


/* File: ./server/user-service\models\User.js */
const mongoose = require("mongoose");
const validator = require("validator");

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, "Please provide your name"],
    trim: true,
  },
  email: {
    type: String,
    required: [true, "Please provide your email"],
    unique: true,
    lowercase: true,
    validate: [validator.isEmail, "Please provide a valid email"],
  },
  phone: {
    type: String,
    required: [true, "Please provide your phone number"],
    validate: {
      validator: function (v) {
        return /^\+?[\d\s-]{10,}$/.test(v);
      },
      message: (props) => `${props.value} is not a valid phone number!`,
    },
  },
  password: {
    type: String,
    required: [true, "Please provide a password"],
    minlength: 8,
    select: false,
  },
  role: {
    type: String,
    enum: ["customer", "restaurant_admin", "delivery_personnel", "admin"],
    default: "customer",
  },
  address: {
    type: String,
    required: function () {
      return this.role === "customer" || this.role === "delivery_personnel";
    },
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Restaurant",
    required: function () {
      return this.role === "restaurant_admin";
    },
  },
  isActive: {
    type: Boolean,
    default: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

userSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model("User", userSchema);


/* File: ./server/user-service\routes\userRoutes.js */
const express = require("express");
const router = express.Router();
const {
  register,
  login,
  getMe,
  updateMe,
  getAllUsers,
  getUser,
  updateUser,
  deleteUser,
} = require("../controllers/userController");
const authMiddleware = require("../utils/authMiddleware");

// Public routes
router.post("/register", register);
router.post("/login", login);

// Protected routes (require authentication)
router.use(
  authMiddleware([
    "customer",
    "restaurant_admin",
    "delivery_personnel",
    "admin",
  ])
);

router.get("/me", getMe);
router.patch("/updateMe", updateMe);

// Admin-only routes
router.use(authMiddleware(["admin"]));

router.get("/", getAllUsers);
router.get("/:id", getUser);
router.patch("/:id", updateUser);
router.delete("/:id", deleteUser);

module.exports = router;


/* File: ./server/user-service\services\authService.js */
const jwt = require("jsonwebtoken");
require("dotenv").config();

const { JWT_SECRET, JWT_EXPIRES_IN } = process.env;

module.exports = {
  generateToken: (userId, role) => {
    return jwt.sign({ id: userId, role }, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
    });
  },

  verifyToken: (token) => {
    return jwt.verify(token, JWT_SECRET);
  },
};


/* File: ./server/user-service\services\notificationService.js */
const axios = require("axios");
require("dotenv").config();

const { NOTIFICATION_SERVICE_URL } = process.env;

module.exports = {
  sendWelcomeNotification: async (userId, email) => {
    try {
      await axios.post(`${NOTIFICATION_SERVICE_URL}/api/notifications`, {
        userId,
        type: "welcome",
        message: "Welcome to our food delivery platform!",
        metadata: {
          email,
        },
      });
    } catch (error) {
      console.error("Error sending welcome notification:", error);
      // Fail silently as notification is not critical
    }
  },

  sendPasswordResetNotification: async (userId, resetToken) => {
    try {
      await axios.post(`${NOTIFICATION_SERVICE_URL}/api/notifications`, {
        userId,
        type: "password_reset",
        message: "You have requested a password reset",
        metadata: {
          resetToken,
        },
      });
    } catch (error) {
      console.error("Error sending password reset notification:", error);
      // Fail silently as notification is not critical
    }
  },
};


/* File: ./server/user-service\utils\authMiddleware.js */
const jwt = require("jsonwebtoken");
const authService = require("../services/authService");
require("dotenv").config();

module.exports = (allowedRoles) => {
  return (req, res, next) => {
    // 1) Get token from header
    let token;
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    }

    if (!token) {
      return res.status(401).json({
        message: "You are not logged in! Please log in to get access.",
      });
    }

    try {
      // 2) Verify token
      const decoded = authService.verifyToken(token);

      // 3) Check if user still exists (would need to query DB)
      // This would be added if we wanted to verify user still exists

      // 4) Check if user role is allowed
      if (!allowedRoles.includes(decoded.role)) {
        return res.status(403).json({
          message: "You do not have permission to perform this action",
        });
      }

      // 5) Grant access to protected route
      req.user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({
        message: "Invalid token. Please log in again.",
      });
    }
  };
};


/* File: ./server/user-service\utils\errorHandler.js */
module.exports = (err, req, res, next) => {
  console.error(err.stack);

  // Mongoose validation error
  if (err.name === "ValidationError") {
    const messages = Object.values(err.errors).map((val) => val.message);
    return res.status(400).json({
      message: "Validation error",
      details: messages,
    });
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    return res.status(400).json({
      message: "Duplicate field value",
      details: `${field} already exists`,
    });
  }

  // JWT errors
  if (err.name === "JsonWebTokenError") {
    return res.status(401).json({
      message: "Invalid token. Please log in again.",
    });
  }

  if (err.name === "TokenExpiredError") {
    return res.status(401).json({
      message: "Your token has expired! Please log in again.",
    });
  }

  // Default error handling
  res.status(500).json({
    message: "Something went wrong",
  });
};


/* File: ./server/user-service\utils\passwordUtils.js */
const bcrypt = require("bcryptjs");

module.exports = {
  hashPassword: async (password) => {
    return await bcrypt.hash(password, 12);
  },

  comparePassword: async (candidatePassword, userPassword) => {
    return await bcrypt.compare(candidatePassword, userPassword);
  },

  generateRandomPassword: () => {
    const length = 12;
    const charset =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+~`|}{[]:;?><,./-=";
    let password = "";
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  },
};

